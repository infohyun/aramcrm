<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --bg: #f5f5f7;
    --card-bg: #ffffff;
    --text-primary: #1d1d1f;
    --text-secondary: #86868b;
    --accent: #0071e3;
    --accent-hover: #0077ED;
    --light-square: #f0e6d6;
    --dark-square: #b58863;
    --light-square-highlight: #f7ec8f;
    --dark-square-highlight: #dac34b;
    --light-square-move: #cde4c0;
    --dark-square-move: #9bc07e;
    --check-color: #ff3b30;
    --shadow: 0 4px 24px rgba(0,0,0,0.08);
    --shadow-lg: 0 12px 40px rgba(0,0,0,0.12);
    --radius: 18px;
    --radius-sm: 12px;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }

  /* Header */
  .header {
    width: 100%;
    padding: 20px 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.72);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    border-bottom: 1px solid rgba(0,0,0,0.06);
    position: sticky;
    top: 0;
    z-index: 100;
  }

  .header h1 {
    font-size: 21px;
    font-weight: 600;
    letter-spacing: -0.3px;
    color: var(--text-primary);
  }

  /* Main Layout */
  .main {
    display: flex;
    gap: 32px;
    padding: 40px 20px 60px;
    max-width: 1200px;
    width: 100%;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  /* Player Card */
  .player-card {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 24px 28px;
    min-width: 200px;
    transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
    border: 2px solid transparent;
  }

  .player-card.active {
    border-color: var(--accent);
    box-shadow: var(--shadow-lg), 0 0 0 4px rgba(0,113,227,0.1);
    transform: translateY(-2px);
  }

  .player-card .player-label {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-secondary);
    margin-bottom: 8px;
  }

  .player-card .player-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .player-card .player-name .piece-icon {
    font-size: 28px;
    line-height: 1;
  }

  .player-card .captured {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    min-height: 32px;
    font-size: 22px;
    line-height: 1;
    opacity: 0.7;
  }

  .player-card .score-diff {
    font-size: 14px;
    font-weight: 600;
    color: var(--accent);
    margin-top: 6px;
  }

  /* Board Container */
  .board-container {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    padding: 20px;
    position: relative;
  }

  .board-wrapper {
    position: relative;
  }

  /* Coordinates */
  .coords-row {
    display: flex;
    padding-left: 28px;
    padding-right: 28px;
  }

  .coords-row span {
    width: 72px;
    text-align: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    padding: 4px 0;
    user-select: none;
  }

  .board-with-coords {
    display: flex;
  }

  .coords-col {
    display: flex;
    flex-direction: column;
    justify-content: stretch;
  }

  .coords-col span {
    height: 72px;
    width: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    user-select: none;
  }

  /* Board */
  .board {
    display: grid;
    grid-template-columns: repeat(8, 72px);
    grid-template-rows: repeat(8, 72px);
    border-radius: 4px;
    overflow: hidden;
    cursor: pointer;
  }

  .square {
    width: 72px;
    height: 72px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 46px;
    line-height: 1;
    user-select: none;
    position: relative;
    transition: background-color 0.15s ease;
  }

  .square.light { background: var(--light-square); }
  .square.dark { background: var(--dark-square); }

  .square.selected.light { background: var(--light-square-highlight); }
  .square.selected.dark { background: var(--dark-square-highlight); }

  .square.last-move.light { background: var(--light-square-highlight); }
  .square.last-move.dark { background: var(--dark-square-highlight); }

  .square.check {
    background: radial-gradient(ellipse at center, var(--check-color) 0%, rgba(255,0,0,0.4) 40%, transparent 70%) !important;
  }

  .square .move-indicator {
    position: absolute;
    width: 18px;
    height: 18px;
    background: rgba(0,0,0,0.15);
    border-radius: 50%;
    pointer-events: none;
  }

  .square .capture-indicator {
    position: absolute;
    width: 66px;
    height: 66px;
    border: 5px solid rgba(0,0,0,0.15);
    border-radius: 50%;
    pointer-events: none;
  }

  .square .piece {
    position: relative;
    z-index: 2;
    text-shadow: 0 1px 3px rgba(0,0,0,0.15);
    transition: transform 0.1s ease;
    cursor: grab;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
  }

  .square:hover .piece {
    transform: scale(1.08);
  }

  /* Status Bar */
  .status-bar {
    margin-top: 20px;
    padding: 14px 24px;
    background: var(--bg);
    border-radius: var(--radius-sm);
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-secondary);
    transition: all 0.3s ease;
  }

  .status-bar.important {
    background: var(--accent);
    color: white;
  }

  /* Buttons */
  .controls {
    display: flex;
    gap: 12px;
    margin-top: 16px;
    justify-content: center;
  }

  .btn {
    padding: 10px 24px;
    border: none;
    border-radius: 980px;
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
    outline: none;
  }

  .btn-primary {
    background: var(--accent);
    color: white;
  }

  .btn-primary:hover {
    background: var(--accent-hover);
    transform: scale(1.02);
  }

  .btn-secondary {
    background: rgba(0,0,0,0.06);
    color: var(--text-primary);
  }

  .btn-secondary:hover {
    background: rgba(0,0,0,0.1);
    transform: scale(1.02);
  }

  /* Move History */
  .move-history-panel {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 24px;
    min-width: 200px;
    max-height: 620px;
    display: flex;
    flex-direction: column;
  }

  .move-history-panel h3 {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-secondary);
    margin-bottom: 16px;
  }

  .move-list {
    flex: 1;
    overflow-y: auto;
    font-size: 14px;
    scrollbar-width: thin;
  }

  .move-list::-webkit-scrollbar {
    width: 4px;
  }
  .move-list::-webkit-scrollbar-thumb {
    background: rgba(0,0,0,0.15);
    border-radius: 2px;
  }

  .move-row {
    display: flex;
    gap: 6px;
    padding: 4px 8px;
    border-radius: 6px;
    align-items: center;
  }

  .move-row:hover {
    background: rgba(0,0,0,0.03);
  }

  .move-num {
    color: var(--text-secondary);
    font-weight: 500;
    min-width: 28px;
    font-size: 12px;
  }

  .move-white, .move-black {
    min-width: 60px;
    font-weight: 500;
    padding: 2px 6px;
    border-radius: 4px;
  }

  .move-row:last-child .move-white,
  .move-row:last-child .move-black:not(:empty) {
    background: rgba(0,113,227,0.08);
    color: var(--accent);
  }

  /* Promotion Modal */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(8px);
    z-index: 200;
    align-items: center;
    justify-content: center;
  }

  .modal-overlay.show {
    display: flex;
  }

  .modal {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    padding: 32px;
    text-align: center;
    animation: modalIn 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
  }

  @keyframes modalIn {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 8px;
  }

  .modal p {
    color: var(--text-secondary);
    font-size: 15px;
    margin-bottom: 24px;
  }

  .promo-pieces {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  .promo-piece {
    width: 72px;
    height: 72px;
    font-size: 44px;
    border: 2px solid rgba(0,0,0,0.08);
    border-radius: var(--radius-sm);
    background: var(--bg);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .promo-piece:hover {
    border-color: var(--accent);
    background: rgba(0,113,227,0.05);
    transform: scale(1.08);
  }

  /* Responsive */
  @media (max-width: 1100px) {
    .move-history-panel { display: none; }
  }

  @media (max-width: 780px) {
    .main {
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 20px 12px 40px;
    }
    .player-card { min-width: 0; width: 100%; max-width: 420px; padding: 16px 20px; }
    .board-container { padding: 12px; }
    .square { width: 44px; height: 44px; font-size: 30px; }
    .board { grid-template-columns: repeat(8, 44px); grid-template-rows: repeat(8, 44px); }
    .coords-row span { width: 44px; font-size: 10px; }
    .coords-col span { height: 44px; width: 20px; font-size: 10px; }
    .coords-row { padding-left: 20px; padding-right: 20px; }
    .square .move-indicator { width: 12px; height: 12px; }
    .square .capture-indicator { width: 40px; height: 40px; border-width: 4px; }
  }
</style>
</head>
<body>

<div class="header">
  <h1>Chess</h1>
</div>

<div class="main">
  <!-- Black Player -->
  <div class="player-card" id="player-black">
    <div class="player-label">Black</div>
    <div class="player-name">
      <span class="piece-icon">&#9818;</span>
      Player 2
    </div>
    <div class="captured" id="captured-black"></div>
    <div class="score-diff" id="score-black"></div>
  </div>

  <!-- Board -->
  <div class="board-container">
    <div class="board-wrapper">
      <div class="coords-row" id="coords-top"></div>
      <div class="board-with-coords">
        <div class="coords-col" id="coords-left"></div>
        <div class="board" id="board"></div>
        <div class="coords-col" id="coords-right"></div>
      </div>
      <div class="coords-row" id="coords-bottom"></div>
    </div>

    <div class="status-bar" id="status">White's turn</div>

    <div class="controls">
      <button class="btn btn-secondary" onclick="undoMove()">Undo</button>
      <button class="btn btn-primary" onclick="newGame()">New Game</button>
    </div>
  </div>

  <!-- White Player -->
  <div class="player-card active" id="player-white">
    <div class="player-label">White</div>
    <div class="player-name">
      <span class="piece-icon">&#9812;</span>
      Player 1
    </div>
    <div class="captured" id="captured-white"></div>
    <div class="score-diff" id="score-white"></div>
  </div>

  <!-- Move History -->
  <div class="move-history-panel">
    <h3>Moves</h3>
    <div class="move-list" id="move-list"></div>
  </div>
</div>

<!-- Promotion Modal -->
<div class="modal-overlay" id="promo-modal">
  <div class="modal">
    <h2>Pawn Promotion</h2>
    <p>Choose a piece</p>
    <div class="promo-pieces" id="promo-pieces"></div>
  </div>
</div>

<script>
// Piece constants
const EMPTY = 0;
const WP = 1, WN = 2, WB = 3, WR = 4, WQ = 5, WK = 6;
const BP = 7, BN = 8, BB = 9, BR = 10, BQ = 11, BK = 12;

const PIECE_UNICODE = {
  [WK]: '\u2654', [WQ]: '\u2655', [WR]: '\u2656', [WB]: '\u2657', [WN]: '\u2658', [WP]: '\u2659',
  [BK]: '\u265A', [BQ]: '\u265B', [BR]: '\u265C', [BB]: '\u265D', [BN]: '\u265E', [BP]: '\u265F'
};

const PIECE_VALUES = { [WP]: 1, [WN]: 3, [WB]: 3, [WR]: 5, [WQ]: 9, [WK]: 0, [BP]: 1, [BN]: 3, [BB]: 3, [BR]: 5, [BQ]: 9, [BK]: 0 };

const PIECE_NAMES = { [WP]: '', [WN]: 'N', [WB]: 'B', [WR]: 'R', [WQ]: 'Q', [WK]: 'K', [BP]: '', [BN]: 'N', [BB]: 'B', [BR]: 'R', [BQ]: 'Q', [BK]: 'K' };

function isWhite(p) { return p >= 1 && p <= 6; }
function isBlack(p) { return p >= 7 && p <= 12; }
function colorOf(p) { return p === 0 ? null : isWhite(p) ? 'w' : 'b'; }

const FILES = 'abcdefgh';

// Game state
let board = [];
let turn = 'w';
let selected = null;
let legalMoves = [];
let lastMove = null;
let moveHistory = [];
let stateHistory = [];
let capturedByWhite = [];
let capturedByBlack = [];
let castleRights = { wk: true, wq: true, bk: true, bq: true };
let enPassantTarget = null;
let halfMoveClock = 0;
let fullMoveNumber = 1;
let gameOver = false;
let promotionPending = null;

function initBoard() {
  board = [
    [BR, BN, BB, BQ, BK, BB, BN, BR],
    [BP, BP, BP, BP, BP, BP, BP, BP],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [WP, WP, WP, WP, WP, WP, WP, WP],
    [WR, WN, WB, WQ, WK, WB, WN, WR]
  ];
}

function cloneBoard(b) { return b.map(r => [...r]); }

function saveState() {
  stateHistory.push({
    board: cloneBoard(board),
    turn,
    castleRights: { ...castleRights },
    enPassantTarget: enPassantTarget ? [...enPassantTarget] : null,
    halfMoveClock,
    fullMoveNumber,
    capturedByWhite: [...capturedByWhite],
    capturedByBlack: [...capturedByBlack],
    lastMove: lastMove ? { ...lastMove } : null,
    moveHistory: [...moveHistory]
  });
}

function undoMove() {
  if (stateHistory.length === 0 || gameOver) return;
  const s = stateHistory.pop();
  board = s.board;
  turn = s.turn;
  castleRights = s.castleRights;
  enPassantTarget = s.enPassantTarget;
  halfMoveClock = s.halfMoveClock;
  fullMoveNumber = s.fullMoveNumber;
  capturedByWhite = s.capturedByWhite;
  capturedByBlack = s.capturedByBlack;
  lastMove = s.lastMove;
  moveHistory = s.moveHistory;
  selected = null;
  legalMoves = [];
  render();
}

// Move generation
function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

function pseudoLegalMoves(b, color, castle, ep) {
  const moves = [];
  const isAlly = color === 'w' ? isWhite : isBlack;
  const isEnemy = color === 'w' ? isBlack : isWhite;

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = b[r][c];
      if (!isAlly(p)) continue;

      if (p === WP) {
        if (r > 0 && b[r-1][c] === 0) {
          moves.push({ fr: r, fc: c, tr: r-1, tc: c });
          if (r === 6 && b[r-2][c] === 0) moves.push({ fr: r, fc: c, tr: r-2, tc: c });
        }
        if (r > 0 && c > 0 && (isEnemy(b[r-1][c-1]) || (ep && ep[0] === r-1 && ep[1] === c-1)))
          moves.push({ fr: r, fc: c, tr: r-1, tc: c-1 });
        if (r > 0 && c < 7 && (isEnemy(b[r-1][c+1]) || (ep && ep[0] === r-1 && ep[1] === c+1)))
          moves.push({ fr: r, fc: c, tr: r-1, tc: c+1 });
      }
      else if (p === BP) {
        if (r < 7 && b[r+1][c] === 0) {
          moves.push({ fr: r, fc: c, tr: r+1, tc: c });
          if (r === 1 && b[r+2][c] === 0) moves.push({ fr: r, fc: c, tr: r+2, tc: c });
        }
        if (r < 7 && c > 0 && (isEnemy(b[r+1][c-1]) || (ep && ep[0] === r+1 && ep[1] === c-1)))
          moves.push({ fr: r, fc: c, tr: r+1, tc: c-1 });
        if (r < 7 && c < 7 && (isEnemy(b[r+1][c+1]) || (ep && ep[0] === r+1 && ep[1] === c+1)))
          moves.push({ fr: r, fc: c, tr: r+1, tc: c+1 });
      }
      else if (p === WN || p === BN) {
        for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
          const nr = r+dr, nc = c+dc;
          if (inBounds(nr, nc) && !isAlly(b[nr][nc])) moves.push({ fr: r, fc: c, tr: nr, tc: nc });
        }
      }
      else if (p === WB || p === BB) {
        for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = r+dr*i, nc = c+dc*i;
            if (!inBounds(nr, nc)) break;
            if (isAlly(b[nr][nc])) break;
            moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            if (isEnemy(b[nr][nc])) break;
          }
        }
      }
      else if (p === WR || p === BR) {
        for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = r+dr*i, nc = c+dc*i;
            if (!inBounds(nr, nc)) break;
            if (isAlly(b[nr][nc])) break;
            moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            if (isEnemy(b[nr][nc])) break;
          }
        }
      }
      else if (p === WQ || p === BQ) {
        for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = r+dr*i, nc = c+dc*i;
            if (!inBounds(nr, nc)) break;
            if (isAlly(b[nr][nc])) break;
            moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            if (isEnemy(b[nr][nc])) break;
          }
        }
      }
      else if (p === WK || p === BK) {
        for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
          const nr = r+dr, nc = c+dc;
          if (inBounds(nr, nc) && !isAlly(b[nr][nc])) moves.push({ fr: r, fc: c, tr: nr, tc: nc });
        }
        // Castling
        if (color === 'w' && r === 7 && c === 4) {
          if (castle.wk && b[7][5] === 0 && b[7][6] === 0 && b[7][7] === WR)
            moves.push({ fr: 7, fc: 4, tr: 7, tc: 6, castle: 'wk' });
          if (castle.wq && b[7][3] === 0 && b[7][2] === 0 && b[7][1] === 0 && b[7][0] === WR)
            moves.push({ fr: 7, fc: 4, tr: 7, tc: 2, castle: 'wq' });
        }
        if (color === 'b' && r === 0 && c === 4) {
          if (castle.bk && b[0][5] === 0 && b[0][6] === 0 && b[0][7] === BR)
            moves.push({ fr: 0, fc: 4, tr: 0, tc: 6, castle: 'bk' });
          if (castle.bq && b[0][3] === 0 && b[0][2] === 0 && b[0][1] === 0 && b[0][0] === BR)
            moves.push({ fr: 0, fc: 4, tr: 0, tc: 2, castle: 'bq' });
        }
      }
    }
  }
  return moves;
}

function isSquareAttacked(b, r, c, byColor) {
  const enemy = byColor === 'w' ? isWhite : isBlack;

  // Pawns
  if (byColor === 'w') {
    if (inBounds(r+1, c-1) && b[r+1][c-1] === WP) return true;
    if (inBounds(r+1, c+1) && b[r+1][c+1] === WP) return true;
  } else {
    if (inBounds(r-1, c-1) && b[r-1][c-1] === BP) return true;
    if (inBounds(r-1, c+1) && b[r-1][c+1] === BP) return true;
  }

  // Knights
  const kn = byColor === 'w' ? WN : BN;
  for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
    const nr = r+dr, nc = c+dc;
    if (inBounds(nr, nc) && b[nr][nc] === kn) return true;
  }

  // King
  const k = byColor === 'w' ? WK : BK;
  for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
    const nr = r+dr, nc = c+dc;
    if (inBounds(nr, nc) && b[nr][nc] === k) return true;
  }

  // Bishop/Queen diag
  const bish = byColor === 'w' ? WB : BB;
  const queen = byColor === 'w' ? WQ : BQ;
  for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
    for (let i = 1; i < 8; i++) {
      const nr = r+dr*i, nc = c+dc*i;
      if (!inBounds(nr, nc)) break;
      if (b[nr][nc] === bish || b[nr][nc] === queen) return true;
      if (b[nr][nc] !== 0) break;
    }
  }

  // Rook/Queen straight
  const rk = byColor === 'w' ? WR : BR;
  for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
    for (let i = 1; i < 8; i++) {
      const nr = r+dr*i, nc = c+dc*i;
      if (!inBounds(nr, nc)) break;
      if (b[nr][nc] === rk || b[nr][nc] === queen) return true;
      if (b[nr][nc] !== 0) break;
    }
  }

  return false;
}

function findKing(b, color) {
  const k = color === 'w' ? WK : BK;
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++)
      if (b[r][c] === k) return [r, c];
  return null;
}

function isInCheck(b, color) {
  const [kr, kc] = findKing(b, color);
  const enemy = color === 'w' ? 'b' : 'w';
  return isSquareAttacked(b, kr, kc, enemy);
}

function makeMoveOnBoard(b, m) {
  const nb = cloneBoard(b);
  const p = nb[m.fr][m.fc];

  // En passant capture
  if ((p === WP || p === BP) && m.tc !== m.fc && nb[m.tr][m.tc] === 0) {
    nb[m.fr][m.tc] = 0;
  }

  nb[m.tr][m.tc] = p;
  nb[m.fr][m.fc] = 0;

  // Castling rook
  if (m.castle === 'wk') { nb[7][5] = WR; nb[7][7] = 0; }
  if (m.castle === 'wq') { nb[7][3] = WR; nb[7][0] = 0; }
  if (m.castle === 'bk') { nb[0][5] = BR; nb[0][7] = 0; }
  if (m.castle === 'bq') { nb[0][3] = BR; nb[0][0] = 0; }

  // Promotion
  if (m.promo) nb[m.tr][m.tc] = m.promo;

  return nb;
}

function getLegalMoves(color) {
  const pseudo = pseudoLegalMoves(board, color, castleRights, enPassantTarget);
  const legal = [];

  for (const m of pseudo) {
    // Castling: check that king is not in check and doesn't pass through check
    if (m.castle) {
      const enemy = color === 'w' ? 'b' : 'w';
      if (isInCheck(board, color)) continue;
      if (m.castle === 'wk') {
        if (isSquareAttacked(board, 7, 5, enemy) || isSquareAttacked(board, 7, 6, enemy)) continue;
      }
      if (m.castle === 'wq') {
        if (isSquareAttacked(board, 7, 3, enemy) || isSquareAttacked(board, 7, 2, enemy)) continue;
      }
      if (m.castle === 'bk') {
        if (isSquareAttacked(board, 0, 5, enemy) || isSquareAttacked(board, 0, 6, enemy)) continue;
      }
      if (m.castle === 'bq') {
        if (isSquareAttacked(board, 0, 3, enemy) || isSquareAttacked(board, 0, 2, enemy)) continue;
      }
    }

    // Pawn promotion: generate all promotion options
    const p = board[m.fr][m.fc];
    if ((p === WP && m.tr === 0) || (p === BP && m.tr === 7)) {
      const promos = color === 'w' ? [WQ, WR, WB, WN] : [BQ, BR, BB, BN];
      for (const promo of promos) {
        const pm = { ...m, promo };
        const nb = makeMoveOnBoard(board, pm);
        if (!isInCheck(nb, color)) legal.push(pm);
      }
      continue;
    }

    const nb = makeMoveOnBoard(board, m);
    if (!isInCheck(nb, color)) legal.push(m);
  }

  return legal;
}

function getMovesFrom(r, c) {
  return getLegalMoves(turn).filter(m => m.fr === r && m.fc === c);
}

function getUniqueMovesTo(r, c) {
  const allLegal = getLegalMoves(turn);
  const moves = allLegal.filter(m => m.fr === selected[0] && m.fc === selected[1] && m.tr === r && m.tc === c);
  return moves;
}

// Execute move
function executeMove(m) {
  saveState();

  const p = board[m.fr][m.fc];
  let captured = board[m.tr][m.tc];

  // En passant capture
  if ((p === WP || p === BP) && m.tc !== m.fc && captured === 0) {
    captured = board[m.fr][m.tc];
    board[m.fr][m.tc] = 0;
  }

  if (captured) {
    if (isWhite(p)) capturedByWhite.push(captured);
    else capturedByBlack.push(captured);
  }

  // Build notation
  let notation = buildNotation(m, p, captured);

  board[m.tr][m.tc] = p;
  board[m.fr][m.fc] = 0;

  // Castling rook
  if (m.castle === 'wk') { board[7][5] = WR; board[7][7] = 0; }
  if (m.castle === 'wq') { board[7][3] = WR; board[7][0] = 0; }
  if (m.castle === 'bk') { board[0][5] = BR; board[0][7] = 0; }
  if (m.castle === 'bq') { board[0][3] = BR; board[0][0] = 0; }

  // Promotion
  if (m.promo) board[m.tr][m.tc] = m.promo;

  // Update castle rights
  if (p === WK) { castleRights.wk = false; castleRights.wq = false; }
  if (p === BK) { castleRights.bk = false; castleRights.bq = false; }
  if (p === WR && m.fr === 7 && m.fc === 0) castleRights.wq = false;
  if (p === WR && m.fr === 7 && m.fc === 7) castleRights.wk = false;
  if (p === BR && m.fr === 0 && m.fc === 0) castleRights.bq = false;
  if (p === BR && m.fr === 0 && m.fc === 7) castleRights.bk = false;
  if (m.tr === 0 && m.tc === 0) castleRights.bq = false;
  if (m.tr === 0 && m.tc === 7) castleRights.bk = false;
  if (m.tr === 7 && m.tc === 0) castleRights.wq = false;
  if (m.tr === 7 && m.tc === 7) castleRights.wk = false;

  // En passant
  if ((p === WP && m.fr - m.tr === 2)) enPassantTarget = [m.fr - 1, m.fc];
  else if ((p === BP && m.tr - m.fr === 2)) enPassantTarget = [m.fr + 1, m.fc];
  else enPassantTarget = null;

  lastMove = { fr: m.fr, fc: m.fc, tr: m.tr, tc: m.tc };

  // Switch turn
  const prevTurn = turn;
  turn = turn === 'w' ? 'b' : 'w';
  if (turn === 'w') fullMoveNumber++;

  // Check / checkmate / stalemate
  const inCheck = isInCheck(board, turn);
  const legal = getLegalMoves(turn);

  if (inCheck && legal.length === 0) {
    notation += '#';
    gameOver = true;
  } else if (inCheck) {
    notation += '+';
  } else if (legal.length === 0) {
    gameOver = true;
  }

  // Record notation
  if (prevTurn === 'w') {
    moveHistory.push({ num: fullMoveNumber - (turn === 'w' ? 0 : 1), white: notation, black: '' });
  } else {
    if (moveHistory.length > 0) moveHistory[moveHistory.length - 1].black = notation;
  }

  selected = null;
  legalMoves = [];
  render();
}

function buildNotation(m, p, captured) {
  if (m.castle === 'wk' || m.castle === 'bk') return 'O-O';
  if (m.castle === 'wq' || m.castle === 'bq') return 'O-O-O';

  let n = PIECE_NAMES[p] || '';
  const targetSq = FILES[m.tc] + (8 - m.tr);

  // Disambiguation for non-pawns
  if (n && n !== '') {
    const allLegal = getLegalMoves(colorOf(p));
    const same = allLegal.filter(om => om.tr === m.tr && om.tc === m.tc && board[om.fr][om.fc] === p && (om.fr !== m.fr || om.fc !== m.fc));
    if (same.length > 0) {
      const sameFile = same.some(om => om.fc === m.fc);
      const sameRank = same.some(om => om.fr === m.fr);
      if (!sameFile) n += FILES[m.fc];
      else if (!sameRank) n += (8 - m.fr);
      else n += FILES[m.fc] + (8 - m.fr);
    }
  }

  if ((p === WP || p === BP) && captured) n = FILES[m.fc];

  if (captured) n += 'x';
  n += targetSq;

  if (m.promo) {
    const promoNames = { [WQ]: 'Q', [WR]: 'R', [WB]: 'B', [WN]: 'N', [BQ]: 'Q', [BR]: 'R', [BB]: 'B', [BN]: 'N' };
    n += '=' + promoNames[m.promo];
  }

  return n;
}

// Click handling
function onSquareClick(r, c) {
  if (gameOver || promotionPending) return;

  const p = board[r][c];

  if (selected) {
    // Clicked same square -> deselect
    if (selected[0] === r && selected[1] === c) {
      selected = null;
      legalMoves = [];
      render();
      return;
    }

    // Clicked another own piece -> reselect
    if (p && colorOf(p) === turn) {
      selected = [r, c];
      legalMoves = getMovesFrom(r, c);
      render();
      return;
    }

    // Try to move
    const moves = legalMoves.filter(m => m.tr === r && m.tc === c);
    if (moves.length === 0) {
      selected = null;
      legalMoves = [];
      render();
      return;
    }

    // Check for promotion choices
    if (moves.length > 1 && moves[0].promo) {
      showPromotionModal(moves);
      return;
    }

    executeMove(moves[0]);
    return;
  }

  // Select piece
  if (p && colorOf(p) === turn) {
    selected = [r, c];
    legalMoves = getMovesFrom(r, c);
    render();
  }
}

function showPromotionModal(moves) {
  promotionPending = moves;
  const modal = document.getElementById('promo-modal');
  const container = document.getElementById('promo-pieces');
  container.innerHTML = '';

  const displayOrder = turn === 'w' ? [WQ, WR, WB, WN] : [BQ, BR, BB, BN];
  for (const promo of displayOrder) {
    const m = moves.find(mv => mv.promo === promo);
    if (!m) continue;
    const btn = document.createElement('div');
    btn.className = 'promo-piece';
    btn.textContent = PIECE_UNICODE[promo];
    btn.onclick = () => {
      modal.classList.remove('show');
      promotionPending = null;
      executeMove(m);
    };
    container.appendChild(btn);
  }
  modal.classList.add('show');
}

// Rendering
function render() {
  renderBoard();
  renderStatus();
  renderPlayers();
  renderMoveHistory();
}

function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';

  const inCheck = isInCheck(board, turn);
  const kingPos = findKing(board, turn);

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const sq = document.createElement('div');
      const isLight = (r + c) % 2 === 0;
      sq.className = 'square ' + (isLight ? 'light' : 'dark');

      // Last move highlight
      if (lastMove && ((lastMove.fr === r && lastMove.fc === c) || (lastMove.tr === r && lastMove.tc === c))) {
        sq.classList.add('last-move');
      }

      // Selected highlight
      if (selected && selected[0] === r && selected[1] === c) {
        sq.classList.add('selected');
      }

      // Check highlight
      if (inCheck && kingPos && kingPos[0] === r && kingPos[1] === c) {
        sq.classList.add('check');
      }

      // Legal move indicators
      const isLegalTarget = legalMoves.some(m => m.tr === r && m.tc === c);
      if (isLegalTarget) {
        if (board[r][c] !== 0 || (enPassantTarget && enPassantTarget[0] === r && enPassantTarget[1] === c && selected && (board[selected[0]][selected[1]] === WP || board[selected[0]][selected[1]] === BP))) {
          const ind = document.createElement('div');
          ind.className = 'capture-indicator';
          sq.appendChild(ind);
        } else {
          const ind = document.createElement('div');
          ind.className = 'move-indicator';
          sq.appendChild(ind);
        }
      }

      // Piece
      if (board[r][c] !== 0) {
        const piece = document.createElement('span');
        piece.className = 'piece';
        piece.textContent = PIECE_UNICODE[board[r][c]];
        sq.appendChild(piece);
      }

      sq.onclick = () => onSquareClick(r, c);
      boardEl.appendChild(sq);
    }
  }

  // Coordinates
  renderCoords();
}

function renderCoords() {
  const top = document.getElementById('coords-top');
  const bottom = document.getElementById('coords-bottom');
  const left = document.getElementById('coords-left');
  const right = document.getElementById('coords-right');

  top.innerHTML = '';
  bottom.innerHTML = '';
  left.innerHTML = '';
  right.innerHTML = '';

  for (let i = 0; i < 8; i++) {
    const ft = document.createElement('span');
    ft.textContent = FILES[i];
    top.appendChild(ft);

    const fb = document.createElement('span');
    fb.textContent = FILES[i];
    bottom.appendChild(fb);

    const rl = document.createElement('span');
    rl.textContent = 8 - i;
    left.appendChild(rl);

    const rr = document.createElement('span');
    rr.textContent = 8 - i;
    right.appendChild(rr);
  }
}

function renderStatus() {
  const statusEl = document.getElementById('status');
  const inCheck = isInCheck(board, turn);
  const legal = getLegalMoves(turn);

  if (gameOver) {
    if (inCheck) {
      const winner = turn === 'w' ? 'Black' : 'White';
      statusEl.textContent = `Checkmate! ${winner} wins!`;
      statusEl.className = 'status-bar important';
    } else {
      statusEl.textContent = 'Stalemate! Draw.';
      statusEl.className = 'status-bar important';
    }
  } else if (inCheck) {
    statusEl.textContent = (turn === 'w' ? 'White' : 'Black') + ' is in check!';
    statusEl.className = 'status-bar';
  } else {
    statusEl.textContent = (turn === 'w' ? "White's turn" : "Black's turn");
    statusEl.className = 'status-bar';
  }
}

function renderPlayers() {
  const wp = document.getElementById('player-white');
  const bp = document.getElementById('player-black');

  wp.classList.toggle('active', turn === 'w' && !gameOver);
  bp.classList.toggle('active', turn === 'b' && !gameOver);

  // Captured pieces
  const sortPieces = (arr) => [...arr].sort((a, b) => PIECE_VALUES[b] - PIECE_VALUES[a]);

  document.getElementById('captured-white').innerHTML = sortPieces(capturedByWhite).map(p => `<span>${PIECE_UNICODE[p]}</span>`).join('');
  document.getElementById('captured-black').innerHTML = sortPieces(capturedByBlack).map(p => `<span>${PIECE_UNICODE[p]}</span>`).join('');

  // Score diff
  const whiteScore = capturedByWhite.reduce((s, p) => s + PIECE_VALUES[p], 0);
  const blackScore = capturedByBlack.reduce((s, p) => s + PIECE_VALUES[p], 0);
  const diff = whiteScore - blackScore;

  document.getElementById('score-white').textContent = diff > 0 ? `+${diff}` : '';
  document.getElementById('score-black').textContent = diff < 0 ? `+${Math.abs(diff)}` : '';
}

function renderMoveHistory() {
  const list = document.getElementById('move-list');
  list.innerHTML = '';

  for (const m of moveHistory) {
    const row = document.createElement('div');
    row.className = 'move-row';
    row.innerHTML = `<span class="move-num">${m.num}.</span><span class="move-white">${m.white}</span><span class="move-black">${m.black}</span>`;
    list.appendChild(row);
  }

  list.scrollTop = list.scrollHeight;
}

function newGame() {
  initBoard();
  turn = 'w';
  selected = null;
  legalMoves = [];
  lastMove = null;
  moveHistory = [];
  stateHistory = [];
  capturedByWhite = [];
  capturedByBlack = [];
  castleRights = { wk: true, wq: true, bk: true, bq: true };
  enPassantTarget = null;
  halfMoveClock = 0;
  fullMoveNumber = 1;
  gameOver = false;
  promotionPending = null;
  render();
}

// Keyboard shortcut
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undoMove();
  }
});

// Init
newGame();
</script>
</body>
</html>
