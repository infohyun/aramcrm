<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>RACING - Neon Velocity</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --cyan: #00f0ff;
  --cyan-dim: #00f0ff44;
  --purple: #a855f7;
  --purple-dim: #a855f744;
  --gold: #f59e0b;
  --gold-dim: #f59e0b44;
  --red: #ef4444;
  --green: #22c55e;
  --bg: #05050f;
  --panel: rgba(10, 10, 30, 0.7);
  --glass: rgba(255, 255, 255, 0.03);
  --glass-border: rgba(255, 255, 255, 0.08);
  --text: #e2e8f0;
  --text-dim: rgba(255, 255, 255, 0.4);
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  font-family: 'Rajdhani', 'Noto Sans KR', sans-serif;
  color: var(--text);
  cursor: default;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

canvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 1;
}

/* ===== OVERLAY SYSTEM ===== */
.overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  transition: opacity 0.6s ease, visibility 0.6s ease;
  pointer-events: none;
}
.overlay.active { pointer-events: all; }
.overlay.hidden { opacity: 0; visibility: hidden; }

/* ===== MENU SCREEN ===== */
#menu {
  background: radial-gradient(ellipse at 50% 30%, rgba(0, 240, 255, 0.06) 0%, transparent 60%),
              radial-gradient(ellipse at 30% 70%, rgba(168, 85, 247, 0.04) 0%, transparent 50%);
}

.logo-container {
  text-align: center;
  margin-bottom: 50px;
  animation: logoFloat 6s ease-in-out infinite;
}

@keyframes logoFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-12px); }
}

.logo-title {
  font-family: 'Orbitron', monospace;
  font-size: clamp(48px, 10vw, 96px);
  font-weight: 900;
  letter-spacing: 12px;
  background: linear-gradient(135deg, var(--cyan) 0%, var(--purple) 50%, var(--gold) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  filter: drop-shadow(0 0 30px rgba(0, 240, 255, 0.4));
  line-height: 1.1;
}

.logo-subtitle {
  font-family: 'Orbitron', monospace;
  font-size: clamp(14px, 3vw, 24px);
  font-weight: 400;
  letter-spacing: 16px;
  color: var(--purple);
  margin-top: 8px;
  text-shadow: 0 0 20px rgba(168, 85, 247, 0.5);
}

.logo-line {
  width: 200px;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
  margin: 20px auto 0;
}

/* ===== GLASS PANELS ===== */
.glass-panel {
  background: rgba(10, 10, 30, 0.65);
  border: 1px solid var(--glass-border);
  border-radius: 16px;
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  padding: 30px 40px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4),
              inset 0 1px 0 rgba(255, 255, 255, 0.05);
}

/* ===== BUTTONS ===== */
.btn {
  font-family: 'Orbitron', monospace;
  font-size: 16px;
  font-weight: 600;
  letter-spacing: 3px;
  padding: 16px 48px;
  border: 1px solid;
  border-radius: 8px;
  cursor: pointer;
  background: transparent;
  transition: all 0.3s ease;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  top: 0; left: -100%;
  width: 100%; height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.08), transparent);
  transition: left 0.5s ease;
}

.btn:hover::before { left: 100%; }

.btn-primary {
  color: var(--cyan);
  border-color: var(--cyan);
  box-shadow: 0 0 15px rgba(0, 240, 255, 0.15), inset 0 0 15px rgba(0, 240, 255, 0.05);
}
.btn-primary:hover {
  background: rgba(0, 240, 255, 0.1);
  box-shadow: 0 0 30px rgba(0, 240, 255, 0.3), inset 0 0 30px rgba(0, 240, 255, 0.1);
  transform: translateY(-2px);
}

.btn-secondary {
  color: var(--purple);
  border-color: var(--purple);
  box-shadow: 0 0 15px rgba(168, 85, 247, 0.15), inset 0 0 15px rgba(168, 85, 247, 0.05);
}
.btn-secondary:hover {
  background: rgba(168, 85, 247, 0.1);
  box-shadow: 0 0 30px rgba(168, 85, 247, 0.3), inset 0 0 30px rgba(168, 85, 247, 0.1);
  transform: translateY(-2px);
}

.btn-gold {
  color: var(--gold);
  border-color: var(--gold);
  box-shadow: 0 0 15px rgba(245, 158, 11, 0.15), inset 0 0 15px rgba(245, 158, 11, 0.05);
}
.btn-gold:hover {
  background: rgba(245, 158, 11, 0.1);
  box-shadow: 0 0 30px rgba(245, 158, 11, 0.3), inset 0 0 30px rgba(245, 158, 11, 0.1);
  transform: translateY(-2px);
}

.menu-buttons {
  display: flex;
  flex-direction: column;
  gap: 16px;
  align-items: center;
}

.back-link {
  position: fixed;
  top: 16px;
  left: 16px;
  z-index: 20;
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  font-weight: 500;
  color: var(--text-dim);
  text-decoration: none;
  letter-spacing: 2px;
  padding: 8px 16px;
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 6px;
  background: rgba(10, 10, 30, 0.6);
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}
.back-link:hover {
  color: var(--cyan);
  border-color: rgba(0, 240, 255, 0.3);
  background: rgba(0, 240, 255, 0.05);
}

/* ===== HUD ===== */
#hud {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 5;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.5s ease;
}
#hud.active { opacity: 1; }

.hud-top {
  position: absolute;
  top: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 20px;
  align-items: center;
}

.hud-item {
  background: rgba(10, 10, 30, 0.6);
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  backdrop-filter: blur(12px);
  padding: 8px 18px;
  text-align: center;
  min-width: 90px;
}

.hud-label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  font-weight: 500;
  letter-spacing: 2px;
  color: var(--text-dim);
  text-transform: uppercase;
}

.hud-value {
  font-family: 'Orbitron', monospace;
  font-size: 20px;
  font-weight: 700;
  color: var(--cyan);
  text-shadow: 0 0 10px rgba(0, 240, 255, 0.4);
}

.hud-value.gold { color: var(--gold); text-shadow: 0 0 10px rgba(245, 158, 11, 0.4); }
.hud-value.purple { color: var(--purple); text-shadow: 0 0 10px rgba(168, 85, 247, 0.4); }

/* Speed gauge */
.gauge-container {
  position: absolute;
  bottom: 20px;
  right: 20px;
  width: 140px;
  height: 140px;
}

.gauge-bg {
  background: rgba(10, 10, 30, 0.6);
  border: 1px solid var(--glass-border);
  border-radius: 50%;
  backdrop-filter: blur(12px);
  width: 100%; height: 100%;
  position: relative;
  overflow: hidden;
}

.gauge-speed {
  position: absolute;
  bottom: 35px;
  width: 100%;
  text-align: center;
  font-family: 'Orbitron', monospace;
  font-size: 28px;
  font-weight: 800;
  color: var(--cyan);
  text-shadow: 0 0 15px rgba(0, 240, 255, 0.5);
}

.gauge-unit {
  position: absolute;
  bottom: 22px;
  width: 100%;
  text-align: center;
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  letter-spacing: 2px;
  color: var(--text-dim);
}

/* Power-up indicators */
.powerup-bar {
  position: absolute;
  bottom: 20px;
  left: 20px;
  display: flex;
  gap: 10px;
}

.powerup-slot {
  width: 50px; height: 50px;
  background: rgba(10, 10, 30, 0.6);
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  backdrop-filter: blur(12px);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 22px;
  opacity: 0.3;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}
.powerup-slot.active {
  opacity: 1;
  border-color: var(--cyan);
  box-shadow: 0 0 15px rgba(0, 240, 255, 0.2);
}

.powerup-timer {
  position: absolute;
  bottom: 0; left: 0;
  height: 3px;
  background: var(--cyan);
  border-radius: 0 0 10px 10px;
  transition: width 0.1s linear;
}

/* ===== GAME OVER ===== */
#gameover {
  background: radial-gradient(ellipse at 50% 40%, rgba(239, 68, 68, 0.06) 0%, transparent 60%);
}

.gameover-title {
  font-family: 'Orbitron', monospace;
  font-size: clamp(32px, 7vw, 64px);
  font-weight: 900;
  letter-spacing: 6px;
  color: var(--red);
  text-shadow: 0 0 40px rgba(239, 68, 68, 0.5);
  margin-bottom: 30px;
  text-align: center;
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin-bottom: 30px;
  min-width: 300px;
}

.stat-box {
  text-align: center;
  padding: 12px;
}

.stat-label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 500;
  letter-spacing: 2px;
  color: var(--text-dim);
  text-transform: uppercase;
  margin-bottom: 4px;
}

.stat-value {
  font-family: 'Orbitron', monospace;
  font-size: 24px;
  font-weight: 700;
}

.new-record {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 4px;
  color: var(--gold);
  text-shadow: 0 0 15px rgba(245, 158, 11, 0.5);
  margin-bottom: 20px;
  animation: recordPulse 1s ease-in-out infinite;
}

@keyframes recordPulse {
  0%, 100% { opacity: 1; transform: scale(1); }
  50% { opacity: 0.7; transform: scale(1.05); }
}

/* ===== CONTROLS HINT ===== */
.controls-hint {
  margin-top: 30px;
  text-align: center;
}
.controls-hint span {
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  color: var(--text-dim);
  letter-spacing: 1px;
}
.key-icon {
  display: inline-block;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 4px;
  padding: 2px 8px;
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  color: var(--text);
  margin: 0 2px;
}

/* ===== PAUSE SCREEN ===== */
#pause {
  background: rgba(5, 5, 15, 0.8);
}

.pause-title {
  font-family: 'Orbitron', monospace;
  font-size: clamp(28px, 6vw, 48px);
  font-weight: 800;
  letter-spacing: 8px;
  color: var(--purple);
  text-shadow: 0 0 30px rgba(168, 85, 247, 0.4);
  margin-bottom: 40px;
}

/* ===== MOBILE CONTROLS ===== */
.mobile-controls {
  position: fixed;
  bottom: 0; left: 0;
  width: 100%; height: 35%;
  z-index: 6;
  display: none;
  pointer-events: none;
}
.mobile-controls.active {
  display: flex;
  pointer-events: all;
}

.touch-zone {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
}
.touch-zone:active { opacity: 0.15; background: var(--cyan); }

@media (max-width: 768px) {
  .hud-top { gap: 10px; }
  .hud-item { padding: 6px 12px; min-width: 70px; }
  .hud-value { font-size: 16px; }
  .gauge-container { width: 100px; height: 100px; }
  .gauge-speed { font-size: 20px; bottom: 28px; }
  .gauge-unit { bottom: 16px; }
  .powerup-slot { width: 40px; height: 40px; font-size: 18px; }
  .stats-grid { min-width: 250px; }
  .stat-value { font-size: 20px; }
}

@media (max-width: 480px) {
  .hud-item { padding: 4px 8px; min-width: 60px; }
  .hud-value { font-size: 14px; }
  .hud-label { font-size: 8px; }
  .btn { padding: 12px 32px; font-size: 13px; letter-spacing: 2px; }
}
</style>
</head>
<body>

<a href="/games.html" class="back-link">&#9664; ARCADE</a>

<canvas id="gameCanvas"></canvas>

<!-- HUD -->
<div id="hud">
  <div class="hud-top">
    <div class="hud-item">
      <div class="hud-label">SCORE</div>
      <div class="hud-value" id="hudScore">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">COINS</div>
      <div class="hud-value gold" id="hudCoins">0</div>
    </div>
    <div class="hud-item">
      <div class="hud-label">DISTANCE</div>
      <div class="hud-value purple" id="hudDist">0m</div>
    </div>
  </div>

  <div class="gauge-container">
    <div class="gauge-bg">
      <canvas id="gaugeCanvas" width="140" height="140"></canvas>
      <div class="gauge-speed" id="gaugeSpeed">0</div>
      <div class="gauge-unit">KM/H</div>
    </div>
  </div>

  <div class="powerup-bar">
    <div class="powerup-slot" id="pw-shield">
      <span>&#9711;</span>
      <div class="powerup-timer" id="pt-shield"></div>
    </div>
    <div class="powerup-slot" id="pw-slow">
      <span>&#9202;</span>
      <div class="powerup-timer" id="pt-slow"></div>
    </div>
    <div class="powerup-slot" id="pw-magnet">
      <span>&#9883;</span>
      <div class="powerup-timer" id="pt-magnet"></div>
    </div>
  </div>
</div>

<!-- MOBILE CONTROLS -->
<div class="mobile-controls" id="mobileControls">
  <div class="touch-zone" id="touchLeft"></div>
  <div class="touch-zone" id="touchRight"></div>
</div>

<!-- MENU SCREEN -->
<div class="overlay active" id="menu">
  <div class="logo-container">
    <div class="logo-title">RACING</div>
    <div class="logo-subtitle">NEON VELOCITY</div>
    <div class="logo-line"></div>
  </div>
  <div class="glass-panel">
    <div class="menu-buttons">
      <button class="btn btn-primary" id="btnStart">START RACE</button>
      <button class="btn btn-secondary" id="btnHow">HOW TO PLAY</button>
      <div style="margin-top:8px;">
        <span style="font-family:'Orbitron';font-size:11px;color:var(--gold);letter-spacing:2px;">BEST: </span>
        <span style="font-family:'Orbitron';font-size:16px;font-weight:700;color:var(--gold);text-shadow:0 0 10px rgba(245,158,11,0.4);" id="menuBest">0</span>
      </div>
    </div>
  </div>
  <div class="controls-hint">
    <span><span class="key-icon">&#9664;</span> <span class="key-icon">&#9654;</span> or swipe to steer &nbsp;&middot;&nbsp; <span class="key-icon">P</span> pause</span>
  </div>
</div>

<!-- HOW TO PLAY -->
<div class="overlay hidden" id="howto">
  <div class="glass-panel" style="max-width:420px;text-align:center;">
    <div style="font-family:'Orbitron';font-size:18px;font-weight:700;letter-spacing:4px;color:var(--cyan);margin-bottom:20px;">HOW TO PLAY</div>
    <div style="font-family:'Rajdhani';font-size:15px;line-height:1.8;color:var(--text-dim);text-align:left;">
      <div style="margin-bottom:10px;"><span style="color:var(--cyan);">&#9654;</span> Use <b style="color:var(--text);">Arrow Keys</b> or <b style="color:var(--text);">Swipe</b> to change lanes</div>
      <div style="margin-bottom:10px;"><span style="color:var(--gold);">&#9679;</span> Collect <b style="color:var(--gold);">coins</b> and <b style="color:var(--purple);">gems</b> for bonus points</div>
      <div style="margin-bottom:10px;"><span style="color:var(--green);">&#9650;</span> Grab <b style="color:var(--green);">power-ups</b>: Shield, Slow-Time, Magnet</div>
      <div style="margin-bottom:10px;"><span style="color:var(--red);">&#9888;</span> <b style="color:var(--red);">Avoid</b> other vehicles on the road</div>
      <div><span style="color:var(--purple);">&#9733;</span> Speed <b style="color:var(--text);">increases</b> over time -- survive as long as you can!</div>
    </div>
    <button class="btn btn-primary" style="margin-top:24px;" id="btnBackHow">BACK</button>
  </div>
</div>

<!-- PAUSE SCREEN -->
<div class="overlay hidden" id="pause">
  <div class="pause-title">PAUSED</div>
  <div class="glass-panel">
    <div class="menu-buttons">
      <button class="btn btn-primary" id="btnResume">RESUME</button>
      <button class="btn btn-secondary" id="btnQuit">QUIT RACE</button>
    </div>
  </div>
</div>

<!-- GAME OVER SCREEN -->
<div class="overlay hidden" id="gameover">
  <div class="gameover-title">WRECKED</div>
  <div class="glass-panel">
    <div id="newRecordBanner" class="new-record" style="display:none;text-align:center;">&#9733; NEW RECORD &#9733;</div>
    <div class="stats-grid">
      <div class="stat-box">
        <div class="stat-label">SCORE</div>
        <div class="stat-value" style="color:var(--cyan);" id="goScore">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">BEST</div>
        <div class="stat-value" style="color:var(--gold);" id="goBest">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">DISTANCE</div>
        <div class="stat-value" style="color:var(--purple);" id="goDist">0m</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">COINS</div>
        <div class="stat-value" style="color:var(--gold);" id="goCoins">0</div>
      </div>
    </div>
    <div class="menu-buttons">
      <button class="btn btn-primary" id="btnRetry">RACE AGAIN</button>
      <button class="btn btn-gold" id="btnMenuGO">MAIN MENU</button>
    </div>
  </div>
</div>

<script>
// ================================================================
// RACING - NEON VELOCITY
// Premium top-down vertical scrolling dodge-racing game
// ================================================================

(function() {
'use strict';

// ===== CANVAS SETUP =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const gaugeCanvas = document.getElementById('gaugeCanvas');
const gaugeCtx = gaugeCanvas.getContext('2d');

let W, H;
function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  gaugeCanvas.width = 140;
  gaugeCanvas.height = 140;
}
resize();
window.addEventListener('resize', resize);

// ===== COLORS =====
const CYAN = '#00f0ff';
const PURPLE = '#a855f7';
const GOLD = '#f59e0b';
const RED = '#ef4444';
const GREEN = '#22c55e';
const PINK = '#ec4899';
const BLUE = '#3b82f6';
const WHITE = '#e2e8f0';
const BG = '#05050f';

// ===== AUDIO ENGINE =====
const AudioEngine = {
  ctx: null,
  muted: false,

  init() {
    try {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    } catch(e) {}
  },

  resume() {
    if (this.ctx && this.ctx.state === 'suspended') this.ctx.resume();
  },

  playTone(freq, dur, type, vol, detune) {
    if (!this.ctx || this.muted) return;
    try {
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.type = type || 'sine';
      o.frequency.value = freq;
      if (detune) o.detune.value = detune;
      g.gain.setValueAtTime(vol || 0.1, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + dur);
      o.connect(g);
      g.connect(this.ctx.destination);
      o.start();
      o.stop(this.ctx.currentTime + dur);
    } catch(e) {}
  },

  coin() {
    this.playTone(880, 0.12, 'sine', 0.12);
    setTimeout(() => this.playTone(1320, 0.15, 'sine', 0.1), 60);
  },

  gem() {
    this.playTone(660, 0.1, 'sine', 0.1);
    setTimeout(() => this.playTone(990, 0.1, 'sine', 0.1), 50);
    setTimeout(() => this.playTone(1320, 0.15, 'sine', 0.08), 100);
  },

  powerup() {
    for (let i = 0; i < 5; i++) {
      setTimeout(() => this.playTone(400 + i * 150, 0.15, 'sine', 0.08), i * 50);
    }
  },

  crash() {
    this.playTone(80, 0.4, 'sawtooth', 0.2);
    this.playTone(60, 0.5, 'square', 0.1);
    // noise burst
    if (!this.ctx) return;
    try {
      const bufferSize = this.ctx.sampleRate * 0.3;
      const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.1));
      const src = this.ctx.createBufferSource();
      const g = this.ctx.createGain();
      src.buffer = buffer;
      g.gain.setValueAtTime(0.15, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
      src.connect(g);
      g.connect(this.ctx.destination);
      src.start();
    } catch(e) {}
  },

  engineHum(speed) {
    // Short engine pulse
    const freq = 40 + speed * 0.3;
    this.playTone(freq, 0.08, 'sawtooth', 0.02);
  }
};

// ===== GAME STATE =====
const LANES = 5;
let roadW, laneW, roadX;
let state = 'menu'; // menu, playing, paused, gameover
let player, obstacles, coins, powerups, particles, trails, roadLines;
let score, coinCount, distance, speed, baseSpeed, maxSpeed, speedMul;
let shieldTimer, slowTimer, magnetTimer;
let shakeX, shakeY, shakeDur;
let engineTick;
let dt, lastTime;
let animFrame;
let isMobile;

// ===== INIT =====
function calcRoad() {
  roadW = Math.min(W * 0.55, 400);
  if (W < 500) roadW = W * 0.85;
  laneW = roadW / LANES;
  roadX = (W - roadW) / 2;
}

function laneCenter(lane) {
  return roadX + laneW * lane + laneW / 2;
}

function initGame() {
  calcRoad();
  player = {
    lane: Math.floor(LANES / 2),
    x: laneCenter(Math.floor(LANES / 2)),
    targetX: laneCenter(Math.floor(LANES / 2)),
    y: H - 120,
    w: laneW * 0.55,
    h: laneW * 1.1,
    alive: true,
    invincible: 0,
    trail: []
  };
  obstacles = [];
  coins = [];
  powerups = [];
  particles = [];
  trails = [];
  roadLines = [];

  score = 0;
  coinCount = 0;
  distance = 0;
  baseSpeed = 3;
  speed = baseSpeed;
  maxSpeed = 14;
  speedMul = 1;
  shieldTimer = 0;
  slowTimer = 0;
  magnetTimer = 0;
  shakeX = 0;
  shakeY = 0;
  shakeDur = 0;
  engineTick = 0;

  // Init road lines
  for (let i = 0; i < H + 40; i += 40) {
    roadLines.push(i);
  }
}

// ===== ENTITY SPAWNERS =====
const carColors = [RED, PURPLE, PINK, BLUE, GREEN, GOLD, '#ff6b35', '#00ff88'];

function spawnObstacle() {
  const lane = Math.floor(Math.random() * LANES);
  // Don't spawn on top of another close obstacle in same lane
  for (const ob of obstacles) {
    if (ob.lane === lane && ob.y < 100) return;
  }
  const color = carColors[Math.floor(Math.random() * carColors.length)];
  const w = laneW * 0.5;
  const h = laneW * (0.9 + Math.random() * 0.4);
  obstacles.push({
    lane,
    x: laneCenter(lane),
    y: -h,
    w, h,
    color,
    speed: speed * (0.3 + Math.random() * 0.3),
    trail: [],
    variant: Math.floor(Math.random() * 3)
  });
}

function spawnCoin() {
  const lane = Math.floor(Math.random() * LANES);
  const isGem = Math.random() < 0.15;
  coins.push({
    lane,
    x: laneCenter(lane),
    y: -20,
    r: isGem ? 12 : 9,
    isGem,
    angle: Math.random() * Math.PI * 2,
    collected: false
  });
}

function spawnPowerup() {
  const lane = Math.floor(Math.random() * LANES);
  const types = ['shield', 'slow', 'magnet'];
  const type = types[Math.floor(Math.random() * types.length)];
  const colors = { shield: CYAN, slow: PURPLE, magnet: GOLD };
  const symbols = { shield: '\u25CB', slow: '\u23F2', magnet: '\u269B' };
  powerups.push({
    lane,
    x: laneCenter(lane),
    y: -20,
    type,
    color: colors[type],
    symbol: symbols[type],
    angle: 0,
    pulse: 0
  });
}

// ===== PARTICLES =====
function emitParticles(x, y, color, count, spread, spd) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const vel = (spd || 3) * (0.5 + Math.random());
    particles.push({
      x, y,
      vx: Math.cos(angle) * vel * (spread || 1),
      vy: Math.sin(angle) * vel * (spread || 1),
      life: 1,
      decay: 0.015 + Math.random() * 0.02,
      color,
      size: 2 + Math.random() * 4
    });
  }
}

function emitCoinParticles(x, y, isGem) {
  const color = isGem ? PURPLE : GOLD;
  emitParticles(x, y, color, isGem ? 15 : 8, 1.5, 2);
}

// ===== SCREEN SHAKE =====
function triggerShake(dur, mag) {
  shakeDur = dur;
  shakeX = 0;
  shakeY = 0;
}

function updateShake(dt) {
  if (shakeDur > 0) {
    shakeDur -= dt;
    const mag = Math.min(shakeDur * 15, 8);
    shakeX = (Math.random() - 0.5) * mag;
    shakeY = (Math.random() - 0.5) * mag;
  } else {
    shakeX = 0;
    shakeY = 0;
  }
}

// ===== MOVEMENT =====
function movePlayerLeft() {
  if (player.lane > 0) {
    player.lane--;
    player.targetX = laneCenter(player.lane);
  }
}

function movePlayerRight() {
  if (player.lane < LANES - 1) {
    player.lane++;
    player.targetX = laneCenter(player.lane);
  }
}

// ===== INPUT =====
const keys = {};
let keyMoveCooldown = 0;

document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    e.preventDefault();
  }
  if (state === 'menu') {
    if (e.key === 'Enter' || e.key === ' ') startGame();
    return;
  }
  if (state === 'gameover') {
    if (e.key === 'Enter' || e.key === ' ') startGame();
    return;
  }
  if (state === 'playing') {
    if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') {
      pauseGame();
      return;
    }
    if (!keys[e.key]) {
      keys[e.key] = true;
      if (e.key === 'ArrowLeft') movePlayerLeft();
      if (e.key === 'ArrowRight') movePlayerRight();
    }
  }
  if (state === 'paused') {
    if (e.key === 'p' || e.key === 'P' || e.key === 'Escape') resumeGame();
  }
});

document.addEventListener('keyup', e => {
  keys[e.key] = false;
});

// Touch / swipe
let touchStartX = 0, touchStartY = 0;
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  AudioEngine.resume();
  if (state === 'playing') {
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
  }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  if (state === 'playing') {
    const touch = e.changedTouches[0];
    const dx = touch.clientX - touchStartX;
    const dy = touch.clientY - touchStartY;
    if (Math.abs(dx) > 20 && Math.abs(dx) > Math.abs(dy)) {
      if (dx < 0) movePlayerLeft();
      else movePlayerRight();
    }
  }
}, { passive: false });

// Mobile tap zones
document.getElementById('touchLeft').addEventListener('touchstart', e => {
  e.preventDefault();
  if (state === 'playing') movePlayerLeft();
});
document.getElementById('touchRight').addEventListener('touchstart', e => {
  e.preventDefault();
  if (state === 'playing') movePlayerRight();
});

// ===== COLLISION =====
function boxCollide(a, b) {
  return Math.abs(a.x - b.x) < (a.w + b.w) * 0.45 &&
         Math.abs(a.y - b.y) < (a.h + b.h) * 0.45;
}

function circleCollide(px, py, cx, cy, cr) {
  const dx = px - cx, dy = py - cy;
  return dx * dx + dy * dy < cr * cr;
}

// ===== UI MANAGEMENT =====
function showOverlay(id) {
  document.querySelectorAll('.overlay').forEach(o => {
    o.classList.remove('active');
    o.classList.add('hidden');
  });
  const el = document.getElementById(id);
  if (el) {
    el.classList.add('active');
    el.classList.remove('hidden');
  }
}

function hideAllOverlays() {
  document.querySelectorAll('.overlay').forEach(o => {
    o.classList.remove('active');
    o.classList.add('hidden');
  });
}

function updateHUD() {
  document.getElementById('hudScore').textContent = Math.floor(score);
  document.getElementById('hudCoins').textContent = coinCount;
  document.getElementById('hudDist').textContent = Math.floor(distance) + 'm';

  const displaySpeed = Math.floor(speed * 25);
  document.getElementById('gaugeSpeed').textContent = displaySpeed;

  // Power-up indicators
  const shield = document.getElementById('pw-shield');
  const slow = document.getElementById('pw-slow');
  const magnet = document.getElementById('pw-magnet');
  shield.classList.toggle('active', shieldTimer > 0);
  slow.classList.toggle('active', slowTimer > 0);
  magnet.classList.toggle('active', magnetTimer > 0);
  document.getElementById('pt-shield').style.width = shieldTimer > 0 ? (shieldTimer / 5 * 100) + '%' : '0%';
  document.getElementById('pt-slow').style.width = slowTimer > 0 ? (slowTimer / 5 * 100) + '%' : '0%';
  document.getElementById('pt-magnet').style.width = magnetTimer > 0 ? (magnetTimer / 5 * 100) + '%' : '0%';
}

function drawGauge() {
  const c = gaugeCtx;
  const cx = 70, cy = 70, r = 56;
  c.clearRect(0, 0, 140, 140);

  const startAngle = 0.75 * Math.PI;
  const endAngle = 2.25 * Math.PI;
  const speedPct = Math.min((speed - baseSpeed) / (maxSpeed - baseSpeed), 1);
  const currentAngle = startAngle + speedPct * (endAngle - startAngle);

  // Track
  c.beginPath();
  c.arc(cx, cy, r, startAngle, endAngle);
  c.strokeStyle = 'rgba(255,255,255,0.06)';
  c.lineWidth = 6;
  c.stroke();

  // Filled arc
  const grad = c.createLinearGradient(0, 0, 140, 140);
  grad.addColorStop(0, CYAN);
  grad.addColorStop(0.7, PURPLE);
  grad.addColorStop(1, RED);
  c.beginPath();
  c.arc(cx, cy, r, startAngle, currentAngle);
  c.strokeStyle = grad;
  c.lineWidth = 6;
  c.lineCap = 'round';
  c.stroke();

  // Ticks
  for (let i = 0; i <= 10; i++) {
    const a = startAngle + (i / 10) * (endAngle - startAngle);
    const x1 = cx + Math.cos(a) * (r - 10);
    const y1 = cy + Math.sin(a) * (r - 10);
    const x2 = cx + Math.cos(a) * (r - 4);
    const y2 = cy + Math.sin(a) * (r - 4);
    c.beginPath();
    c.moveTo(x1, y1);
    c.lineTo(x2, y2);
    c.strokeStyle = i <= speedPct * 10 ? CYAN : 'rgba(255,255,255,0.15)';
    c.lineWidth = i % 5 === 0 ? 2 : 1;
    c.stroke();
  }

  // Needle
  const nx = cx + Math.cos(currentAngle) * (r - 18);
  const ny = cy + Math.sin(currentAngle) * (r - 18);
  c.beginPath();
  c.moveTo(cx, cy);
  c.lineTo(nx, ny);
  c.strokeStyle = RED;
  c.lineWidth = 2;
  c.lineCap = 'round';
  c.stroke();

  // Center dot
  c.beginPath();
  c.arc(cx, cy, 4, 0, Math.PI * 2);
  c.fillStyle = RED;
  c.fill();
}

// ===== GAME FLOW =====
function startGame() {
  AudioEngine.init();
  AudioEngine.resume();
  initGame();
  state = 'playing';
  hideAllOverlays();
  document.getElementById('hud').classList.add('active');
  isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  if (isMobile) document.getElementById('mobileControls').classList.add('active');
  lastTime = performance.now();
  if (animFrame) cancelAnimationFrame(animFrame);
  gameLoop(performance.now());
}

function pauseGame() {
  state = 'paused';
  showOverlay('pause');
}

function resumeGame() {
  state = 'playing';
  hideAllOverlays();
  lastTime = performance.now();
  gameLoop(performance.now());
}

function gameOver() {
  state = 'gameover';
  player.alive = false;
  triggerShake(0.5, 10);
  AudioEngine.crash();

  // Big explosion
  emitParticles(player.x, player.y, CYAN, 30, 3, 5);
  emitParticles(player.x, player.y, RED, 20, 2, 4);
  emitParticles(player.x, player.y, GOLD, 15, 2.5, 3);

  const totalScore = Math.floor(score);
  let best = parseInt(localStorage.getItem('racing_best') || '0');
  const isNew = totalScore > best;
  if (isNew) {
    best = totalScore;
    localStorage.setItem('racing_best', best.toString());
  }

  // Delay showing overlay for crash effect
  setTimeout(() => {
    document.getElementById('goScore').textContent = totalScore;
    document.getElementById('goBest').textContent = best;
    document.getElementById('goDist').textContent = Math.floor(distance) + 'm';
    document.getElementById('goCoins').textContent = coinCount;
    document.getElementById('newRecordBanner').style.display = isNew ? 'block' : 'none';
    showOverlay('gameover');
    document.getElementById('hud').classList.remove('active');
    if (isMobile) document.getElementById('mobileControls').classList.remove('active');
  }, 800);
}

function goToMenu() {
  state = 'menu';
  if (animFrame) cancelAnimationFrame(animFrame);
  showOverlay('menu');
  document.getElementById('hud').classList.remove('active');
  if (isMobile) document.getElementById('mobileControls').classList.remove('active');
  let best = parseInt(localStorage.getItem('racing_best') || '0');
  document.getElementById('menuBest').textContent = best;
  drawMenuBg();
}

// ===== BUTTON EVENTS =====
document.getElementById('btnStart').addEventListener('click', () => { AudioEngine.resume(); startGame(); });
document.getElementById('btnRetry').addEventListener('click', () => { AudioEngine.resume(); startGame(); });
document.getElementById('btnResume').addEventListener('click', resumeGame);
document.getElementById('btnQuit').addEventListener('click', goToMenu);
document.getElementById('btnMenuGO').addEventListener('click', goToMenu);
document.getElementById('btnHow').addEventListener('click', () => { showOverlay('howto'); });
document.getElementById('btnBackHow').addEventListener('click', () => { showOverlay('menu'); });

// ===== UPDATE =====
let spawnTimer = 0, coinTimer = 0, powerupTimer = 0;

function update(dt) {
  if (state !== 'playing' || !player.alive) return;

  const timeMul = slowTimer > 0 ? 0.5 : 1;
  const effectiveDt = dt * timeMul;
  const effectiveSpeed = speed * timeMul;

  // Increase speed over time
  if (speed < maxSpeed) {
    speed += dt * 0.08;
    if (speed > maxSpeed) speed = maxSpeed;
  }

  distance += effectiveSpeed * dt * 2;
  score += effectiveSpeed * dt * 3;

  // Timers
  if (shieldTimer > 0) shieldTimer -= dt;
  if (slowTimer > 0) slowTimer -= dt;
  if (magnetTimer > 0) magnetTimer -= dt;

  // Engine sound
  engineTick -= dt;
  if (engineTick <= 0) {
    AudioEngine.engineHum(speed);
    engineTick = 0.15;
  }

  // Spawn obstacles
  spawnTimer -= dt;
  if (spawnTimer <= 0) {
    spawnObstacle();
    const interval = Math.max(0.4, 1.5 - (speed - baseSpeed) * 0.08);
    spawnTimer = interval + Math.random() * interval * 0.5;
  }

  // Spawn coins
  coinTimer -= dt;
  if (coinTimer <= 0) {
    spawnCoin();
    coinTimer = 0.6 + Math.random() * 0.8;
  }

  // Spawn powerups
  powerupTimer -= dt;
  if (powerupTimer <= 0) {
    spawnPowerup();
    powerupTimer = 8 + Math.random() * 10;
  }

  // Player smooth movement
  const lerpSpeed = 12;
  player.x += (player.targetX - player.x) * Math.min(lerpSpeed * dt, 1);

  // Player trail
  player.trail.push({ x: player.x, y: player.y + player.h * 0.45, alpha: 1 });
  if (player.trail.length > 30) player.trail.shift();

  // Road lines
  for (let i = 0; i < roadLines.length; i++) {
    roadLines[i] += effectiveSpeed * 4;
    if (roadLines[i] > H + 40) roadLines[i] -= H + 80;
  }

  // Update obstacles
  for (let i = obstacles.length - 1; i >= 0; i--) {
    const ob = obstacles[i];
    ob.y += (effectiveSpeed * 4 - ob.speed);

    // Trail
    ob.trail.push({ x: ob.x, y: ob.y - ob.h * 0.4, alpha: 1 });
    if (ob.trail.length > 15) ob.trail.shift();

    // Collision with player
    if (player.alive && boxCollide(player, ob)) {
      if (shieldTimer > 0) {
        // Shield absorbs hit
        shieldTimer = 0;
        emitParticles(ob.x, ob.y, CYAN, 20, 2, 4);
        obstacles.splice(i, 1);
        triggerShake(0.2, 4);
        AudioEngine.playTone(200, 0.2, 'sine', 0.1);
        continue;
      } else {
        gameOver();
        return;
      }
    }

    if (ob.y > H + 100) {
      obstacles.splice(i, 1);
    }
  }

  // Update coins
  for (let i = coins.length - 1; i >= 0; i--) {
    const c = coins[i];
    c.y += effectiveSpeed * 4;
    c.angle += dt * 3;

    // Magnet effect
    if (magnetTimer > 0) {
      const dx = player.x - c.x;
      const dy = player.y - c.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 200) {
        c.x += (dx / dist) * 8;
        c.y += (dy / dist) * 8;
      }
    }

    // Collect
    if (!c.collected && circleCollide(player.x, player.y, c.x, c.y, c.r + player.w * 0.4)) {
      c.collected = true;
      const pts = c.isGem ? 50 : 10;
      score += pts;
      coinCount += c.isGem ? 5 : 1;
      emitCoinParticles(c.x, c.y, c.isGem);
      if (c.isGem) AudioEngine.gem();
      else AudioEngine.coin();
    }

    if (c.collected || c.y > H + 40) {
      coins.splice(i, 1);
    }
  }

  // Update powerups
  for (let i = powerups.length - 1; i >= 0; i--) {
    const p = powerups[i];
    p.y += effectiveSpeed * 4;
    p.angle += dt * 2;
    p.pulse += dt * 4;

    if (circleCollide(player.x, player.y, p.x, p.y, 20 + player.w * 0.3)) {
      if (p.type === 'shield') shieldTimer = 5;
      if (p.type === 'slow') slowTimer = 5;
      if (p.type === 'magnet') magnetTimer = 5;
      emitParticles(p.x, p.y, p.color, 20, 2, 3);
      AudioEngine.powerup();
      powerups.splice(i, 1);
      continue;
    }

    if (p.y > H + 40) {
      powerups.splice(i, 1);
    }
  }

  // Update particles
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vx *= 0.98;
    p.vy *= 0.98;
    p.life -= p.decay;
    if (p.life <= 0) particles.splice(i, 1);
  }

  // Decay trails
  player.trail.forEach(t => t.alpha -= 0.03);
  obstacles.forEach(ob => ob.trail.forEach(t => t.alpha -= 0.05));

  // Update shake
  updateShake(dt);

  // Update HUD
  updateHUD();
  drawGauge();
}

// ===== RENDERING =====

function drawRoad() {
  // Road background
  const roadGrad = ctx.createLinearGradient(roadX, 0, roadX + roadW, 0);
  roadGrad.addColorStop(0, 'rgba(0, 240, 255, 0.02)');
  roadGrad.addColorStop(0.5, 'rgba(10, 10, 30, 0.9)');
  roadGrad.addColorStop(1, 'rgba(168, 85, 247, 0.02)');
  ctx.fillStyle = roadGrad;
  ctx.fillRect(roadX, 0, roadW, H);

  // Road edges (neon lines)
  ctx.shadowBlur = 10;
  ctx.shadowColor = CYAN;
  ctx.strokeStyle = CYAN;
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(roadX, 0);
  ctx.lineTo(roadX, H);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(roadX + roadW, 0);
  ctx.lineTo(roadX + roadW, H);
  ctx.stroke();

  // Edge glow strips
  const edgeGrad = ctx.createLinearGradient(roadX - 20, 0, roadX + 5, 0);
  edgeGrad.addColorStop(0, 'transparent');
  edgeGrad.addColorStop(1, 'rgba(0, 240, 255, 0.05)');
  ctx.fillStyle = edgeGrad;
  ctx.fillRect(roadX - 20, 0, 25, H);

  const edgeGrad2 = ctx.createLinearGradient(roadX + roadW - 5, 0, roadX + roadW + 20, 0);
  edgeGrad2.addColorStop(0, 'rgba(0, 240, 255, 0.05)');
  edgeGrad2.addColorStop(1, 'transparent');
  ctx.fillStyle = edgeGrad2;
  ctx.fillRect(roadX + roadW - 5, 0, 25, H);

  ctx.shadowBlur = 0;

  // Lane markings (neon dashed)
  for (let i = 1; i < LANES; i++) {
    const lx = roadX + laneW * i;
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.12)';
    ctx.lineWidth = 1;
    ctx.setLineDash([20, 25]);
    ctx.lineDashOffset = -roadLines[0];
    ctx.beginPath();
    ctx.moveTo(lx, 0);
    ctx.lineTo(lx, H);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // Scrolling ground pattern (subtle grid)
  ctx.strokeStyle = 'rgba(0, 240, 255, 0.015)';
  ctx.lineWidth = 1;
  for (const ly of roadLines) {
    ctx.beginPath();
    ctx.moveTo(roadX, ly);
    ctx.lineTo(roadX + roadW, ly);
    ctx.stroke();
  }
}

function drawCarShape(x, y, w, h, color, variant) {
  ctx.save();
  ctx.translate(x, y);

  // Car body
  const hw = w / 2, hh = h / 2;

  ctx.shadowBlur = 15;
  ctx.shadowColor = color;

  ctx.beginPath();
  if (variant === 0) {
    // Sleek sport car
    ctx.moveTo(0, -hh);
    ctx.lineTo(hw * 0.6, -hh * 0.6);
    ctx.lineTo(hw, -hh * 0.1);
    ctx.lineTo(hw, hh * 0.5);
    ctx.lineTo(hw * 0.8, hh);
    ctx.lineTo(-hw * 0.8, hh);
    ctx.lineTo(-hw, hh * 0.5);
    ctx.lineTo(-hw, -hh * 0.1);
    ctx.lineTo(-hw * 0.6, -hh * 0.6);
    ctx.closePath();
  } else if (variant === 1) {
    // Truck/van
    ctx.moveTo(-hw * 0.7, -hh);
    ctx.lineTo(hw * 0.7, -hh);
    ctx.lineTo(hw, -hh * 0.7);
    ctx.lineTo(hw, hh * 0.8);
    ctx.lineTo(hw * 0.7, hh);
    ctx.lineTo(-hw * 0.7, hh);
    ctx.lineTo(-hw, hh * 0.8);
    ctx.lineTo(-hw, -hh * 0.7);
    ctx.closePath();
  } else {
    // Wedge racer
    ctx.moveTo(0, -hh);
    ctx.lineTo(hw * 0.4, -hh * 0.4);
    ctx.lineTo(hw * 0.9, hh * 0.2);
    ctx.lineTo(hw * 0.7, hh);
    ctx.lineTo(-hw * 0.7, hh);
    ctx.lineTo(-hw * 0.9, hh * 0.2);
    ctx.lineTo(-hw * 0.4, -hh * 0.4);
    ctx.closePath();
  }

  // Fill with gradient
  const cGrad = ctx.createLinearGradient(0, -hh, 0, hh);
  cGrad.addColorStop(0, color);
  cGrad.addColorStop(1, shadeColor(color, -40));
  ctx.fillStyle = cGrad;
  ctx.fill();
  ctx.strokeStyle = color;
  ctx.lineWidth = 1;
  ctx.stroke();

  // Windshield
  ctx.fillStyle = 'rgba(0, 240, 255, 0.15)';
  ctx.fillRect(-hw * 0.4, -hh * 0.4, hw * 0.8, hh * 0.3);

  // Headlights / taillights
  ctx.shadowBlur = 8;
  ctx.shadowColor = RED;
  ctx.fillStyle = RED;
  ctx.fillRect(-hw * 0.6, hh * 0.75, hw * 0.3, 3);
  ctx.fillRect(hw * 0.3, hh * 0.75, hw * 0.3, 3);

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawPlayerCar() {
  if (!player.alive && state === 'gameover') return;

  const x = player.x, y = player.y;
  const w = player.w, h = player.h;
  const hw = w / 2, hh = h / 2;

  ctx.save();
  ctx.translate(x, y);

  // Shield aura
  if (shieldTimer > 0) {
    ctx.beginPath();
    ctx.arc(0, 0, Math.max(hw, hh) + 10, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(0, 240, 255, ${0.3 + Math.sin(Date.now() * 0.01) * 0.15})`;
    ctx.lineWidth = 2;
    ctx.shadowBlur = 20;
    ctx.shadowColor = CYAN;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  // Invincibility blink
  if (player.invincible > 0 && Math.floor(player.invincible * 10) % 2 === 0) {
    ctx.restore();
    return;
  }

  // Engine glow trail
  ctx.shadowBlur = 20;
  ctx.shadowColor = CYAN;
  const flicker = 0.6 + Math.sin(Date.now() * 0.02) * 0.2 + Math.random() * 0.2;
  const trailLen = 15 + speed * 3;

  const engineGrad = ctx.createLinearGradient(0, hh, 0, hh + trailLen);
  engineGrad.addColorStop(0, `rgba(0, 240, 255, ${flicker * 0.8})`);
  engineGrad.addColorStop(0.3, `rgba(168, 85, 247, ${flicker * 0.4})`);
  engineGrad.addColorStop(1, 'transparent');

  ctx.fillStyle = engineGrad;
  ctx.beginPath();
  ctx.moveTo(-hw * 0.3, hh);
  ctx.lineTo(hw * 0.3, hh);
  ctx.lineTo(hw * 0.1, hh + trailLen);
  ctx.lineTo(-hw * 0.1, hh + trailLen);
  ctx.closePath();
  ctx.fill();

  // Secondary engine trails (side thrusters)
  const sideGrad = ctx.createLinearGradient(0, hh, 0, hh + trailLen * 0.6);
  sideGrad.addColorStop(0, `rgba(168, 85, 247, ${flicker * 0.5})`);
  sideGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = sideGrad;
  ctx.beginPath();
  ctx.moveTo(-hw * 0.7, hh * 0.6);
  ctx.lineTo(-hw * 0.5, hh * 0.6);
  ctx.lineTo(-hw * 0.55, hh + trailLen * 0.5);
  ctx.lineTo(-hw * 0.75, hh + trailLen * 0.5);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(hw * 0.5, hh * 0.6);
  ctx.lineTo(hw * 0.7, hh * 0.6);
  ctx.lineTo(hw * 0.75, hh + trailLen * 0.5);
  ctx.lineTo(hw * 0.55, hh + trailLen * 0.5);
  ctx.closePath();
  ctx.fill();

  // Car body
  ctx.shadowBlur = 20;
  ctx.shadowColor = CYAN;

  ctx.beginPath();
  ctx.moveTo(0, -hh);
  ctx.lineTo(hw * 0.5, -hh * 0.5);
  ctx.lineTo(hw, -hh * 0.1);
  ctx.lineTo(hw * 0.95, hh * 0.3);
  ctx.lineTo(hw * 0.85, hh);
  ctx.lineTo(-hw * 0.85, hh);
  ctx.lineTo(-hw * 0.95, hh * 0.3);
  ctx.lineTo(-hw, -hh * 0.1);
  ctx.lineTo(-hw * 0.5, -hh * 0.5);
  ctx.closePath();

  const bodyGrad = ctx.createLinearGradient(0, -hh, 0, hh);
  bodyGrad.addColorStop(0, '#00c8dd');
  bodyGrad.addColorStop(0.5, '#0090aa');
  bodyGrad.addColorStop(1, '#006677');
  ctx.fillStyle = bodyGrad;
  ctx.fill();
  ctx.strokeStyle = CYAN;
  ctx.lineWidth = 1.5;
  ctx.stroke();

  // Neon detail lines
  ctx.strokeStyle = `rgba(0, 240, 255, ${0.4 + Math.sin(Date.now() * 0.005) * 0.2})`;
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(-hw * 0.6, 0);
  ctx.lineTo(-hw * 0.3, -hh * 0.3);
  ctx.lineTo(0, -hh * 0.4);
  ctx.lineTo(hw * 0.3, -hh * 0.3);
  ctx.lineTo(hw * 0.6, 0);
  ctx.stroke();

  // Windshield
  ctx.fillStyle = 'rgba(0, 240, 255, 0.2)';
  ctx.beginPath();
  ctx.moveTo(-hw * 0.35, -hh * 0.35);
  ctx.lineTo(hw * 0.35, -hh * 0.35);
  ctx.lineTo(hw * 0.25, -hh * 0.1);
  ctx.lineTo(-hw * 0.25, -hh * 0.1);
  ctx.closePath();
  ctx.fill();

  // Headlights (front)
  ctx.shadowBlur = 12;
  ctx.shadowColor = WHITE;
  ctx.fillStyle = WHITE;
  ctx.fillRect(-hw * 0.4, -hh + 2, 4, 4);
  ctx.fillRect(hw * 0.4 - 4, -hh + 2, 4, 4);

  ctx.shadowBlur = 0;
  ctx.restore();
}

function drawTrails() {
  // Player trail
  for (let i = 0; i < player.trail.length; i++) {
    const t = player.trail[i];
    if (t.alpha <= 0) continue;
    ctx.beginPath();
    ctx.arc(t.x, t.y, 3, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(0, 240, 255, ${t.alpha * 0.3})`;
    ctx.fill();
  }

  // Obstacle trails
  for (const ob of obstacles) {
    for (let i = 0; i < ob.trail.length; i++) {
      const t = ob.trail[i];
      if (t.alpha <= 0) continue;
      ctx.beginPath();
      ctx.arc(t.x, t.y, 2, 0, Math.PI * 2);
      ctx.fillStyle = hexToRgba(ob.color, t.alpha * 0.25);
      ctx.fill();
    }
  }
}

function drawCoins() {
  for (const c of coins) {
    if (c.collected) continue;
    ctx.save();
    ctx.translate(c.x, c.y);

    const scaleX = Math.cos(c.angle) * 0.6 + 0.4;
    ctx.scale(scaleX, 1);

    // Glow
    ctx.shadowBlur = 15;
    ctx.shadowColor = c.isGem ? PURPLE : GOLD;

    if (c.isGem) {
      // Diamond shape
      ctx.beginPath();
      ctx.moveTo(0, -c.r);
      ctx.lineTo(c.r * 0.7, 0);
      ctx.lineTo(0, c.r);
      ctx.lineTo(-c.r * 0.7, 0);
      ctx.closePath();
      const gemGrad = ctx.createLinearGradient(-c.r, -c.r, c.r, c.r);
      gemGrad.addColorStop(0, '#c084fc');
      gemGrad.addColorStop(0.5, PURPLE);
      gemGrad.addColorStop(1, '#7c3aed');
      ctx.fillStyle = gemGrad;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.5)';
      ctx.lineWidth = 1;
      ctx.stroke();
    } else {
      // Coin circle
      ctx.beginPath();
      ctx.arc(0, 0, c.r, 0, Math.PI * 2);
      const coinGrad = ctx.createRadialGradient(0, -2, 0, 0, 0, c.r);
      coinGrad.addColorStop(0, '#fcd34d');
      coinGrad.addColorStop(1, GOLD);
      ctx.fillStyle = coinGrad;
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Inner detail
      ctx.beginPath();
      ctx.arc(0, 0, c.r * 0.5, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.stroke();
    }

    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

function drawPowerups() {
  for (const p of powerups) {
    ctx.save();
    ctx.translate(p.x, p.y);

    const pulse = Math.sin(p.pulse) * 0.15 + 1;
    ctx.scale(pulse, pulse);

    // Outer glow ring
    ctx.shadowBlur = 20;
    ctx.shadowColor = p.color;
    ctx.beginPath();
    ctx.arc(0, 0, 18, 0, Math.PI * 2);
    ctx.strokeStyle = p.color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Inner fill
    ctx.beginPath();
    ctx.arc(0, 0, 14, 0, Math.PI * 2);
    ctx.fillStyle = hexToRgba(p.color, 0.15);
    ctx.fill();

    // Rotating arcs
    ctx.beginPath();
    ctx.arc(0, 0, 18, p.angle, p.angle + Math.PI * 0.5);
    ctx.strokeStyle = hexToRgba(p.color, 0.6);
    ctx.lineWidth = 2;
    ctx.stroke();

    // Symbol
    ctx.font = '14px "Orbitron"';
    ctx.fillStyle = p.color;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(p.type === 'shield' ? 'S' : p.type === 'slow' ? 'T' : 'M', 0, 1);

    ctx.shadowBlur = 0;
    ctx.restore();
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = p.life;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fillStyle = p.color;
    ctx.shadowBlur = 6;
    ctx.shadowColor = p.color;
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
}

function drawBackground() {
  // Side scenery - distant neon buildings
  const buildingAlpha = 0.04;
  const scrollY = (distance * 2) % 800;

  for (let i = 0; i < 8; i++) {
    const bx = roadX - 50 - Math.random() * 80;
    const by = ((i * 100 + scrollY) % (H + 200)) - 100;
    const bw = 15 + Math.random() * 25;
    const bh = 40 + Math.random() * 100;
    ctx.fillStyle = `rgba(0, 240, 255, ${buildingAlpha})`;
    ctx.fillRect(bx, by, bw, bh);

    const bx2 = roadX + roadW + 20 + Math.random() * 80;
    ctx.fillStyle = `rgba(168, 85, 247, ${buildingAlpha})`;
    ctx.fillRect(bx2, by, bw, bh);
  }
}

// Slow-time overlay
function drawSlowOverlay() {
  if (slowTimer > 0) {
    ctx.fillStyle = `rgba(168, 85, 247, ${0.03 + Math.sin(Date.now() * 0.003) * 0.015})`;
    ctx.fillRect(0, 0, W, H);

    // Vignette
    const vig = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, H * 0.7);
    vig.addColorStop(0, 'transparent');
    vig.addColorStop(1, 'rgba(168, 85, 247, 0.06)');
    ctx.fillStyle = vig;
    ctx.fillRect(0, 0, W, H);
  }
}

// Magnet overlay
function drawMagnetOverlay() {
  if (magnetTimer > 0) {
    const mag = 0.02 + Math.sin(Date.now() * 0.004) * 0.01;
    ctx.fillStyle = `rgba(245, 158, 11, ${mag})`;
    ctx.fillRect(0, 0, W, H);
  }
}

// ===== MAIN RENDER =====
function render() {
  ctx.save();
  ctx.translate(shakeX, shakeY);

  // Clear
  ctx.fillStyle = BG;
  ctx.fillRect(-10, -10, W + 20, H + 20);

  // Subtle radial glow at center
  const bgGlow = ctx.createRadialGradient(W/2, H * 0.4, 0, W/2, H * 0.4, H * 0.8);
  bgGlow.addColorStop(0, 'rgba(0, 240, 255, 0.015)');
  bgGlow.addColorStop(1, 'transparent');
  ctx.fillStyle = bgGlow;
  ctx.fillRect(0, 0, W, H);

  drawBackground();
  drawRoad();
  drawTrails();
  drawCoins();
  drawPowerups();

  // Draw obstacles
  for (const ob of obstacles) {
    drawCarShape(ob.x, ob.y, ob.w, ob.h, ob.color, ob.variant);
  }

  drawPlayerCar();
  drawParticles();
  drawSlowOverlay();
  drawMagnetOverlay();

  // Speed lines on sides
  if (speed > baseSpeed + 2) {
    const intensity = Math.min((speed - baseSpeed - 2) / (maxSpeed - baseSpeed - 2), 1) * 0.08;
    ctx.strokeStyle = `rgba(0, 240, 255, ${intensity})`;
    ctx.lineWidth = 1;
    for (let i = 0; i < 8; i++) {
      const sx = Math.random() < 0.5 ? (roadX - 10 - Math.random() * 30) : (roadX + roadW + 10 + Math.random() * 30);
      const sy = Math.random() * H;
      const len = 30 + speed * 5;
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx, sy + len);
      ctx.stroke();
    }
  }

  ctx.restore();
}

// ===== MENU BACKGROUND =====
let menuParticles = [];
function initMenuParticles() {
  menuParticles = [];
  for (let i = 0; i < 60; i++) {
    menuParticles.push({
      x: Math.random() * W,
      y: Math.random() * H,
      vx: (Math.random() - 0.5) * 0.3,
      vy: -0.3 - Math.random() * 0.5,
      size: 1 + Math.random() * 2,
      alpha: 0.2 + Math.random() * 0.3,
      color: Math.random() < 0.5 ? CYAN : PURPLE
    });
  }
}
initMenuParticles();

function drawMenuBg() {
  ctx.fillStyle = BG;
  ctx.fillRect(0, 0, W, H);

  // Radial glow
  const glow = ctx.createRadialGradient(W/2, H * 0.35, 0, W/2, H * 0.35, H * 0.6);
  glow.addColorStop(0, 'rgba(0, 240, 255, 0.03)');
  glow.addColorStop(0.5, 'rgba(168, 85, 247, 0.015)');
  glow.addColorStop(1, 'transparent');
  ctx.fillStyle = glow;
  ctx.fillRect(0, 0, W, H);

  // Grid lines
  ctx.strokeStyle = 'rgba(0, 240, 255, 0.03)';
  ctx.lineWidth = 1;
  const gridSize = 60;
  for (let x = 0; x < W; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }
  for (let y = 0; y < H; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(W, y);
    ctx.stroke();
  }

  // Floating particles
  for (const p of menuParticles) {
    p.x += p.vx;
    p.y += p.vy;
    if (p.y < -10) { p.y = H + 10; p.x = Math.random() * W; }
    if (p.x < -10) p.x = W + 10;
    if (p.x > W + 10) p.x = -10;

    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
    ctx.fillStyle = hexToRgba(p.color, p.alpha);
    ctx.fill();
  }
}

// Menu animation loop
let menuAnim;
function menuLoop() {
  if (state !== 'menu' && state !== 'gameover') return;
  drawMenuBg();
  menuAnim = requestAnimationFrame(menuLoop);
}

// ===== GAME LOOP =====
function gameLoop(now) {
  dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;

  if (state === 'playing') {
    update(dt);
    render();
    animFrame = requestAnimationFrame(gameLoop);
  } else if (state === 'gameover') {
    // Continue rendering for crash effect
    updateShake(dt);
    // Update remaining particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.98;
      p.vy *= 0.98;
      p.life -= p.decay;
      if (p.life <= 0) particles.splice(i, 1);
    }
    render();
    if (particles.length > 0) {
      animFrame = requestAnimationFrame(gameLoop);
    }
  }
}

// ===== HELPERS =====
function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function shadeColor(hex, amt) {
  let r = parseInt(hex.slice(1, 3), 16) + amt;
  let g = parseInt(hex.slice(3, 5), 16) + amt;
  let b = parseInt(hex.slice(5, 7), 16) + amt;
  r = Math.max(0, Math.min(255, r));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b));
  return `rgb(${r},${g},${b})`;
}

// ===== INIT =====
let best = parseInt(localStorage.getItem('racing_best') || '0');
document.getElementById('menuBest').textContent = best;
goToMenu();
menuLoop();

})();
</script>
</body>
</html>
