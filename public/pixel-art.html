<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>PIXEL - Neon Canvas</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --cyan: #00f0ff;
  --cyan-dim: #00f0ff44;
  --cyan-glow: rgba(0, 240, 255, 0.3);
  --purple: #a855f7;
  --purple-dim: #a855f744;
  --purple-glow: rgba(168, 85, 247, 0.3);
  --gold: #f59e0b;
  --gold-dim: #f59e0b44;
  --red: #ef4444;
  --green: #22c55e;
  --pink: #ec4899;
  --bg: #05050f;
  --panel: rgba(10, 10, 30, 0.7);
  --glass: rgba(255, 255, 255, 0.02);
  --glass-border: rgba(255, 255, 255, 0.06);
  --glass-hover: rgba(255, 255, 255, 0.05);
  --text: #e2e8f0;
  --text-dim: rgba(255, 255, 255, 0.35);
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  font-family: 'Rajdhani', 'Noto Sans KR', sans-serif;
  color: var(--text);
  cursor: default;
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-font-smoothing: antialiased;
}

/* ===== STAR BACKGROUND ===== */
#starCanvas {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 0;
  pointer-events: none;
}

/* ===== LAYOUT ===== */
.app {
  position: relative;
  z-index: 1;
  width: 100%; height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ===== TOP BAR ===== */
.top-bar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 20px;
  background: rgba(5, 5, 15, 0.85);
  border-bottom: 1px solid var(--glass-border);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  z-index: 100;
  flex-shrink: 0;
}

.top-left {
  display: flex;
  align-items: center;
  gap: 16px;
}

.back-btn {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 14px;
  border: 1px solid var(--glass-border);
  border-radius: 8px;
  background: var(--glass);
  backdrop-filter: blur(20px);
  color: var(--text-dim);
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  font-weight: 500;
  text-decoration: none;
  transition: all 0.3s ease;
  cursor: pointer;
  letter-spacing: 1px;
}

.back-btn:hover {
  border-color: var(--cyan-dim);
  color: var(--cyan);
  background: rgba(0, 240, 255, 0.05);
}

.back-btn svg {
  width: 14px; height: 14px;
  transition: transform 0.3s ease;
}

.back-btn:hover svg { transform: translateX(-3px); }

.title-group {
  display: flex;
  align-items: baseline;
  gap: 10px;
}

.title-main {
  font-family: 'Orbitron', sans-serif;
  font-size: 20px;
  font-weight: 800;
  letter-spacing: 6px;
  background: linear-gradient(135deg, var(--cyan), var(--purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.title-sub {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 300;
  letter-spacing: 4px;
  color: var(--text-dim);
  text-transform: uppercase;
}

.top-right {
  display: flex;
  align-items: center;
  gap: 8px;
}

/* ===== MAIN CONTENT ===== */
.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
}

/* ===== SIDEBAR TOOLBAR ===== */
.sidebar {
  width: 260px;
  flex-shrink: 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
  padding: 12px;
  background: rgba(5, 5, 15, 0.75);
  border-right: 1px solid var(--glass-border);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
  scrollbar-color: rgba(255,255,255,0.1) transparent;
}

.sidebar::-webkit-scrollbar { width: 4px; }
.sidebar::-webkit-scrollbar-track { background: transparent; }
.sidebar::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }

.panel {
  background: var(--glass);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 14px;
  margin-bottom: 8px;
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
}

.panel-label {
  font-family: 'Orbitron', sans-serif;
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 3px;
  color: var(--text-dim);
  text-transform: uppercase;
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.panel-label .dot {
  width: 4px; height: 4px;
  border-radius: 50%;
  background: var(--cyan);
  box-shadow: 0 0 6px var(--cyan-glow);
}

/* ===== TOOLS ===== */
.tools-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 6px;
}

.tool-btn {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  padding: 10px 4px;
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  background: var(--glass);
  color: var(--text-dim);
  font-family: 'Rajdhani', sans-serif;
  font-size: 10px;
  font-weight: 500;
  letter-spacing: 1px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.tool-btn svg {
  width: 20px; height: 20px;
  stroke: currentColor;
  fill: none;
  stroke-width: 1.5;
  stroke-linecap: round;
  stroke-linejoin: round;
  transition: all 0.3s ease;
}

.tool-btn:hover {
  border-color: var(--cyan-dim);
  color: var(--text);
  background: rgba(0, 240, 255, 0.03);
}

.tool-btn.active {
  border-color: var(--cyan);
  color: var(--cyan);
  background: rgba(0, 240, 255, 0.08);
  box-shadow: 0 0 20px rgba(0, 240, 255, 0.1), inset 0 0 20px rgba(0, 240, 255, 0.03);
}

.tool-btn.active svg { filter: drop-shadow(0 0 4px var(--cyan-glow)); }

.tool-btn.active::before {
  content: '';
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--cyan), transparent);
}

/* ===== COLOR PALETTE ===== */
.color-palette {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 4px;
}

.color-swatch {
  aspect-ratio: 1;
  border-radius: 6px;
  border: 2px solid transparent;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
}

.color-swatch:hover {
  transform: scale(1.15);
  z-index: 2;
}

.color-swatch.active {
  border-color: #fff;
  box-shadow: 0 0 12px var(--cyan-glow), 0 0 24px rgba(0, 240, 255, 0.15);
  transform: scale(1.15);
  z-index: 2;
}

.color-swatch.active::after {
  content: '';
  position: absolute;
  inset: -4px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.2);
  pointer-events: none;
}

.custom-color-row {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-top: 8px;
}

.color-input-wrapper {
  position: relative;
  width: 32px; height: 32px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid var(--glass-border);
  cursor: pointer;
  flex-shrink: 0;
}

.color-input-wrapper input[type="color"] {
  position: absolute;
  top: -4px; left: -4px;
  width: 40px; height: 40px;
  border: none;
  cursor: pointer;
  background: none;
}

.current-color-display {
  flex: 1;
  height: 32px;
  border-radius: 8px;
  border: 1px solid var(--glass-border);
  display: flex;
  align-items: center;
  justify-content: center;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 500;
  letter-spacing: 2px;
  color: var(--text-dim);
  background: var(--glass);
}

/* ===== SIZE / CANVAS / ZOOM CONTROLS ===== */
.control-row {
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 6px;
}

.control-row:last-child { margin-bottom: 0; }

.control-label {
  font-size: 11px;
  font-weight: 500;
  color: var(--text-dim);
  letter-spacing: 1px;
  min-width: 50px;
  flex-shrink: 0;
}

.ctrl-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 30px; height: 30px;
  border: 1px solid var(--glass-border);
  border-radius: 8px;
  background: var(--glass);
  backdrop-filter: blur(10px);
  color: var(--text-dim);
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  flex-shrink: 0;
}

.ctrl-btn:hover {
  border-color: var(--cyan-dim);
  color: var(--cyan);
  background: rgba(0, 240, 255, 0.05);
}

.ctrl-btn:active { transform: scale(0.92); }

.ctrl-btn.active {
  border-color: var(--cyan);
  color: var(--cyan);
  background: rgba(0, 240, 255, 0.1);
  box-shadow: 0 0 12px rgba(0, 240, 255, 0.1);
}

.ctrl-btn svg {
  width: 16px; height: 16px;
  stroke: currentColor;
  fill: none;
  stroke-width: 1.5;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.ctrl-value {
  flex: 1;
  text-align: center;
  font-family: 'Orbitron', sans-serif;
  font-size: 11px;
  font-weight: 600;
  color: var(--text);
  letter-spacing: 1px;
}

.select-ctrl {
  flex: 1;
  padding: 5px 8px;
  border: 1px solid var(--glass-border);
  border-radius: 8px;
  background: rgba(5, 5, 15, 0.6);
  color: var(--text);
  font-family: 'Rajdhani', sans-serif;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: border-color 0.3s ease;
  outline: none;
  appearance: none;
  -webkit-appearance: none;
  letter-spacing: 1px;
}

.select-ctrl:hover, .select-ctrl:focus { border-color: var(--cyan-dim); }

.select-ctrl option { background: #0a0a1e; color: var(--text); }

/* ===== ACTION BUTTONS ===== */
.action-row {
  display: flex;
  gap: 6px;
}

.action-btn {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 5px;
  padding: 8px 6px;
  border: 1px solid var(--glass-border);
  border-radius: 8px;
  background: var(--glass);
  backdrop-filter: blur(10px);
  color: var(--text-dim);
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 1px;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}

.action-btn svg {
  width: 14px; height: 14px;
  stroke: currentColor;
  fill: none;
  stroke-width: 1.5;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.action-btn:hover {
  border-color: var(--cyan-dim);
  color: var(--text);
  background: rgba(0, 240, 255, 0.04);
}

.action-btn:active { transform: scale(0.95); }

.action-btn.danger:hover {
  border-color: rgba(239, 68, 68, 0.4);
  color: var(--red);
  background: rgba(239, 68, 68, 0.06);
}

.action-btn.export {
  border-color: rgba(168, 85, 247, 0.2);
  color: var(--purple);
}

.action-btn.export:hover {
  border-color: rgba(168, 85, 247, 0.5);
  background: rgba(168, 85, 247, 0.08);
  box-shadow: 0 0 20px rgba(168, 85, 247, 0.1);
}

/* ===== TOGGLE BUTTON ===== */
.toggle-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.toggle-switch {
  width: 38px; height: 20px;
  border-radius: 10px;
  border: 1px solid var(--glass-border);
  background: rgba(255, 255, 255, 0.04);
  cursor: pointer;
  position: relative;
  transition: all 0.3s ease;
  flex-shrink: 0;
}

.toggle-switch::after {
  content: '';
  position: absolute;
  top: 2px; left: 2px;
  width: 14px; height: 14px;
  border-radius: 50%;
  background: var(--text-dim);
  transition: all 0.3s ease;
}

.toggle-switch.on {
  border-color: var(--cyan);
  background: rgba(0, 240, 255, 0.15);
}

.toggle-switch.on::after {
  left: 20px;
  background: var(--cyan);
  box-shadow: 0 0 8px var(--cyan-glow);
}

/* ===== CANVAS AREA ===== */
.canvas-area {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  background:
    radial-gradient(ellipse at 30% 40%, rgba(0, 240, 255, 0.02) 0%, transparent 50%),
    radial-gradient(ellipse at 70% 60%, rgba(168, 85, 247, 0.02) 0%, transparent 50%);
}

.canvas-wrapper {
  position: relative;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  border: 1px solid var(--glass-border);
  box-shadow:
    0 0 60px rgba(0, 240, 255, 0.05),
    0 0 120px rgba(168, 85, 247, 0.03),
    inset 0 0 60px rgba(0, 0, 0, 0.3);
  border-radius: 4px;
  overflow: hidden;
  transition: box-shadow 0.3s ease;
}

.canvas-wrapper:hover {
  box-shadow:
    0 0 80px rgba(0, 240, 255, 0.08),
    0 0 160px rgba(168, 85, 247, 0.05),
    inset 0 0 60px rgba(0, 0, 0, 0.3);
}

#pixelCanvas {
  display: block;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
  cursor: crosshair;
}

#gridOverlay {
  position: absolute;
  top: 0; left: 0;
  pointer-events: none;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* ===== CURSOR INFO ===== */
.cursor-info {
  position: fixed;
  bottom: 16px;
  right: 16px;
  padding: 6px 14px;
  border: 1px solid var(--glass-border);
  border-radius: 8px;
  background: var(--glass);
  backdrop-filter: blur(20px);
  font-family: 'Orbitron', sans-serif;
  font-size: 10px;
  font-weight: 500;
  color: var(--text-dim);
  letter-spacing: 2px;
  z-index: 50;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

/* ===== MOBILE TOGGLE ===== */
.mobile-toggle {
  display: none;
  position: fixed;
  bottom: 16px;
  left: 16px;
  width: 48px; height: 48px;
  border-radius: 50%;
  border: 1px solid var(--cyan-dim);
  background: rgba(0, 240, 255, 0.1);
  backdrop-filter: blur(20px);
  color: var(--cyan);
  cursor: pointer;
  z-index: 200;
  align-items: center;
  justify-content: center;
  box-shadow: 0 0 20px rgba(0, 240, 255, 0.15);
  transition: all 0.3s ease;
}

.mobile-toggle svg {
  width: 20px; height: 20px;
  stroke: currentColor;
  fill: none;
  stroke-width: 2;
}

.mobile-toggle:active { transform: scale(0.9); }

/* ===== NOTIFICATIONS ===== */
.notification {
  position: fixed;
  top: 60px;
  left: 50%;
  transform: translateX(-50%) translateY(-20px);
  padding: 10px 24px;
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  background: rgba(5, 5, 15, 0.9);
  backdrop-filter: blur(20px);
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 1px;
  color: var(--text);
  z-index: 300;
  opacity: 0;
  transition: all 0.4s cubic-bezier(0.16, 1, 0.3, 1);
  pointer-events: none;
  white-space: nowrap;
}

.notification.show {
  opacity: 1;
  transform: translateX(-50%) translateY(0);
}

.notification.success { border-color: rgba(34, 197, 94, 0.4); color: var(--green); }
.notification.info { border-color: var(--cyan-dim); color: var(--cyan); }
.notification.warning { border-color: var(--gold-dim); color: var(--gold); }

/* ===== RESPONSIVE ===== */
@media (max-width: 768px) {
  .sidebar {
    position: fixed;
    top: 0; left: 0;
    width: 280px; height: 100%;
    z-index: 150;
    transform: translateX(-100%);
    transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
    padding-top: 60px;
  }

  .sidebar.open { transform: translateX(0); }

  .sidebar-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 149;
  }

  .sidebar-overlay.show { display: block; }

  .mobile-toggle { display: flex; }

  .title-sub { display: none; }

  .top-bar { padding: 8px 12px; }

  .cursor-info { display: none; }
}

@media (max-width: 480px) {
  .title-main { font-size: 16px; letter-spacing: 4px; }
  .top-right .action-btn span { display: none; }
}

/* ===== ANIMATIONS ===== */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideIn {
  from { opacity: 0; transform: translateX(-10px); }
  to { opacity: 1; transform: translateX(0); }
}

.panel { animation: slideIn 0.4s ease forwards; }
.panel:nth-child(2) { animation-delay: 0.05s; }
.panel:nth-child(3) { animation-delay: 0.1s; }
.panel:nth-child(4) { animation-delay: 0.15s; }
.panel:nth-child(5) { animation-delay: 0.2s; }
.panel:nth-child(6) { animation-delay: 0.25s; }
</style>
</head>
<body>

<canvas id="starCanvas"></canvas>

<div class="app">
  <!-- TOP BAR -->
  <div class="top-bar">
    <div class="top-left">
      <a href="/games.html" class="back-btn">
        <svg viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7" stroke="currentColor" fill="none" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
        ARCADE
      </a>
      <div class="title-group">
        <div class="title-main">PIXEL</div>
        <div class="title-sub">NEON CANVAS</div>
      </div>
    </div>
    <div class="top-right">
      <div class="action-btn export" id="exportBtn" title="PNG로 내보내기">
        <svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg>
        <span>EXPORT PNG</span>
      </div>
    </div>
  </div>

  <!-- MAIN CONTENT -->
  <div class="main-content">
    <!-- SIDEBAR -->
    <div class="sidebar" id="sidebar">

      <!-- TOOLS -->
      <div class="panel">
        <div class="panel-label"><span class="dot"></span>TOOLS</div>
        <div class="tools-grid">
          <button class="tool-btn active" data-tool="brush" title="브러시 (B)">
            <svg viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>
            BRUSH
          </button>
          <button class="tool-btn" data-tool="eraser" title="지우개 (E)">
            <svg viewBox="0 0 24 24"><path d="M20 20H7L3 16l9-9 8 8-4 4"/><path d="M6.5 13.5l5-5"/></svg>
            ERASE
          </button>
          <button class="tool-btn" data-tool="fill" title="채우기 (F)">
            <svg viewBox="0 0 24 24"><path d="M2 22l1-1h3l9-9"/><path d="M3 21l9-9"/><path d="M13 3l7 7"/><path d="M10 6l8 8"/><path d="M19 15c1 1 2 2 2 3.5S20 21 19 21s-2-1-2-2.5 1-2.5 2-3.5z"/></svg>
            FILL
          </button>
          <button class="tool-btn" data-tool="picker" title="색상 추출 (I)">
            <svg viewBox="0 0 24 24"><path d="M2 22l1-1h3l9-9M3 21l9-9"/><circle cx="17.5" cy="6.5" r="3"/></svg>
            PICK
          </button>
          <button class="tool-btn" data-tool="line" title="직선 (L)">
            <svg viewBox="0 0 24 24"><line x1="5" y1="19" x2="19" y2="5"/><circle cx="5" cy="19" r="1.5"/><circle cx="19" cy="5" r="1.5"/></svg>
            LINE
          </button>
          <button class="tool-btn" data-tool="rect" title="사각형 (R)">
            <svg viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="1"/></svg>
            RECT
          </button>
        </div>
      </div>

      <!-- COLOR PALETTE -->
      <div class="panel">
        <div class="panel-label"><span class="dot"></span>PALETTE</div>
        <div class="color-palette" id="palette"></div>
        <div class="custom-color-row">
          <div class="color-input-wrapper">
            <input type="color" id="colorPicker" value="#00f0ff">
          </div>
          <div class="current-color-display" id="currentColorDisplay">#00F0FF</div>
        </div>
      </div>

      <!-- BRUSH SIZE -->
      <div class="panel">
        <div class="panel-label"><span class="dot"></span>BRUSH SIZE</div>
        <div class="control-row">
          <button class="ctrl-btn" id="sizeDown">-</button>
          <div class="ctrl-value" id="sizeValue">1 PX</div>
          <button class="ctrl-btn" id="sizeUp">+</button>
        </div>
      </div>

      <!-- CANVAS SIZE -->
      <div class="panel">
        <div class="panel-label"><span class="dot"></span>CANVAS</div>
        <div class="control-row">
          <div class="control-label">SIZE</div>
          <select class="select-ctrl" id="canvasSize">
            <option value="16">16 x 16</option>
            <option value="32" selected>32 x 32</option>
            <option value="64">64 x 64</option>
          </select>
        </div>
        <div class="control-row" style="margin-top:6px">
          <div class="control-label">ZOOM</div>
          <button class="ctrl-btn" id="zoomOut">
            <svg viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"/></svg>
          </button>
          <div class="ctrl-value" id="zoomValue">12x</div>
          <button class="ctrl-btn" id="zoomIn">
            <svg viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/></svg>
          </button>
        </div>
      </div>

      <!-- OPTIONS -->
      <div class="panel">
        <div class="panel-label"><span class="dot"></span>OPTIONS</div>
        <div class="toggle-row" style="margin-bottom:8px">
          <div class="control-label">GRID</div>
          <div class="toggle-switch on" id="gridToggle"></div>
        </div>
        <div class="toggle-row">
          <div class="control-label">MIRROR</div>
          <div class="toggle-switch" id="mirrorToggle"></div>
        </div>
      </div>

      <!-- ACTIONS -->
      <div class="panel">
        <div class="panel-label"><span class="dot"></span>ACTIONS</div>
        <div class="action-row" style="margin-bottom:6px">
          <button class="action-btn" id="undoBtn" title="실행 취소 (Ctrl+Z)">
            <svg viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 105.64-11.36L1 10"/></svg>
            UNDO
          </button>
          <button class="action-btn" id="redoBtn" title="다시 실행 (Ctrl+Y)">
            <svg viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"/><path d="M20.49 15a9 9 0 11-5.64-11.36L23 10"/></svg>
            REDO
          </button>
        </div>
        <div class="action-row">
          <button class="action-btn danger" id="clearBtn" title="캔버스 초기화">
            <svg viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14a2 2 0 01-2 2H8a2 2 0 01-2-2L5 6"/><path d="M10 11v6M14 11v6M9 6V4h6v2"/></svg>
            CLEAR
          </button>
        </div>
      </div>

    </div>

    <!-- CANVAS AREA -->
    <div class="canvas-area" id="canvasArea">
      <div class="canvas-wrapper" id="canvasWrapper">
        <canvas id="pixelCanvas"></canvas>
        <canvas id="gridOverlay"></canvas>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE TOGGLE -->
<button class="mobile-toggle" id="mobileToggle">
  <svg viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/></svg>
</button>

<!-- SIDEBAR OVERLAY -->
<div class="sidebar-overlay" id="sidebarOverlay"></div>

<!-- CURSOR INFO -->
<div class="cursor-info" id="cursorInfo">X: 0  Y: 0</div>

<!-- NOTIFICATION -->
<div class="notification" id="notification"></div>

<script>
(() => {
  'use strict';

  // ===== STAR BACKGROUND =====
  const starCanvas = document.getElementById('starCanvas');
  const starCtx = starCanvas.getContext('2d');
  let stars = [];

  function initStars() {
    starCanvas.width = window.innerWidth;
    starCanvas.height = window.innerHeight;
    stars = [];
    const count = Math.floor((starCanvas.width * starCanvas.height) / 4000);
    for (let i = 0; i < count; i++) {
      stars.push({
        x: Math.random() * starCanvas.width,
        y: Math.random() * starCanvas.height,
        r: Math.random() * 1.2 + 0.2,
        a: Math.random(),
        speed: Math.random() * 0.003 + 0.001,
        phase: Math.random() * Math.PI * 2
      });
    }
  }

  function drawStars(time) {
    starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
    for (const s of stars) {
      const alpha = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(time * s.speed + s.phase));
      starCtx.beginPath();
      starCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      starCtx.fillStyle = `rgba(255,255,255,${alpha * s.a})`;
      starCtx.fill();
    }
    requestAnimationFrame(drawStars);
  }

  initStars();
  requestAnimationFrame(drawStars);
  window.addEventListener('resize', initStars);

  // ===== WEB AUDIO =====
  let audioCtx = null;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  }

  function playTone(freq, dur, vol = 0.04, type = 'sine') {
    try {
      ensureAudio();
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      gain.gain.setValueAtTime(vol, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
    } catch (e) {}
  }

  function soundDraw() { playTone(800 + Math.random() * 400, 0.04, 0.02, 'sine'); }
  function soundToolSwitch() { playTone(1200, 0.08, 0.04, 'sine'); playTone(1600, 0.06, 0.03, 'sine'); }
  function soundAction() { playTone(600, 0.1, 0.04, 'triangle'); }
  function soundClear() { playTone(300, 0.15, 0.05, 'sawtooth'); playTone(200, 0.2, 0.03, 'sawtooth'); }
  function soundExport() { playTone(800, 0.08, 0.04, 'sine'); playTone(1000, 0.08, 0.03, 'sine'); playTone(1200, 0.12, 0.04, 'sine'); }

  // ===== STATE =====
  let gridSize = 32;
  let zoom = 12;
  let currentColor = '#00f0ff';
  let currentTool = 'brush';
  let brushSize = 1;
  let showGrid = true;
  let mirrorMode = false;
  let isDrawing = false;
  let lastCell = null;

  // Canvas pixel data
  let pixels = [];
  let undoStack = [];
  let redoStack = [];
  const MAX_UNDO = 50;

  // Line / Rect tool
  let shapeStart = null;
  let previewPixels = null;

  // DOM elements
  const pixelCanvas = document.getElementById('pixelCanvas');
  const pixelCtx = pixelCanvas.getContext('2d');
  const gridOverlay = document.getElementById('gridOverlay');
  const gridCtx = gridOverlay.getContext('2d');
  const canvasWrapper = document.getElementById('canvasWrapper');
  const canvasArea = document.getElementById('canvasArea');
  const cursorInfo = document.getElementById('cursorInfo');
  const notificationEl = document.getElementById('notification');

  // ===== PALETTE =====
  const paletteColors = [
    '#000000', '#1a1a2e', '#16213e', '#0f3460',
    '#e94560', '#ef4444', '#f97316', '#f59e0b',
    '#eab308', '#84cc16', '#22c55e', '#10b981',
    '#14b8a6', '#06b6d4', '#00f0ff', '#3b82f6',
    '#6366f1', '#8b5cf6', '#a855f7', '#d946ef',
    '#ec4899', '#f43f5e', '#ffffff', '#e2e8f0',
    '#94a3b8', '#64748b', '#475569', '#334155',
    '#1e293b', '#0f172a', '#7c3aed', '#2dd4bf'
  ];

  function buildPalette() {
    const paletteEl = document.getElementById('palette');
    paletteEl.innerHTML = '';
    paletteColors.forEach(c => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch' + (c === currentColor ? ' active' : '');
      swatch.style.background = c;
      if (c === '#000000') {
        swatch.style.border = '1px solid rgba(255,255,255,0.1)';
      }
      swatch.addEventListener('click', () => {
        currentColor = c;
        selectColor(c);
        soundToolSwitch();
      });
      paletteEl.appendChild(swatch);
    });
  }

  function selectColor(c) {
    currentColor = c;
    document.querySelectorAll('.color-swatch').forEach(s => {
      s.classList.toggle('active', rgbMatch(s.style.background, c));
    });
    document.getElementById('colorPicker').value = c;
    document.getElementById('currentColorDisplay').textContent = c.toUpperCase();
  }

  function rgbMatch(rgb, hex) {
    const tmp = document.createElement('div');
    tmp.style.color = hex;
    document.body.appendChild(tmp);
    const computed = getComputedStyle(tmp).color;
    document.body.removeChild(tmp);
    // Normalize both to compare
    const tmp2 = document.createElement('div');
    tmp2.style.color = rgb;
    document.body.appendChild(tmp2);
    const computed2 = getComputedStyle(tmp2).color;
    document.body.removeChild(tmp2);
    return computed === computed2;
  }

  document.getElementById('colorPicker').addEventListener('input', e => {
    currentColor = e.target.value;
    selectColor(currentColor);
  });

  // ===== PIXEL DATA =====
  function initPixels() {
    pixels = [];
    for (let y = 0; y < gridSize; y++) {
      pixels[y] = [];
      for (let x = 0; x < gridSize; x++) {
        pixels[y][x] = null; // null = transparent
      }
    }
    undoStack = [];
    redoStack = [];
  }

  function saveState() {
    undoStack.push(pixels.map(row => [...row]));
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack = [];
  }

  function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(pixels.map(row => [...row]));
    pixels = undoStack.pop();
    renderPixels();
    soundAction();
    notify('실행 취소', 'info');
  }

  function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(pixels.map(row => [...row]));
    pixels = redoStack.pop();
    renderPixels();
    soundAction();
    notify('다시 실행', 'info');
  }

  // ===== RENDER =====
  function resizeCanvas() {
    const w = gridSize * zoom;
    const h = gridSize * zoom;
    pixelCanvas.width = w;
    pixelCanvas.height = h;
    gridOverlay.width = w;
    gridOverlay.height = h;
    canvasWrapper.style.width = w + 'px';
    canvasWrapper.style.height = h + 'px';
    renderPixels();
    renderGrid();
  }

  function renderPixels() {
    pixelCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);

    // Checkerboard background for transparency
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        const dark = (x + y) % 2 === 0;
        pixelCtx.fillStyle = dark ? '#1a1a2e' : '#16213e';
        pixelCtx.fillRect(x * zoom, y * zoom, zoom, zoom);
      }
    }

    // Draw pixels
    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (pixels[y][x]) {
          pixelCtx.fillStyle = pixels[y][x];
          pixelCtx.fillRect(x * zoom, y * zoom, zoom, zoom);
        }
      }
    }

    // Draw preview pixels (for line/rect tool)
    if (previewPixels) {
      pixelCtx.globalAlpha = 0.5;
      for (const [px, py] of previewPixels) {
        if (px >= 0 && px < gridSize && py >= 0 && py < gridSize) {
          pixelCtx.fillStyle = currentColor;
          pixelCtx.fillRect(px * zoom, py * zoom, zoom, zoom);
          if (mirrorMode) {
            const mx = gridSize - 1 - px;
            pixelCtx.fillRect(mx * zoom, py * zoom, zoom, zoom);
          }
        }
      }
      pixelCtx.globalAlpha = 1;
    }
  }

  function renderGrid() {
    gridCtx.clearRect(0, 0, gridOverlay.width, gridOverlay.height);
    if (!showGrid) return;

    gridCtx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
    gridCtx.lineWidth = 1;

    for (let x = 0; x <= gridSize; x++) {
      gridCtx.beginPath();
      gridCtx.moveTo(x * zoom + 0.5, 0);
      gridCtx.lineTo(x * zoom + 0.5, gridSize * zoom);
      gridCtx.stroke();
    }
    for (let y = 0; y <= gridSize; y++) {
      gridCtx.beginPath();
      gridCtx.moveTo(0, y * zoom + 0.5);
      gridCtx.lineTo(gridSize * zoom, y * zoom + 0.5);
      gridCtx.stroke();
    }

    // Mirror line
    if (mirrorMode) {
      gridCtx.strokeStyle = 'rgba(0, 240, 255, 0.25)';
      gridCtx.lineWidth = 2;
      gridCtx.setLineDash([4, 4]);
      const mid = Math.floor(gridSize / 2) * zoom;
      gridCtx.beginPath();
      gridCtx.moveTo(mid, 0);
      gridCtx.lineTo(mid, gridSize * zoom);
      gridCtx.stroke();
      gridCtx.setLineDash([]);
    }
  }

  // ===== DRAWING =====
  function getCellFromEvent(e) {
    const rect = pixelCanvas.getBoundingClientRect();
    let clientX, clientY;
    if (e.touches) {
      clientX = e.touches[0].clientX;
      clientY = e.touches[0].clientY;
    } else {
      clientX = e.clientX;
      clientY = e.clientY;
    }
    const x = Math.floor((clientX - rect.left) / zoom);
    const y = Math.floor((clientY - rect.top) / zoom);
    return { x, y };
  }

  function setPixel(x, y, color) {
    if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
    pixels[y][x] = color;
    if (mirrorMode) {
      const mx = gridSize - 1 - x;
      pixels[y][mx] = color;
    }
  }

  function setPixelArea(cx, cy, color) {
    const half = Math.floor(brushSize / 2);
    for (let dy = -half; dy < brushSize - half; dy++) {
      for (let dx = -half; dx < brushSize - half; dx++) {
        setPixel(cx + dx, cy + dy, color);
      }
    }
  }

  function drawBrush(x, y) {
    const color = currentTool === 'eraser' ? null : currentColor;
    setPixelArea(x, y, color);
    renderPixels();
  }

  // Bresenham line
  function getLinePixels(x0, y0, x1, y1) {
    const result = [];
    let dx = Math.abs(x1 - x0), dy = Math.abs(y1 - y0);
    let sx = x0 < x1 ? 1 : -1, sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    while (true) {
      result.push([x0, y0]);
      if (x0 === x1 && y0 === y1) break;
      const e2 = 2 * err;
      if (e2 > -dy) { err -= dy; x0 += sx; }
      if (e2 < dx) { err += dx; y0 += sy; }
    }
    return result;
  }

  function getRectPixels(x0, y0, x1, y1) {
    const result = [];
    const minX = Math.min(x0, x1), maxX = Math.max(x0, x1);
    const minY = Math.min(y0, y1), maxY = Math.max(y0, y1);
    for (let x = minX; x <= maxX; x++) {
      result.push([x, minY]);
      result.push([x, maxY]);
    }
    for (let y = minY + 1; y < maxY; y++) {
      result.push([minX, y]);
      result.push([maxX, y]);
    }
    return result;
  }

  // Flood fill
  function floodFill(startX, startY, fillColor) {
    if (startX < 0 || startX >= gridSize || startY < 0 || startY >= gridSize) return;
    const targetColor = pixels[startY][startX];
    if (targetColor === fillColor) return;

    const stack = [[startX, startY]];
    const visited = new Set();

    while (stack.length > 0) {
      const [x, y] = stack.pop();
      const key = y * gridSize + x;
      if (visited.has(key)) continue;
      if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) continue;
      if (pixels[y][x] !== targetColor) continue;

      visited.add(key);
      pixels[y][x] = fillColor;
      if (mirrorMode) {
        const mx = gridSize - 1 - x;
        pixels[y][mx] = fillColor;
      }

      stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
    }
  }

  // Color picker
  function pickColor(x, y) {
    if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;
    const c = pixels[y][x];
    if (c) {
      currentColor = c;
      selectColor(c);
      notify(`색상 추출: ${c.toUpperCase()}`, 'info');
    }
  }

  // ===== DRAWING INTERPOLATION =====
  function drawInterpolated(x, y) {
    if (lastCell) {
      const linePixels = getLinePixels(lastCell.x, lastCell.y, x, y);
      const color = currentTool === 'eraser' ? null : currentColor;
      for (const [lx, ly] of linePixels) {
        setPixelArea(lx, ly, color);
      }
    } else {
      drawBrush(x, y);
    }
    lastCell = { x, y };
    renderPixels();
  }

  // ===== EVENT HANDLERS =====
  function onPointerDown(e) {
    e.preventDefault();
    ensureAudio();
    const { x, y } = getCellFromEvent(e);
    if (x < 0 || x >= gridSize || y < 0 || y >= gridSize) return;

    if (currentTool === 'picker') {
      pickColor(x, y);
      return;
    }

    if (currentTool === 'fill') {
      saveState();
      floodFill(x, y, currentColor);
      renderPixels();
      soundAction();
      return;
    }

    if (currentTool === 'line' || currentTool === 'rect') {
      isDrawing = true;
      shapeStart = { x, y };
      previewPixels = [[x, y]];
      renderPixels();
      return;
    }

    isDrawing = true;
    saveState();
    lastCell = null;
    drawInterpolated(x, y);
    soundDraw();
  }

  function onPointerMove(e) {
    e.preventDefault();
    const { x, y } = getCellFromEvent(e);

    // Update cursor info
    if (x >= 0 && x < gridSize && y >= 0 && y < gridSize) {
      cursorInfo.textContent = `X: ${x}  Y: ${y}`;
      cursorInfo.style.opacity = '1';
    } else {
      cursorInfo.style.opacity = '0';
    }

    if (!isDrawing) return;

    if (currentTool === 'line' && shapeStart) {
      previewPixels = getLinePixels(shapeStart.x, shapeStart.y, x, y);
      renderPixels();
      return;
    }

    if (currentTool === 'rect' && shapeStart) {
      previewPixels = getRectPixels(shapeStart.x, shapeStart.y, x, y);
      renderPixels();
      return;
    }

    if (currentTool === 'brush' || currentTool === 'eraser') {
      drawInterpolated(x, y);
    }
  }

  function onPointerUp(e) {
    if (!isDrawing) return;

    if ((currentTool === 'line' || currentTool === 'rect') && shapeStart) {
      const { x, y } = getCellFromEvent(e);
      saveState();
      const pts = currentTool === 'line'
        ? getLinePixels(shapeStart.x, shapeStart.y, x, y)
        : getRectPixels(shapeStart.x, shapeStart.y, x, y);
      for (const [px, py] of pts) {
        setPixelArea(px, py, currentColor);
      }
      previewPixels = null;
      shapeStart = null;
      renderPixels();
      soundDraw();
    }

    isDrawing = false;
    lastCell = null;
  }

  // Mouse events
  pixelCanvas.addEventListener('mousedown', onPointerDown);
  window.addEventListener('mousemove', onPointerMove);
  window.addEventListener('mouseup', onPointerUp);

  // Touch events
  pixelCanvas.addEventListener('touchstart', onPointerDown, { passive: false });
  window.addEventListener('touchmove', onPointerMove, { passive: false });
  window.addEventListener('touchend', onPointerUp);

  // ===== TOOLS =====
  document.querySelectorAll('.tool-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      currentTool = btn.dataset.tool;
      document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      soundToolSwitch();
    });
  });

  // ===== BRUSH SIZE =====
  function updateSizeDisplay() {
    document.getElementById('sizeValue').textContent = brushSize + ' PX';
  }

  document.getElementById('sizeDown').addEventListener('click', () => {
    if (brushSize > 1) { brushSize--; updateSizeDisplay(); soundAction(); }
  });

  document.getElementById('sizeUp').addEventListener('click', () => {
    if (brushSize < 8) { brushSize++; updateSizeDisplay(); soundAction(); }
  });

  // ===== CANVAS SIZE =====
  document.getElementById('canvasSize').addEventListener('change', e => {
    const newSize = parseInt(e.target.value);
    if (newSize !== gridSize) {
      if (undoStack.length > 0 || pixels.some(row => row.some(p => p !== null))) {
        if (!confirm('캔버스 크기를 변경하면 현재 작업이 지워집니다. 계속하시겠습니까?')) {
          e.target.value = gridSize;
          return;
        }
      }
      gridSize = newSize;
      // Adjust zoom so canvas fits
      adjustZoom();
      initPixels();
      resizeCanvas();
      soundAction();
      notify(`캔버스: ${gridSize}x${gridSize}`, 'info');
    }
  });

  function adjustZoom() {
    const area = canvasArea.getBoundingClientRect();
    const maxW = area.width - 60;
    const maxH = area.height - 60;
    zoom = Math.max(2, Math.floor(Math.min(maxW, maxH) / gridSize));
    document.getElementById('zoomValue').textContent = zoom + 'x';
  }

  // ===== ZOOM =====
  function updateZoomDisplay() {
    document.getElementById('zoomValue').textContent = zoom + 'x';
  }

  document.getElementById('zoomOut').addEventListener('click', () => {
    if (zoom > 2) { zoom = Math.max(2, zoom - (zoom > 10 ? 2 : 1)); resizeCanvas(); updateZoomDisplay(); soundAction(); }
  });

  document.getElementById('zoomIn').addEventListener('click', () => {
    if (zoom < 40) { zoom = Math.min(40, zoom + (zoom >= 10 ? 2 : 1)); resizeCanvas(); updateZoomDisplay(); soundAction(); }
  });

  // Mouse wheel zoom
  canvasArea.addEventListener('wheel', e => {
    e.preventDefault();
    if (e.deltaY < 0 && zoom < 40) {
      zoom = Math.min(40, zoom + 1);
    } else if (e.deltaY > 0 && zoom > 2) {
      zoom = Math.max(2, zoom - 1);
    }
    resizeCanvas();
    updateZoomDisplay();
  }, { passive: false });

  // ===== GRID TOGGLE =====
  document.getElementById('gridToggle').addEventListener('click', function() {
    showGrid = !showGrid;
    this.classList.toggle('on', showGrid);
    renderGrid();
    soundAction();
  });

  // ===== MIRROR TOGGLE =====
  document.getElementById('mirrorToggle').addEventListener('click', function() {
    mirrorMode = !mirrorMode;
    this.classList.toggle('on', mirrorMode);
    renderGrid();
    soundAction();
    notify(mirrorMode ? '미러 모드 ON' : '미러 모드 OFF', 'info');
  });

  // ===== UNDO / REDO =====
  document.getElementById('undoBtn').addEventListener('click', undo);
  document.getElementById('redoBtn').addEventListener('click', redo);

  // ===== CLEAR =====
  document.getElementById('clearBtn').addEventListener('click', () => {
    if (pixels.some(row => row.some(p => p !== null))) {
      saveState();
      for (let y = 0; y < gridSize; y++)
        for (let x = 0; x < gridSize; x++)
          pixels[y][x] = null;
      renderPixels();
      soundClear();
      notify('캔버스 초기화', 'warning');
    }
  });

  // ===== EXPORT =====
  document.getElementById('exportBtn').addEventListener('click', () => {
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = gridSize;
    exportCanvas.height = gridSize;
    const ctx = exportCanvas.getContext('2d');

    for (let y = 0; y < gridSize; y++) {
      for (let x = 0; x < gridSize; x++) {
        if (pixels[y][x]) {
          ctx.fillStyle = pixels[y][x];
          ctx.fillRect(x, y, 1, 1);
        }
      }
    }

    const link = document.createElement('a');
    link.download = `pixel-art-${gridSize}x${gridSize}.png`;
    link.href = exportCanvas.toDataURL('image/png');
    link.click();
    soundExport();
    notify('PNG 내보내기 완료!', 'success');
  });

  // ===== KEYBOARD SHORTCUTS =====
  document.addEventListener('keydown', e => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

    if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); return; }
    if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); redo(); return; }

    switch (e.key.toLowerCase()) {
      case 'b': selectTool('brush'); break;
      case 'e': selectTool('eraser'); break;
      case 'f': selectTool('fill'); break;
      case 'i': selectTool('picker'); break;
      case 'l': selectTool('line'); break;
      case 'r': selectTool('rect'); break;
      case 'g':
        showGrid = !showGrid;
        document.getElementById('gridToggle').classList.toggle('on', showGrid);
        renderGrid();
        soundAction();
        break;
      case 'm':
        mirrorMode = !mirrorMode;
        document.getElementById('mirrorToggle').classList.toggle('on', mirrorMode);
        renderGrid();
        soundAction();
        notify(mirrorMode ? '미러 모드 ON' : '미러 모드 OFF', 'info');
        break;
      case '[':
        if (brushSize > 1) { brushSize--; updateSizeDisplay(); soundAction(); }
        break;
      case ']':
        if (brushSize < 8) { brushSize++; updateSizeDisplay(); soundAction(); }
        break;
      case '+': case '=':
        if (zoom < 40) { zoom = Math.min(40, zoom + 1); resizeCanvas(); updateZoomDisplay(); soundAction(); }
        break;
      case '-':
        if (zoom > 2) { zoom = Math.max(2, zoom - 1); resizeCanvas(); updateZoomDisplay(); soundAction(); }
        break;
    }
  });

  function selectTool(tool) {
    currentTool = tool;
    document.querySelectorAll('.tool-btn').forEach(b => {
      b.classList.toggle('active', b.dataset.tool === tool);
    });
    soundToolSwitch();
  }

  // ===== MOBILE SIDEBAR =====
  const sidebar = document.getElementById('sidebar');
  const sidebarOverlay = document.getElementById('sidebarOverlay');

  document.getElementById('mobileToggle').addEventListener('click', () => {
    sidebar.classList.toggle('open');
    sidebarOverlay.classList.toggle('show');
  });

  sidebarOverlay.addEventListener('click', () => {
    sidebar.classList.remove('open');
    sidebarOverlay.classList.remove('show');
  });

  // ===== NOTIFICATION =====
  let notifyTimer;
  function notify(msg, type = 'info') {
    notificationEl.textContent = msg;
    notificationEl.className = 'notification ' + type + ' show';
    clearTimeout(notifyTimer);
    notifyTimer = setTimeout(() => {
      notificationEl.classList.remove('show');
    }, 1800);
  }

  // ===== PREVENT CONTEXT MENU ON CANVAS =====
  pixelCanvas.addEventListener('contextmenu', e => e.preventDefault());

  // ===== INIT =====
  function init() {
    buildPalette();
    initPixels();
    adjustZoom();
    resizeCanvas();
    updateSizeDisplay();
  }

  // Wait for layout
  requestAnimationFrame(() => {
    requestAnimationFrame(init);
  });

  window.addEventListener('resize', () => {
    initStars();
    // Don't auto-adjust zoom on resize to preserve user preference
  });

})();
</script>
</body>
</html>
