<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>TOWER - Defense Protocol</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --cyan: #00f0ff;
  --cyan-dim: rgba(0, 240, 255, 0.3);
  --purple: #a855f7;
  --purple-dim: rgba(168, 85, 247, 0.3);
  --gold: #f59e0b;
  --gold-dim: rgba(245, 158, 11, 0.3);
  --red: #ef4444;
  --red-dim: rgba(239, 68, 68, 0.3);
  --green: #22c55e;
  --bg: #05050f;
  --panel: rgba(10, 10, 30, 0.75);
  --glass: rgba(255, 255, 255, 0.03);
  --glass-border: rgba(255, 255, 255, 0.08);
  --text: #e2e8f0;
  --text-dim: rgba(255, 255, 255, 0.4);
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  color: var(--text);
  font-family: 'Rajdhani', 'Noto Sans KR', sans-serif;
  -webkit-font-smoothing: antialiased;
  cursor: default;
  user-select: none;
}

canvas {
  display: block;
  position: absolute;
  top: 0; left: 0;
}

/* ===== HUD ===== */
#hud {
  position: absolute;
  top: 0; left: 0; right: 0;
  height: 56px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 16px;
  background: linear-gradient(180deg, rgba(5,5,15,0.95) 0%, rgba(5,5,15,0.6) 80%, transparent 100%);
  z-index: 10;
  pointer-events: none;
}
#hud > * { pointer-events: auto; }

.hud-left, .hud-right, .hud-center {
  display: flex;
  align-items: center;
  gap: 16px;
}

.hud-center {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
}

.back-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--glass-border);
  color: var(--text-dim);
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  font-weight: 600;
  padding: 6px 14px;
  border-radius: 6px;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
}
.back-btn:hover {
  background: rgba(255,255,255,0.1);
  color: var(--cyan);
  border-color: var(--cyan-dim);
}

.hud-stat {
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 0.5px;
}
.hud-stat .label {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 500;
  text-transform: uppercase;
  color: var(--text-dim);
  letter-spacing: 1px;
}
.hud-stat .value {
  min-width: 32px;
  text-align: right;
}
.stat-gold .value { color: var(--gold); }
.stat-lives .value { color: var(--red); }
.stat-wave .value { color: var(--cyan); }
.stat-enemies .value { color: var(--purple); }

.game-title {
  font-family: 'Orbitron', monospace;
  font-weight: 800;
  font-size: 16px;
  color: var(--cyan);
  text-shadow: 0 0 20px var(--cyan-dim);
  letter-spacing: 3px;
}
.game-subtitle {
  font-family: 'Rajdhani', sans-serif;
  font-size: 9px;
  font-weight: 500;
  color: var(--text-dim);
  letter-spacing: 4px;
  text-transform: uppercase;
  margin-top: -2px;
  text-align: center;
}

/* ===== TOWER PANEL ===== */
#tower-panel {
  position: absolute;
  bottom: 12px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  padding: 10px 16px;
  background: var(--panel);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--glass-border);
  border-radius: 14px;
  z-index: 10;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.05);
}

.tower-btn {
  width: 72px;
  height: 80px;
  background: rgba(255,255,255,0.03);
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  gap: 4px;
  transition: all 0.2s;
  position: relative;
}
.tower-btn:hover {
  background: rgba(255,255,255,0.07);
  transform: translateY(-2px);
}
.tower-btn.selected {
  border-color: var(--cyan);
  box-shadow: 0 0 15px var(--cyan-dim), inset 0 0 15px rgba(0,240,255,0.05);
}
.tower-btn.disabled {
  opacity: 0.35;
  cursor: not-allowed;
  pointer-events: none;
}
.tower-btn .icon {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
}
.tower-btn .name {
  font-family: 'Orbitron', monospace;
  font-size: 9px;
  font-weight: 600;
  letter-spacing: 0.5px;
}
.tower-btn .cost {
  font-family: 'Rajdhani', sans-serif;
  font-size: 11px;
  font-weight: 600;
  color: var(--gold);
}
.tower-btn .hotkey {
  position: absolute;
  top: 4px;
  right: 6px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 9px;
  color: var(--text-dim);
  font-weight: 600;
}

/* ===== WAVE BUTTON ===== */
#wave-btn {
  position: absolute;
  bottom: 108px;
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 32px;
  font-family: 'Orbitron', monospace;
  font-size: 13px;
  font-weight: 700;
  letter-spacing: 2px;
  color: #000;
  background: linear-gradient(135deg, var(--cyan), #00c0d0);
  border: none;
  border-radius: 8px;
  cursor: pointer;
  z-index: 10;
  transition: all 0.25s;
  box-shadow: 0 0 20px var(--cyan-dim), 0 4px 15px rgba(0,0,0,0.3);
  text-transform: uppercase;
}
#wave-btn:hover {
  transform: translateX(-50%) scale(1.05);
  box-shadow: 0 0 35px var(--cyan-dim), 0 4px 20px rgba(0,0,0,0.4);
}
#wave-btn.hidden { display: none; }

/* ===== UPGRADE PANEL ===== */
#upgrade-panel {
  position: absolute;
  display: none;
  z-index: 15;
  background: var(--panel);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 14px;
  min-width: 180px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.5);
}
#upgrade-panel .up-title {
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  font-weight: 700;
  margin-bottom: 6px;
  letter-spacing: 1px;
}
#upgrade-panel .up-stats {
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  color: var(--text-dim);
  margin-bottom: 10px;
  line-height: 1.5;
}
#upgrade-panel .up-stats span { color: var(--text); font-weight: 600; }
.up-btns {
  display: flex;
  gap: 6px;
}
.up-btn {
  flex: 1;
  padding: 7px 10px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  font-weight: 700;
  border: 1px solid var(--glass-border);
  border-radius: 6px;
  cursor: pointer;
  background: rgba(255,255,255,0.05);
  color: var(--text);
  transition: all 0.2s;
  text-align: center;
}
.up-btn:hover { background: rgba(255,255,255,0.1); }
.up-btn.upgrade-action {
  background: linear-gradient(135deg, rgba(0,240,255,0.15), rgba(0,240,255,0.05));
  border-color: var(--cyan-dim);
  color: var(--cyan);
}
.up-btn.upgrade-action:hover {
  background: linear-gradient(135deg, rgba(0,240,255,0.25), rgba(0,240,255,0.1));
}
.up-btn.sell-action {
  color: var(--gold);
  border-color: var(--gold-dim);
}
.up-btn.sell-action:hover {
  background: rgba(245,158,11,0.1);
}

/* ===== OVERLAY SCREENS ===== */
.overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
  background: rgba(5,5,15,0.85);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
}
.overlay.hidden { display: none; }

.overlay-box {
  background: var(--panel);
  backdrop-filter: blur(30px);
  -webkit-backdrop-filter: blur(30px);
  border: 1px solid var(--glass-border);
  border-radius: 20px;
  padding: 40px 50px;
  text-align: center;
  box-shadow: 0 20px 60px rgba(0,0,0,0.6), inset 0 1px 0 rgba(255,255,255,0.05);
  min-width: 340px;
  max-width: 90vw;
}

.overlay-box .big-title {
  font-family: 'Orbitron', monospace;
  font-size: 36px;
  font-weight: 900;
  letter-spacing: 6px;
  margin-bottom: 4px;
}
.overlay-box .sub-title {
  font-family: 'Rajdhani', sans-serif;
  font-size: 14px;
  font-weight: 500;
  letter-spacing: 4px;
  color: var(--text-dim);
  text-transform: uppercase;
  margin-bottom: 24px;
}
.overlay-box .info-text {
  font-family: 'Rajdhani', sans-serif;
  font-size: 16px;
  color: var(--text-dim);
  margin-bottom: 8px;
  line-height: 1.6;
}
.overlay-box .info-text span { color: var(--text); font-weight: 600; }
.overlay-box .big-btn {
  margin-top: 24px;
  padding: 12px 40px;
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 2px;
  color: #000;
  background: linear-gradient(135deg, var(--cyan), #00c0d0);
  border: none;
  border-radius: 10px;
  cursor: pointer;
  transition: all 0.25s;
  box-shadow: 0 0 25px var(--cyan-dim);
  text-transform: uppercase;
}
.overlay-box .big-btn:hover {
  transform: scale(1.05);
  box-shadow: 0 0 40px var(--cyan-dim);
}

.overlay-box .result-title { margin-bottom: 16px; }
.result-victory { color: var(--green); text-shadow: 0 0 30px rgba(34,197,94,0.4); }
.result-defeat { color: var(--red); text-shadow: 0 0 30px rgba(239,68,68,0.4); }

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px 20px;
  margin: 16px 0;
  text-align: left;
}
.stats-grid .sg-label {
  font-size: 12px;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 1px;
}
.stats-grid .sg-value {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 700;
  text-align: right;
}

/* Speed control */
#speed-btn {
  background: rgba(255,255,255,0.05);
  border: 1px solid var(--glass-border);
  color: var(--text-dim);
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  font-weight: 700;
  padding: 6px 12px;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
  letter-spacing: 1px;
}
#speed-btn:hover { background: rgba(255,255,255,0.1); color: var(--cyan); border-color: var(--cyan-dim); }
#speed-btn.fast { color: var(--gold); border-color: var(--gold-dim); }

/* Tooltip */
#tooltip {
  position: absolute;
  display: none;
  z-index: 20;
  background: rgba(10,10,30,0.9);
  backdrop-filter: blur(10px);
  border: 1px solid var(--glass-border);
  border-radius: 8px;
  padding: 10px 14px;
  font-family: 'Rajdhani', sans-serif;
  font-size: 12px;
  color: var(--text-dim);
  pointer-events: none;
  max-width: 200px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.4);
}
#tooltip .tt-name {
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  font-weight: 700;
  margin-bottom: 4px;
  letter-spacing: 0.5px;
}
#tooltip .tt-desc {
  line-height: 1.4;
}

@media (max-width: 600px) {
  .hud-center { display: none; }
  .tower-btn { width: 60px; height: 68px; }
  .tower-btn .name { font-size: 8px; }
  .tower-btn .cost { font-size: 10px; }
  .tower-btn .icon { width: 24px; height: 24px; font-size: 14px; }
  #tower-panel { padding: 8px 10px; gap: 6px; }
  #wave-btn { bottom: 96px; font-size: 11px; padding: 8px 24px; }
  .overlay-box { padding: 28px 24px; min-width: 280px; }
  .overlay-box .big-title { font-size: 26px; letter-spacing: 4px; }
}
</style>
</head>
<body>

<!-- HUD -->
<div id="hud">
  <div class="hud-left">
    <a href="/games.html" class="back-btn">&larr; HUB</a>
    <div class="hud-stat stat-gold">
      <span class="label">CREDITS</span>
      <span class="value" id="gold-val">200</span>
    </div>
    <div class="hud-stat stat-lives">
      <span class="label">LIVES</span>
      <span class="value" id="lives-val">20</span>
    </div>
  </div>
  <div class="hud-center">
    <div>
      <div class="game-title">TOWER</div>
      <div class="game-subtitle">DEFENSE PROTOCOL</div>
    </div>
  </div>
  <div class="hud-right">
    <div class="hud-stat stat-wave">
      <span class="label">WAVE</span>
      <span class="value" id="wave-val">0/20</span>
    </div>
    <div class="hud-stat stat-enemies">
      <span class="label">ENEMIES</span>
      <span class="value" id="enemy-val">0</span>
    </div>
    <button id="speed-btn" onclick="toggleSpeed()">1X</button>
  </div>
</div>

<!-- Tower selection panel -->
<div id="tower-panel">
  <div class="tower-btn" data-tower="blaster" onmouseenter="showTooltip(event,'blaster')" onmouseleave="hideTooltip()">
    <span class="hotkey">1</span>
    <div class="icon" style="border: 2px solid var(--cyan); color: var(--cyan);">&#9670;</div>
    <div class="name" style="color: var(--cyan);">BLASTER</div>
    <div class="cost">100</div>
  </div>
  <div class="tower-btn" data-tower="cannon" onmouseenter="showTooltip(event,'cannon')" onmouseleave="hideTooltip()">
    <span class="hotkey">2</span>
    <div class="icon" style="border: 2px solid var(--gold); color: var(--gold);">&#9646;</div>
    <div class="name" style="color: var(--gold);">CANNON</div>
    <div class="cost">150</div>
  </div>
  <div class="tower-btn" data-tower="frost" onmouseenter="showTooltip(event,'frost')" onmouseleave="hideTooltip()">
    <span class="hotkey">3</span>
    <div class="icon" style="border: 2px solid var(--purple); color: var(--purple);">&#10052;</div>
    <div class="name" style="color: var(--purple);">FROST</div>
    <div class="cost">125</div>
  </div>
  <div class="tower-btn" data-tower="laser" onmouseenter="showTooltip(event,'laser')" onmouseleave="hideTooltip()">
    <span class="hotkey">4</span>
    <div class="icon" style="border: 2px solid var(--red); color: var(--red);">&#9683;</div>
    <div class="name" style="color: var(--red);">LASER</div>
    <div class="cost">200</div>
  </div>
</div>

<button id="wave-btn" onclick="startWave()">START WAVE 1</button>

<!-- Upgrade panel -->
<div id="upgrade-panel">
  <div class="up-title" id="up-title">BLASTER LV.1</div>
  <div class="up-stats" id="up-stats"></div>
  <div class="up-btns">
    <button class="up-btn upgrade-action" id="up-upgrade-btn" onclick="upgradeTower()">UPGRADE</button>
    <button class="up-btn sell-action" onclick="sellTower()">SELL</button>
  </div>
</div>

<div id="tooltip">
  <div class="tt-name" id="tt-name"></div>
  <div class="tt-desc" id="tt-desc"></div>
</div>

<!-- Menu screen -->
<div class="overlay" id="menu-screen">
  <div class="overlay-box">
    <div class="big-title" style="color: var(--cyan); text-shadow: 0 0 40px var(--cyan-dim);">TOWER</div>
    <div class="sub-title">DEFENSE PROTOCOL</div>
    <div class="info-text">Defend the core against waves of hostile entities.<br>Build towers. Upgrade. Survive.</div>
    <button class="big-btn" onclick="startGame()">INITIALIZE</button>
  </div>
</div>

<!-- Game over screen -->
<div class="overlay hidden" id="gameover-screen">
  <div class="overlay-box">
    <div class="big-title result-title result-defeat" id="result-title">BREACH</div>
    <div class="sub-title" id="result-sub">DEFENSE PROTOCOL FAILED</div>
    <div class="stats-grid" id="result-stats"></div>
    <button class="big-btn" onclick="restartGame()">REINITIALIZE</button>
  </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
// ===== AUDIO ENGINE =====
const AudioEngine = {
  ctx: null,
  vol: null,
  init() {
    if (this.ctx) return;
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    this.vol = this.ctx.createGain();
    this.vol.gain.value = 0.15;
    this.vol.connect(this.ctx.destination);
  },
  play(type) {
    if (!this.ctx) return;
    const now = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    osc.connect(g);
    g.connect(this.vol);
    switch(type) {
      case 'place':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.08);
        g.gain.setValueAtTime(0.4, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
        break;
      case 'shoot':
        osc.type = 'square';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.06);
        g.gain.setValueAtTime(0.12, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
        osc.start(now); osc.stop(now + 0.06);
        break;
      case 'cannon':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.2);
        g.gain.setValueAtTime(0.5, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.start(now); osc.stop(now + 0.25);
        break;
      case 'frost':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.15);
        g.gain.setValueAtTime(0.15, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
        break;
      case 'laser':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, now);
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
        break;
      case 'kill':
        osc.type = 'square';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.15);
        g.gain.setValueAtTime(0.3, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
        break;
      case 'leak':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        g.gain.setValueAtTime(0.4, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.start(now); osc.stop(now + 0.35);
        break;
      case 'wave':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.3);
        g.gain.setValueAtTime(0.3, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        osc.start(now); osc.stop(now + 0.35);
        break;
      case 'upgrade':
        osc.type = 'sine';
        osc.frequency.setValueAtTime(500, now);
        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.2);
        g.gain.setValueAtTime(0.3, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.start(now); osc.stop(now + 0.25);
        break;
      case 'sell':
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.12);
        g.gain.setValueAtTime(0.25, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
        break;
      case 'victory':
        osc.type = 'sine';
        [600,800,1000,1200].forEach((f,i) => {
          osc.frequency.setValueAtTime(f, now + i*0.12);
        });
        g.gain.setValueAtTime(0.3, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.start(now); osc.stop(now + 0.6);
        break;
      case 'defeat':
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        g.gain.setValueAtTime(0.4, now);
        g.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.start(now); osc.stop(now + 0.6);
        break;
    }
  }
};

// ===== GAME CONSTANTS =====
const CELL = 40;
const TOTAL_WAVES = 20;
const TOWER_DEFS = {
  blaster: {
    name: 'BLASTER', color: '#00f0ff', cost: 100, range: 120, damage: 15, fireRate: 0.4,
    desc: 'Fast single-target turret. Moderate damage, high fire rate.',
    upgrades: [
      { cost: 75, damage: 22, range: 135, fireRate: 0.35 },
      { cost: 150, damage: 35, range: 155, fireRate: 0.28 }
    ]
  },
  cannon: {
    name: 'CANNON', color: '#f59e0b', cost: 150, range: 110, damage: 40, fireRate: 1.2, splash: 50,
    desc: 'Area damage artillery. Slow but devastating splash explosions.',
    upgrades: [
      { cost: 100, damage: 65, range: 125, fireRate: 1.0, splash: 60 },
      { cost: 200, damage: 100, range: 145, fireRate: 0.85, splash: 75 }
    ]
  },
  frost: {
    name: 'FROST', color: '#a855f7', cost: 125, range: 100, damage: 8, fireRate: 0.6, slow: 0.4, slowDur: 2.0,
    desc: 'Cryogenic tower. Slows enemies and deals light damage.',
    upgrades: [
      { cost: 80, damage: 14, range: 115, fireRate: 0.5, slow: 0.5, slowDur: 2.5 },
      { cost: 160, damage: 22, range: 135, fireRate: 0.4, slow: 0.6, slowDur: 3.0 }
    ]
  },
  laser: {
    name: 'LASER', color: '#ef4444', cost: 200, range: 140, damage: 50, fireRate: 0.05, dps: true,
    desc: 'Continuous beam weapon. Extreme DPS against single targets.',
    upgrades: [
      { cost: 125, damage: 75, range: 155 },
      { cost: 250, damage: 110, range: 175 }
    ]
  }
};

// ===== CANVAS SETUP =====
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W, H, COLS, ROWS, offsetX, offsetY;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  COLS = Math.floor(W / CELL);
  ROWS = Math.floor(H / CELL);
  offsetX = Math.floor((W - COLS * CELL) / 2);
  offsetY = Math.floor((H - ROWS * CELL) / 2);
  buildPath();
}

// ===== PATH SYSTEM =====
let pathCells = [];
let pathWaypoints = [];
let pathSet = new Set();

function buildPath() {
  pathCells = [];
  pathWaypoints = [];
  pathSet = new Set();

  const marginY = 3;
  const marginX = 1;
  const usableRows = ROWS - marginY * 2;
  const startY = marginY + Math.floor(usableRows * 0.3);

  // Define waypoint positions as fractions of grid
  const wps = [
    { x: marginX, y: startY },
    { x: Math.floor(COLS * 0.2), y: startY },
    { x: Math.floor(COLS * 0.2), y: marginY + 1 },
    { x: Math.floor(COLS * 0.4), y: marginY + 1 },
    { x: Math.floor(COLS * 0.4), y: ROWS - marginY - 2 },
    { x: Math.floor(COLS * 0.6), y: ROWS - marginY - 2 },
    { x: Math.floor(COLS * 0.6), y: marginY + 2 },
    { x: Math.floor(COLS * 0.8), y: marginY + 2 },
    { x: Math.floor(COLS * 0.8), y: Math.floor(ROWS * 0.6) },
    { x: COLS - marginX - 1, y: Math.floor(ROWS * 0.6) }
  ];

  // Build cells between waypoints
  for (let i = 0; i < wps.length - 1; i++) {
    const a = wps[i], b = wps[i+1];
    let cx = a.x, cy = a.y;
    while (cx !== b.x || cy !== b.y) {
      const key = cx + ',' + cy;
      if (!pathSet.has(key)) {
        pathCells.push({ x: cx, y: cy });
        pathSet.add(key);
      }
      if (cx < b.x) cx++;
      else if (cx > b.x) cx--;
      else if (cy < b.y) cy++;
      else if (cy > b.y) cy--;
    }
  }
  // Add last cell
  const last = wps[wps.length - 1];
  const lk = last.x + ',' + last.y;
  if (!pathSet.has(lk)) {
    pathCells.push({ x: last.x, y: last.y });
    pathSet.add(lk);
  }

  // Build pixel waypoints (center of each cell)
  pathWaypoints = pathCells.map(c => ({
    x: offsetX + c.x * CELL + CELL / 2,
    y: offsetY + c.y * CELL + CELL / 2
  }));
}

// ===== GAME STATE =====
let game = {
  gold: 200,
  lives: 20,
  wave: 0,
  waveActive: false,
  enemies: [],
  towers: [],
  projectiles: [],
  particles: [],
  floatingTexts: [],
  selectedTowerType: null,
  selectedTower: null,
  speed: 1,
  totalKills: 0,
  totalSpent: 0,
  gameOver: false,
  started: false,
  spawnQueue: [],
  spawnTimer: 0,
  mouseX: 0,
  mouseY: 0,
  mouseGridX: -1,
  mouseGridY: -1,
  placementValid: false
};

// ===== ENEMY TYPES =====
function getWaveEnemies(wave) {
  const base = 6 + wave * 2;
  const hp = 30 + wave * 20 + Math.floor(wave * wave * 1.5);
  const speed = 1.0 + wave * 0.03;
  const reward = 8 + Math.floor(wave * 1.5);
  const enemies = [];

  for (let i = 0; i < base; i++) {
    const t = Math.random();
    let type, hpMul, spdMul, rwdMul, shape, size;
    if (wave >= 15 && t < 0.15) {
      // Boss - diamond
      type = 'boss'; hpMul = 8; spdMul = 0.5; rwdMul = 10; shape = 'diamond'; size = 14;
    } else if (wave >= 8 && t < 0.3) {
      // Tank - hexagon
      type = 'tank'; hpMul = 3.5; spdMul = 0.6; rwdMul = 4; shape = 'hexagon'; size = 11;
    } else if (t < 0.5) {
      // Fast - triangle
      type = 'fast'; hpMul = 0.6; spdMul = 1.8; rwdMul = 1.2; shape = 'triangle'; size = 7;
    } else {
      // Normal - circle
      type = 'normal'; hpMul = 1; spdMul = 1; rwdMul = 1; shape = 'circle'; size = 8;
    }
    enemies.push({
      type, shape, size,
      maxHp: Math.round(hp * hpMul),
      speed: speed * spdMul,
      reward: Math.round(reward * rwdMul),
      delay: i * (0.6 - Math.min(wave * 0.015, 0.3))
    });
  }
  return enemies;
}

function spawnEnemy(def) {
  return {
    x: pathWaypoints[0].x,
    y: pathWaypoints[0].y,
    wpIndex: 0,
    hp: def.maxHp,
    maxHp: def.maxHp,
    speed: def.speed,
    baseSpeed: def.speed,
    reward: def.reward,
    shape: def.shape,
    size: def.size,
    type: def.type,
    slowTimer: 0,
    slowAmount: 0,
    alive: true,
    hitFlash: 0
  };
}

// ===== TOWER CLASS =====
function createTower(type, gx, gy) {
  const def = TOWER_DEFS[type];
  return {
    type,
    gx, gy,
    x: offsetX + gx * CELL + CELL / 2,
    y: offsetY + gy * CELL + CELL / 2,
    level: 1,
    damage: def.damage,
    range: def.range,
    fireRate: def.fireRate,
    cooldown: 0,
    target: null,
    angle: 0,
    splash: def.splash || 0,
    slow: def.slow || 0,
    slowDur: def.slowDur || 0,
    dps: def.dps || false,
    laserTarget: null,
    laserAlpha: 0,
    totalCost: def.cost,
    pulsePhase: Math.random() * Math.PI * 2
  };
}

// ===== PROJECTILE =====
function createProjectile(tower, target) {
  const color = TOWER_DEFS[tower.type].color;
  return {
    x: tower.x,
    y: tower.y,
    tx: target.x,
    ty: target.y,
    target,
    speed: tower.type === 'cannon' ? 4 : 8,
    damage: tower.damage,
    type: tower.type,
    color,
    splash: tower.splash,
    slow: tower.slow,
    slowDur: tower.slowDur,
    alive: true,
    trail: []
  };
}

// ===== PARTICLE =====
function addParticle(x, y, color, count, speed, life, size) {
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const s = Math.random() * speed + speed * 0.3;
    game.particles.push({
      x, y,
      vx: Math.cos(a) * s,
      vy: Math.sin(a) * s,
      life: life * (0.5 + Math.random() * 0.5),
      maxLife: life,
      color,
      size: size * (0.5 + Math.random() * 0.5)
    });
  }
}

function addFloatingText(x, y, text, color) {
  game.floatingTexts.push({ x, y, text, color, life: 1.0, vy: -1.5 });
}

// ===== GRID HELPERS =====
function isPathCell(gx, gy) {
  return pathSet.has(gx + ',' + gy);
}

function isPathAdjacent(gx, gy) {
  for (let dx = -1; dx <= 1; dx++) {
    for (let dy = -1; dy <= 1; dy++) {
      if (dx === 0 && dy === 0) continue;
      if (isPathCell(gx + dx, gy + dy)) return true;
    }
  }
  return false;
}

function hasTower(gx, gy) {
  return game.towers.some(t => t.gx === gx && t.gy === gy);
}

function canPlace(gx, gy) {
  if (gx < 0 || gy < 0 || gx >= COLS || gy >= ROWS) return false;
  if (isPathCell(gx, gy)) return false;
  if (hasTower(gx, gy)) return false;
  if (!isPathAdjacent(gx, gy)) return false;
  // Not too close to HUD
  if (gy < 2) return false;
  return true;
}

function gridFromMouse(mx, my) {
  return {
    gx: Math.floor((mx - offsetX) / CELL),
    gy: Math.floor((my - offsetY) / CELL)
  };
}

function dist(a, b) {
  return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
}

// ===== UPDATE =====
function update(dt) {
  if (game.gameOver) return;
  const spd = game.speed;
  const sDt = dt * spd;

  // Spawn queue
  if (game.spawnQueue.length > 0) {
    game.spawnTimer -= sDt;
    while (game.spawnTimer <= 0 && game.spawnQueue.length > 0) {
      const def = game.spawnQueue.shift();
      game.enemies.push(spawnEnemy(def));
      if (game.spawnQueue.length > 0) {
        game.spawnTimer += game.spawnQueue[0].delay;
      }
    }
  }

  // Update enemies
  for (const e of game.enemies) {
    if (!e.alive) continue;
    // Slow
    if (e.slowTimer > 0) {
      e.slowTimer -= sDt;
      e.speed = e.baseSpeed * (1 - e.slowAmount);
      if (e.slowTimer <= 0) e.speed = e.baseSpeed;
    }
    // Move along path
    if (e.wpIndex < pathWaypoints.length - 1) {
      const wp = pathWaypoints[e.wpIndex + 1];
      const dx = wp.x - e.x;
      const dy = wp.y - e.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      const move = e.speed * 60 * sDt;
      if (d <= move) {
        e.x = wp.x;
        e.y = wp.y;
        e.wpIndex++;
      } else {
        e.x += (dx / d) * move;
        e.y += (dy / d) * move;
      }
    }
    // Reached end
    if (e.wpIndex >= pathWaypoints.length - 1) {
      e.alive = false;
      game.lives--;
      AudioEngine.play('leak');
      addParticle(e.x, e.y, '#ef4444', 8, 2, 0.5, 3);
      updateHUD();
      if (game.lives <= 0) {
        endGame(false);
        return;
      }
    }
    // Hit flash
    if (e.hitFlash > 0) e.hitFlash -= sDt * 5;
  }

  // Update towers
  for (const t of game.towers) {
    t.cooldown -= sDt;
    t.pulsePhase += sDt * 2;

    // Find target
    const aliveEnemies = game.enemies.filter(e => e.alive && dist(t, e) <= t.range);
    if (aliveEnemies.length === 0) {
      t.target = null;
      if (t.dps) t.laserAlpha = Math.max(0, t.laserAlpha - sDt * 5);
      continue;
    }

    // Target closest to end (highest wpIndex, then closest to next wp)
    aliveEnemies.sort((a, b) => {
      if (b.wpIndex !== a.wpIndex) return b.wpIndex - a.wpIndex;
      if (a.wpIndex < pathWaypoints.length - 1) {
        const wa = pathWaypoints[a.wpIndex + 1];
        const wb = pathWaypoints[b.wpIndex + 1];
        return dist(a, wa) - dist(b, wb);
      }
      return 0;
    });
    t.target = aliveEnemies[0];
    t.angle = Math.atan2(t.target.y - t.y, t.target.x - t.x);

    if (t.dps) {
      // Laser - continuous beam
      t.laserTarget = t.target;
      t.laserAlpha = Math.min(1, t.laserAlpha + sDt * 8);
      t.target.hp -= t.damage * sDt;
      t.target.hitFlash = 1;
      if (Math.random() < 0.3) {
        addParticle(t.target.x, t.target.y, TOWER_DEFS[t.type].color, 1, 1.5, 0.3, 2);
      }
      if (t.cooldown <= 0) {
        AudioEngine.play('laser');
        t.cooldown = 0.2;
      }
    } else if (t.cooldown <= 0) {
      t.cooldown = t.fireRate;
      game.projectiles.push(createProjectile(t, t.target));
      if (t.type === 'cannon') AudioEngine.play('cannon');
      else if (t.type === 'frost') AudioEngine.play('frost');
      else AudioEngine.play('shoot');
    }
  }

  // Update projectiles
  for (const p of game.projectiles) {
    if (!p.alive) continue;
    // Add trail
    p.trail.push({ x: p.x, y: p.y, life: 0.3 });
    if (p.trail.length > 8) p.trail.shift();

    // Move toward target
    const tgt = p.target;
    if (!tgt || !tgt.alive) {
      // Move to last known pos
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < p.speed * 2) { p.alive = false; continue; }
      p.x += (dx / d) * p.speed * spd;
      p.y += (dy / d) * p.speed * spd;
    } else {
      p.tx = tgt.x; p.ty = tgt.y;
      const dx = tgt.x - p.x, dy = tgt.y - p.y;
      const d = Math.sqrt(dx * dx + dy * dy);
      if (d < p.speed * 2) {
        p.alive = false;
        // Hit
        if (p.splash > 0) {
          // AOE
          for (const e of game.enemies) {
            if (e.alive && dist(e, { x: p.tx, y: p.ty }) <= p.splash) {
              e.hp -= p.damage;
              e.hitFlash = 1;
            }
          }
          addParticle(p.tx, p.ty, p.color, 15, 3, 0.5, 3);
        } else {
          tgt.hp -= p.damage;
          tgt.hitFlash = 1;
          if (p.slow > 0) {
            tgt.slowTimer = p.slowDur;
            tgt.slowAmount = p.slow;
            addParticle(tgt.x, tgt.y, p.color, 6, 2, 0.4, 2);
          } else {
            addParticle(tgt.x, tgt.y, p.color, 4, 2, 0.3, 2);
          }
        }
      } else {
        p.x += (dx / d) * p.speed * spd;
        p.y += (dy / d) * p.speed * spd;
      }
    }
    // Trail decay
    for (const tr of p.trail) tr.life -= sDt * 3;
    p.trail = p.trail.filter(t => t.life > 0);
  }

  // Check enemy deaths
  for (const e of game.enemies) {
    if (e.alive && e.hp <= 0) {
      e.alive = false;
      game.gold += e.reward;
      game.totalKills++;
      addParticle(e.x, e.y, '#ffffff', 10, 3, 0.6, 3);
      addFloatingText(e.x, e.y - 15, '+' + e.reward, '#f59e0b');
      AudioEngine.play('kill');
      updateHUD();
    }
  }

  // Cleanup
  game.enemies = game.enemies.filter(e => e.alive);
  game.projectiles = game.projectiles.filter(p => p.alive);

  // Particles
  for (const p of game.particles) {
    p.x += p.vx * spd;
    p.y += p.vy * spd;
    p.life -= sDt;
    p.vx *= 0.96;
    p.vy *= 0.96;
  }
  game.particles = game.particles.filter(p => p.life > 0);

  // Floating texts
  for (const ft of game.floatingTexts) {
    ft.y += ft.vy * spd;
    ft.life -= sDt * 1.5;
  }
  game.floatingTexts = game.floatingTexts.filter(ft => ft.life > 0);

  // Wave complete check
  if (game.waveActive && game.enemies.length === 0 && game.spawnQueue.length === 0) {
    game.waveActive = false;
    if (game.wave >= TOTAL_WAVES) {
      endGame(true);
    } else {
      document.getElementById('wave-btn').textContent = 'START WAVE ' + (game.wave + 1);
      document.getElementById('wave-btn').classList.remove('hidden');
      // Bonus gold
      const bonus = 20 + game.wave * 5;
      game.gold += bonus;
      addFloatingText(W / 2, H / 2, 'WAVE CLEAR +' + bonus, '#22c55e');
      updateHUD();
    }
  }

  // Update placement validity
  if (game.selectedTowerType) {
    const { gx, gy } = gridFromMouse(game.mouseX, game.mouseY);
    game.mouseGridX = gx;
    game.mouseGridY = gy;
    game.placementValid = canPlace(gx, gy);
  }

  updateTowerButtons();
}

// ===== RENDER =====
function render() {
  ctx.clearRect(0, 0, W, H);

  // Background grid
  ctx.strokeStyle = 'rgba(255,255,255,0.015)';
  ctx.lineWidth = 1;
  for (let x = 0; x <= COLS; x++) {
    const px = offsetX + x * CELL;
    ctx.beginPath(); ctx.moveTo(px, offsetY); ctx.lineTo(px, offsetY + ROWS * CELL); ctx.stroke();
  }
  for (let y = 0; y <= ROWS; y++) {
    const py = offsetY + y * CELL;
    ctx.beginPath(); ctx.moveTo(offsetX, py); ctx.lineTo(offsetX + COLS * CELL, py); ctx.stroke();
  }

  // Path glow (broad)
  if (pathWaypoints.length > 1) {
    ctx.save();
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.04)';
    ctx.lineWidth = CELL + 10;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(pathWaypoints[0].x, pathWaypoints[0].y);
    for (let i = 1; i < pathWaypoints.length; i++) {
      ctx.lineTo(pathWaypoints[i].x, pathWaypoints[i].y);
    }
    ctx.stroke();
    ctx.restore();
  }

  // Path cells
  for (const c of pathCells) {
    const px = offsetX + c.x * CELL;
    const py = offsetY + c.y * CELL;
    ctx.fillStyle = 'rgba(0, 240, 255, 0.03)';
    ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.08)';
    ctx.lineWidth = 1;
    ctx.strokeRect(px + 1, py + 1, CELL - 2, CELL - 2);
  }

  // Path neon line
  if (pathWaypoints.length > 1) {
    ctx.save();
    ctx.strokeStyle = 'rgba(0, 240, 255, 0.15)';
    ctx.lineWidth = 2;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.setLineDash([6, 8]);
    ctx.lineDashOffset = -performance.now() / 80;
    ctx.beginPath();
    ctx.moveTo(pathWaypoints[0].x, pathWaypoints[0].y);
    for (let i = 1; i < pathWaypoints.length; i++) {
      ctx.lineTo(pathWaypoints[i].x, pathWaypoints[i].y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // Start / End markers
  if (pathWaypoints.length > 1) {
    const start = pathWaypoints[0];
    const end = pathWaypoints[pathWaypoints.length - 1];
    // Start
    ctx.save();
    ctx.strokeStyle = 'rgba(34, 197, 94, 0.4)';
    ctx.lineWidth = 2;
    const sr = 12 + Math.sin(performance.now() / 400) * 3;
    ctx.beginPath(); ctx.arc(start.x, start.y, sr, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = 'rgba(34, 197, 94, 0.1)';
    ctx.fill();
    // End
    ctx.strokeStyle = 'rgba(239, 68, 68, 0.4)';
    const er = 12 + Math.sin(performance.now() / 400) * 3;
    ctx.beginPath(); ctx.arc(end.x, end.y, er, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
    ctx.fill();
    ctx.restore();
  }

  // Tower range indicators
  if (game.selectedTowerType) {
    const def = TOWER_DEFS[game.selectedTowerType];
    if (game.placementValid) {
      const cx = offsetX + game.mouseGridX * CELL + CELL / 2;
      const cy = offsetY + game.mouseGridY * CELL + CELL / 2;
      ctx.save();
      ctx.strokeStyle = def.color + '33';
      ctx.fillStyle = def.color + '08';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.arc(cx, cy, def.range, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
      ctx.restore();
    }
  }

  // Selected tower range
  if (game.selectedTower) {
    const t = game.selectedTower;
    const color = TOWER_DEFS[t.type].color;
    ctx.save();
    ctx.strokeStyle = color + '44';
    ctx.fillStyle = color + '0a';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([4, 4]);
    ctx.beginPath(); ctx.arc(t.x, t.y, t.range, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
    ctx.setLineDash([]);
    ctx.restore();
  }

  // Towers
  for (const t of game.towers) {
    const def = TOWER_DEFS[t.type];
    const color = def.color;
    const px = offsetX + t.gx * CELL;
    const py = offsetY + t.gy * CELL;
    const cx = t.x, cy = t.y;

    // Base
    ctx.save();
    ctx.fillStyle = 'rgba(15, 15, 35, 0.8)';
    ctx.strokeStyle = color + '55';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.roundRect(px + 3, py + 3, CELL - 6, CELL - 6, 4);
    ctx.fill(); ctx.stroke();

    // Pulse ring
    const pulse = Math.sin(t.pulsePhase) * 0.5 + 0.5;
    ctx.strokeStyle = color + Math.floor(pulse * 30).toString(16).padStart(2,'0');
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(cx, cy, 14 + pulse * 3, 0, Math.PI * 2); ctx.stroke();

    // Tower body
    ctx.fillStyle = color;
    ctx.globalAlpha = 0.8;
    if (t.type === 'blaster') {
      // Diamond shape
      ctx.beginPath();
      ctx.moveTo(cx, cy - 8); ctx.lineTo(cx + 6, cy); ctx.lineTo(cx, cy + 8); ctx.lineTo(cx - 6, cy);
      ctx.closePath(); ctx.fill();
    } else if (t.type === 'cannon') {
      // Square
      ctx.fillRect(cx - 7, cy - 7, 14, 14);
    } else if (t.type === 'frost') {
      // Hexagon
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i - Math.PI / 6;
        const r = 9;
        ctx.lineTo(cx + Math.cos(a) * r, cy + Math.sin(a) * r);
      }
      ctx.closePath(); ctx.fill();
    } else if (t.type === 'laser') {
      // Circle with inner ring
      ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 0.3;
      ctx.beginPath(); ctx.arc(cx, cy, 5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Turret direction
    if (t.target) {
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(cx + Math.cos(t.angle) * 14, cy + Math.sin(t.angle) * 14);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Level indicator
    if (t.level > 1) {
      ctx.fillStyle = color;
      ctx.font = '700 8px Orbitron';
      ctx.textAlign = 'center';
      ctx.fillText('L' + t.level, cx, py + CELL - 4);
    }

    // Laser beam
    if (t.dps && t.laserTarget && t.laserAlpha > 0) {
      const tgt = t.laserTarget;
      ctx.save();
      ctx.globalAlpha = t.laserAlpha * 0.8;
      // Glow
      ctx.strokeStyle = color + '44';
      ctx.lineWidth = 6;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tgt.x, tgt.y); ctx.stroke();
      // Core
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tgt.x, tgt.y); ctx.stroke();
      // Bright core
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.globalAlpha = t.laserAlpha * 0.4;
      ctx.beginPath(); ctx.moveTo(cx, cy); ctx.lineTo(tgt.x, tgt.y); ctx.stroke();
      ctx.restore();
    }

    ctx.restore();
  }

  // Projectiles
  for (const p of game.projectiles) {
    // Trail
    for (const tr of p.trail) {
      ctx.save();
      ctx.globalAlpha = tr.life * 0.4;
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(tr.x, tr.y, 2 * tr.life, 0, Math.PI * 2); ctx.fill();
      ctx.restore();
    }
    // Bullet
    ctx.save();
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 8;
    ctx.beginPath();
    if (p.type === 'cannon') {
      ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
    } else if (p.type === 'frost') {
      // Frost crystal
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i;
        ctx.lineTo(p.x + Math.cos(a) * 4, p.y + Math.sin(a) * 4);
      }
      ctx.closePath();
    } else {
      ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
    }
    ctx.fill();
    ctx.restore();
  }

  // Enemies
  for (const e of game.enemies) {
    if (!e.alive) continue;
    const color = e.type === 'boss' ? '#ff6b6b' :
                  e.type === 'tank' ? '#fbbf24' :
                  e.type === 'fast' ? '#34d399' : '#00f0ff';

    ctx.save();
    // Slow effect
    if (e.slowTimer > 0) {
      ctx.strokeStyle = 'rgba(168, 85, 247, 0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.size + 4, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Hit flash
    const flashMix = Math.max(0, e.hitFlash);
    ctx.fillStyle = flashMix > 0 ? '#fff' : color;
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    ctx.shadowColor = color;
    ctx.shadowBlur = flashMix > 0 ? 15 : 6;

    ctx.beginPath();
    if (e.shape === 'circle') {
      ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    } else if (e.shape === 'triangle') {
      for (let i = 0; i < 3; i++) {
        const a = (Math.PI * 2 / 3) * i - Math.PI / 2;
        ctx.lineTo(e.x + Math.cos(a) * e.size, e.y + Math.sin(a) * e.size);
      }
      ctx.closePath();
    } else if (e.shape === 'hexagon') {
      for (let i = 0; i < 6; i++) {
        const a = (Math.PI / 3) * i;
        ctx.lineTo(e.x + Math.cos(a) * e.size, e.y + Math.sin(a) * e.size);
      }
      ctx.closePath();
    } else if (e.shape === 'diamond') {
      ctx.moveTo(e.x, e.y - e.size);
      ctx.lineTo(e.x + e.size * 0.7, e.y);
      ctx.lineTo(e.x, e.y + e.size);
      ctx.lineTo(e.x - e.size * 0.7, e.y);
      ctx.closePath();
    }
    if (flashMix > 0) { ctx.globalAlpha = 0.6 + flashMix * 0.4; }
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.stroke();
    ctx.shadowBlur = 0;

    // Health bar
    if (e.hp < e.maxHp) {
      const bw = 18, bh = 3;
      const bx = e.x - bw / 2, by = e.y - e.size - 7;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(bx - 1, by - 1, bw + 2, bh + 2);
      const pct = Math.max(0, e.hp / e.maxHp);
      const hpColor = pct > 0.6 ? '#22c55e' : pct > 0.3 ? '#f59e0b' : '#ef4444';
      ctx.fillStyle = hpColor;
      ctx.fillRect(bx, by, bw * pct, bh);
    }

    ctx.restore();
  }

  // Particles
  for (const p of game.particles) {
    ctx.save();
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillStyle = p.color;
    ctx.shadowColor = p.color;
    ctx.shadowBlur = 4;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * (p.life / p.maxLife), 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  // Floating texts
  for (const ft of game.floatingTexts) {
    ctx.save();
    ctx.globalAlpha = ft.life;
    ctx.fillStyle = ft.color;
    ctx.font = '700 13px Rajdhani';
    ctx.textAlign = 'center';
    ctx.shadowColor = ft.color;
    ctx.shadowBlur = 6;
    ctx.fillText(ft.text, ft.x, ft.y);
    ctx.restore();
  }

  // Placement ghost
  if (game.selectedTowerType && game.mouseGridX >= 0) {
    const gx = game.mouseGridX, gy = game.mouseGridY;
    const px = offsetX + gx * CELL, py = offsetY + gy * CELL;
    const cx = px + CELL / 2, cy = py + CELL / 2;
    const valid = game.placementValid;
    ctx.save();
    ctx.globalAlpha = 0.5;
    ctx.fillStyle = valid ? 'rgba(34, 197, 94, 0.15)' : 'rgba(239, 68, 68, 0.15)';
    ctx.strokeStyle = valid ? 'rgba(34, 197, 94, 0.5)' : 'rgba(239, 68, 68, 0.5)';
    ctx.lineWidth = 2;
    ctx.fillRect(px + 2, py + 2, CELL - 4, CELL - 4);
    ctx.strokeRect(px + 2, py + 2, CELL - 4, CELL - 4);

    if (valid) {
      const def = TOWER_DEFS[game.selectedTowerType];
      ctx.fillStyle = def.color;
      ctx.globalAlpha = 0.4;
      ctx.beginPath(); ctx.arc(cx, cy, 8, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();
  }
}

// ===== GAME LOOP =====
let lastTime = 0;
function gameLoop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  if (game.started && !game.gameOver) {
    update(dt);
  }
  render();
  requestAnimationFrame(gameLoop);
}

// ===== HUD =====
function updateHUD() {
  document.getElementById('gold-val').textContent = game.gold;
  document.getElementById('lives-val').textContent = game.lives;
  document.getElementById('wave-val').textContent = game.wave + '/' + TOTAL_WAVES;
  document.getElementById('enemy-val').textContent = game.enemies.length + game.spawnQueue.length;
}

function updateTowerButtons() {
  document.querySelectorAll('.tower-btn').forEach(btn => {
    const type = btn.dataset.tower;
    const def = TOWER_DEFS[type];
    if (game.gold < def.cost) {
      btn.classList.add('disabled');
    } else {
      btn.classList.remove('disabled');
    }
    if (game.selectedTowerType === type) {
      btn.classList.add('selected');
    } else {
      btn.classList.remove('selected');
    }
  });
}

// ===== INPUT =====
canvas.addEventListener('mousemove', (e) => {
  game.mouseX = e.clientX;
  game.mouseY = e.clientY;
});

canvas.addEventListener('click', (e) => {
  AudioEngine.init();
  const mx = e.clientX, my = e.clientY;
  const { gx, gy } = gridFromMouse(mx, my);

  // Close upgrade panel on click elsewhere
  if (game.selectedTower) {
    const panel = document.getElementById('upgrade-panel');
    if (!panel.contains(e.target)) {
      game.selectedTower = null;
      panel.style.display = 'none';
    }
  }

  // Place tower
  if (game.selectedTowerType && canPlace(gx, gy)) {
    const def = TOWER_DEFS[game.selectedTowerType];
    if (game.gold >= def.cost) {
      game.gold -= def.cost;
      game.totalSpent += def.cost;
      const tower = createTower(game.selectedTowerType, gx, gy);
      game.towers.push(tower);
      addParticle(tower.x, tower.y, def.color, 10, 2, 0.5, 3);
      AudioEngine.play('place');
      updateHUD();
    }
    return;
  }

  // Select existing tower
  if (!game.selectedTowerType) {
    const tower = game.towers.find(t => t.gx === gx && t.gy === gy);
    if (tower) {
      game.selectedTower = tower;
      showUpgradePanel(tower, mx, my);
      return;
    }
  }

  // Deselect tower type on empty click
  if (game.selectedTowerType) {
    game.selectedTowerType = null;
  }
});

canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  game.selectedTowerType = null;
  game.selectedTower = null;
  document.getElementById('upgrade-panel').style.display = 'none';
});

// Tower panel clicks
document.querySelectorAll('.tower-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    e.stopPropagation();
    AudioEngine.init();
    const type = btn.dataset.tower;
    const def = TOWER_DEFS[type];
    if (game.gold < def.cost) return;
    game.selectedTowerType = game.selectedTowerType === type ? null : type;
    game.selectedTower = null;
    document.getElementById('upgrade-panel').style.display = 'none';
  });
});

// Keyboard
document.addEventListener('keydown', (e) => {
  AudioEngine.init();
  const keyMap = { '1': 'blaster', '2': 'cannon', '3': 'frost', '4': 'laser' };
  if (keyMap[e.key]) {
    const type = keyMap[e.key];
    if (game.gold >= TOWER_DEFS[type].cost) {
      game.selectedTowerType = game.selectedTowerType === type ? null : type;
      game.selectedTower = null;
      document.getElementById('upgrade-panel').style.display = 'none';
    }
  }
  if (e.key === 'Escape') {
    game.selectedTowerType = null;
    game.selectedTower = null;
    document.getElementById('upgrade-panel').style.display = 'none';
  }
  if (e.key === ' ' || e.key === 'Enter') {
    if (!game.waveActive && game.wave < TOTAL_WAVES && game.started && !game.gameOver) {
      startWave();
    }
  }
});

// Touch support
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  AudioEngine.init();
  const t = e.touches[0];
  game.mouseX = t.clientX;
  game.mouseY = t.clientY;
  // Simulate click
  const clickEvt = new MouseEvent('click', { clientX: t.clientX, clientY: t.clientY });
  canvas.dispatchEvent(clickEvt);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const t = e.touches[0];
  game.mouseX = t.clientX;
  game.mouseY = t.clientY;
}, { passive: false });

// ===== UPGRADE PANEL =====
function showUpgradePanel(tower, mx, my) {
  const panel = document.getElementById('upgrade-panel');
  const def = TOWER_DEFS[tower.type];
  const title = document.getElementById('up-title');
  const stats = document.getElementById('up-stats');
  const upgradeBtn = document.getElementById('up-upgrade-btn');

  title.textContent = def.name + ' LV.' + tower.level;
  title.style.color = def.color;

  let html = 'DMG: <span>' + tower.damage + '</span> | RNG: <span>' + tower.range + '</span>';
  if (tower.slow) html += '<br>SLOW: <span>' + Math.round(tower.slow * 100) + '%</span>';
  if (tower.dps) html += '<br>TYPE: <span>CONTINUOUS</span>';
  if (tower.splash) html += '<br>SPLASH: <span>' + tower.splash + '</span>';

  const sellValue = Math.floor(tower.totalCost * 0.6);
  document.querySelector('.sell-action').textContent = 'SELL $' + sellValue;

  if (tower.level < 3) {
    const upg = def.upgrades[tower.level - 1];
    html += '<br>UPGRADE: <span style="color:var(--gold)">$' + upg.cost + '</span>';
    upgradeBtn.style.display = '';
    upgradeBtn.textContent = 'UPGRADE $' + upg.cost;
    if (game.gold < upg.cost) {
      upgradeBtn.style.opacity = '0.4';
      upgradeBtn.style.pointerEvents = 'none';
    } else {
      upgradeBtn.style.opacity = '1';
      upgradeBtn.style.pointerEvents = '';
    }
  } else {
    html += '<br><span style="color:var(--green)">MAX LEVEL</span>';
    upgradeBtn.style.display = 'none';
  }

  stats.innerHTML = html;

  // Position panel
  let px = mx + 15, py = my - 60;
  if (px + 200 > W) px = mx - 200;
  if (py < 60) py = 60;
  if (py + 150 > H - 120) py = H - 270;
  panel.style.left = px + 'px';
  panel.style.top = py + 'px';
  panel.style.display = 'block';
}

function upgradeTower() {
  if (!game.selectedTower) return;
  const t = game.selectedTower;
  const def = TOWER_DEFS[t.type];
  if (t.level >= 3) return;
  const upg = def.upgrades[t.level - 1];
  if (game.gold < upg.cost) return;

  game.gold -= upg.cost;
  game.totalSpent += upg.cost;
  t.level++;
  t.damage = upg.damage;
  t.range = upg.range;
  if (upg.fireRate !== undefined) t.fireRate = upg.fireRate;
  if (upg.splash !== undefined) t.splash = upg.splash;
  if (upg.slow !== undefined) t.slow = upg.slow;
  if (upg.slowDur !== undefined) t.slowDur = upg.slowDur;
  t.totalCost += upg.cost;

  addParticle(t.x, t.y, def.color, 15, 3, 0.6, 3);
  addFloatingText(t.x, t.y - 20, 'LV.' + t.level, def.color);
  AudioEngine.play('upgrade');
  updateHUD();

  // Refresh panel
  showUpgradePanel(t, parseInt(document.getElementById('upgrade-panel').style.left), parseInt(document.getElementById('upgrade-panel').style.top));
}

function sellTower() {
  if (!game.selectedTower) return;
  const t = game.selectedTower;
  const sellValue = Math.floor(t.totalCost * 0.6);
  game.gold += sellValue;
  addParticle(t.x, t.y, '#f59e0b', 10, 2, 0.4, 2);
  addFloatingText(t.x, t.y - 15, '+$' + sellValue, '#f59e0b');
  AudioEngine.play('sell');
  game.towers = game.towers.filter(tw => tw !== t);
  game.selectedTower = null;
  document.getElementById('upgrade-panel').style.display = 'none';
  updateHUD();
}

// ===== TOOLTIP =====
function showTooltip(e, type) {
  const def = TOWER_DEFS[type];
  const tt = document.getElementById('tooltip');
  const name = document.getElementById('tt-name');
  const desc = document.getElementById('tt-desc');
  name.textContent = def.name;
  name.style.color = def.color;
  let d = def.desc + '<br>DMG: ' + def.damage + ' | RNG: ' + def.range;
  if (def.splash) d += ' | SPLASH: ' + def.splash;
  if (def.slow) d += ' | SLOW: ' + Math.round(def.slow * 100) + '%';
  if (def.dps) d += ' | CONTINUOUS';
  desc.innerHTML = d;
  tt.style.display = 'block';
  const rect = e.target.closest('.tower-btn').getBoundingClientRect();
  tt.style.left = (rect.left + rect.width / 2 - 100) + 'px';
  tt.style.top = (rect.top - tt.offsetHeight - 8) + 'px';
}
function hideTooltip() {
  document.getElementById('tooltip').style.display = 'none';
}

// ===== WAVE =====
function startWave() {
  if (game.waveActive || game.wave >= TOTAL_WAVES) return;
  game.wave++;
  game.waveActive = true;
  const enemies = getWaveEnemies(game.wave);
  game.spawnQueue = enemies;
  game.spawnTimer = enemies[0].delay;
  document.getElementById('wave-btn').classList.add('hidden');
  AudioEngine.play('wave');
  updateHUD();
}

// ===== SPEED =====
function toggleSpeed() {
  game.speed = game.speed === 1 ? 2 : 1;
  const btn = document.getElementById('speed-btn');
  btn.textContent = game.speed + 'X';
  btn.classList.toggle('fast', game.speed === 2);
}

// ===== GAME FLOW =====
function startGame() {
  document.getElementById('menu-screen').classList.add('hidden');
  game.started = true;
  game.gold = 200;
  game.lives = 20;
  game.wave = 0;
  game.totalKills = 0;
  game.totalSpent = 0;
  game.enemies = [];
  game.towers = [];
  game.projectiles = [];
  game.particles = [];
  game.floatingTexts = [];
  game.spawnQueue = [];
  game.gameOver = false;
  game.waveActive = false;
  game.selectedTowerType = null;
  game.selectedTower = null;
  document.getElementById('wave-btn').textContent = 'START WAVE 1';
  document.getElementById('wave-btn').classList.remove('hidden');
  document.getElementById('upgrade-panel').style.display = 'none';
  updateHUD();
}

function endGame(victory) {
  game.gameOver = true;
  const screen = document.getElementById('gameover-screen');
  const title = document.getElementById('result-title');
  const sub = document.getElementById('result-sub');
  const stats = document.getElementById('result-stats');

  if (victory) {
    title.textContent = 'VICTORY';
    title.className = 'big-title result-title result-victory';
    sub.textContent = 'DEFENSE PROTOCOL COMPLETE';
    AudioEngine.play('victory');
  } else {
    title.textContent = 'BREACH';
    title.className = 'big-title result-title result-defeat';
    sub.textContent = 'DEFENSE PROTOCOL FAILED';
    AudioEngine.play('defeat');
  }

  stats.innerHTML = `
    <div class="sg-label">Waves</div><div class="sg-value" style="color:var(--cyan)">${game.wave}/${TOTAL_WAVES}</div>
    <div class="sg-label">Kills</div><div class="sg-value" style="color:var(--red)">${game.totalKills}</div>
    <div class="sg-label">Towers</div><div class="sg-value" style="color:var(--purple)">${game.towers.length}</div>
    <div class="sg-label">Spent</div><div class="sg-value" style="color:var(--gold)">$${game.totalSpent}</div>
  `;

  screen.classList.remove('hidden');
  document.getElementById('wave-btn').classList.add('hidden');
  document.getElementById('upgrade-panel').style.display = 'none';
}

function restartGame() {
  document.getElementById('gameover-screen').classList.add('hidden');
  startGame();
}

// ===== INIT =====
window.addEventListener('resize', resize);
resize();
requestAnimationFrame(gameLoop);
updateHUD();
</script>
</body>
</html>
