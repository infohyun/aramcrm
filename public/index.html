<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chess Online</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }

  :root {
    --bg: #f5f5f7;
    --card-bg: #ffffff;
    --text-primary: #1d1d1f;
    --text-secondary: #86868b;
    --accent: #0071e3;
    --accent-hover: #0077ED;
    --light-square: #f0e6d6;
    --dark-square: #b58863;
    --light-square-highlight: #f7ec8f;
    --dark-square-highlight: #dac34b;
    --light-square-move: #cde4c0;
    --dark-square-move: #9bc07e;
    --check-color: #ff3b30;
    --shadow: 0 4px 24px rgba(0,0,0,0.08);
    --shadow-lg: 0 12px 40px rgba(0,0,0,0.12);
    --radius: 18px;
    --radius-sm: 12px;
    --green: #34c759;
    --red: #ff3b30;
    --orange: #ff9500;
  }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    background: var(--bg);
    color: var(--text-primary);
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    overflow-x: hidden;
  }

  /* Header */
  .header {
    width: 100%;
    padding: 20px 40px;
    display: flex;
    justify-content: center;
    align-items: center;
    background: rgba(255,255,255,0.72);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    border-bottom: 1px solid rgba(0,0,0,0.06);
    position: sticky;
    top: 0;
    z-index: 100;
    gap: 12px;
  }

  .header h1 {
    font-size: 21px;
    font-weight: 600;
    letter-spacing: -0.3px;
    color: var(--text-primary);
  }

  .connection-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-secondary);
    transition: background 0.3s ease;
  }
  .connection-dot.connected { background: var(--green); }
  .connection-dot.disconnected { background: var(--red); }

  /* Main Layout */
  .main {
    display: flex;
    gap: 32px;
    padding: 40px 20px 60px;
    max-width: 1200px;
    width: 100%;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
  }

  /* Player Card */
  .player-card {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 24px 28px;
    min-width: 200px;
    transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
    border: 2px solid transparent;
  }

  .player-card.active {
    border-color: var(--accent);
    box-shadow: var(--shadow-lg), 0 0 0 4px rgba(0,113,227,0.1);
    transform: translateY(-2px);
  }

  .player-card .player-label {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-secondary);
    margin-bottom: 8px;
  }

  .player-card .player-name {
    font-size: 20px;
    font-weight: 600;
    margin-bottom: 12px;
    display: flex;
    align-items: center;
    gap: 10px;
  }

  .player-card .player-name .piece-icon {
    font-size: 28px;
    line-height: 1;
  }

  .player-card .captured {
    display: flex;
    flex-wrap: wrap;
    gap: 2px;
    min-height: 32px;
    font-size: 22px;
    line-height: 1;
    opacity: 0.7;
  }

  .player-card .score-diff {
    font-size: 14px;
    font-weight: 600;
    color: var(--accent);
    margin-top: 6px;
  }

  /* Board Container */
  .board-container {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    padding: 20px;
    position: relative;
  }

  .board-wrapper {
    position: relative;
  }

  /* Coordinates */
  .coords-row {
    display: flex;
    padding-left: 28px;
    padding-right: 28px;
  }

  .coords-row span {
    width: 72px;
    text-align: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    padding: 4px 0;
    user-select: none;
  }

  .board-with-coords {
    display: flex;
  }

  .coords-col {
    display: flex;
    flex-direction: column;
    justify-content: stretch;
  }

  .coords-col span {
    height: 72px;
    width: 28px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    font-weight: 500;
    color: var(--text-secondary);
    user-select: none;
  }

  /* Board */
  .board {
    display: grid;
    grid-template-columns: repeat(8, 72px);
    grid-template-rows: repeat(8, 72px);
    border-radius: 4px;
    overflow: hidden;
    cursor: pointer;
  }

  .square {
    width: 72px;
    height: 72px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 46px;
    line-height: 1;
    user-select: none;
    position: relative;
    transition: background-color 0.15s ease;
  }

  .square.light { background: var(--light-square); }
  .square.dark { background: var(--dark-square); }

  .square.selected.light { background: var(--light-square-highlight); }
  .square.selected.dark { background: var(--dark-square-highlight); }

  .square.last-move.light { background: var(--light-square-highlight); }
  .square.last-move.dark { background: var(--dark-square-highlight); }

  .square.check {
    background: radial-gradient(ellipse at center, var(--check-color) 0%, rgba(255,0,0,0.4) 40%, transparent 70%) !important;
  }

  .square .move-indicator {
    position: absolute;
    width: 18px;
    height: 18px;
    background: rgba(0,0,0,0.15);
    border-radius: 50%;
    pointer-events: none;
  }

  .square .capture-indicator {
    position: absolute;
    width: 66px;
    height: 66px;
    border: 5px solid rgba(0,0,0,0.15);
    border-radius: 50%;
    pointer-events: none;
  }

  .square .piece {
    position: relative;
    z-index: 2;
    text-shadow: 0 1px 3px rgba(0,0,0,0.15);
    transition: transform 0.1s ease;
    cursor: grab;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
  }

  .square:hover .piece {
    transform: scale(1.08);
  }

  /* Status Bar */
  .status-bar {
    margin-top: 20px;
    padding: 14px 24px;
    background: var(--bg);
    border-radius: var(--radius-sm);
    text-align: center;
    font-size: 15px;
    font-weight: 500;
    color: var(--text-secondary);
    transition: all 0.3s ease;
  }

  .status-bar.important {
    background: var(--accent);
    color: white;
  }

  /* Buttons */
  .controls {
    display: flex;
    gap: 12px;
    margin-top: 16px;
    justify-content: center;
    flex-wrap: wrap;
  }

  .btn {
    padding: 10px 24px;
    border: none;
    border-radius: 980px;
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
    outline: none;
  }

  .btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
    transform: none !important;
  }

  .btn-primary {
    background: var(--accent);
    color: white;
  }

  .btn-primary:hover:not(:disabled) {
    background: var(--accent-hover);
    transform: scale(1.02);
  }

  .btn-secondary {
    background: rgba(0,0,0,0.06);
    color: var(--text-primary);
  }

  .btn-secondary:hover:not(:disabled) {
    background: rgba(0,0,0,0.1);
    transform: scale(1.02);
  }

  .btn-danger {
    background: var(--red);
    color: white;
  }

  .btn-danger:hover:not(:disabled) {
    background: #e0332b;
    transform: scale(1.02);
  }

  /* Move History */
  .move-history-panel {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    padding: 24px;
    min-width: 200px;
    max-height: 620px;
    display: flex;
    flex-direction: column;
  }

  .move-history-panel h3 {
    font-size: 14px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    color: var(--text-secondary);
    margin-bottom: 16px;
  }

  .move-list {
    flex: 1;
    overflow-y: auto;
    font-size: 14px;
    scrollbar-width: thin;
  }

  .move-list::-webkit-scrollbar {
    width: 4px;
  }
  .move-list::-webkit-scrollbar-thumb {
    background: rgba(0,0,0,0.15);
    border-radius: 2px;
  }

  .move-row {
    display: flex;
    gap: 6px;
    padding: 4px 8px;
    border-radius: 6px;
    align-items: center;
  }

  .move-row:hover {
    background: rgba(0,0,0,0.03);
  }

  .move-num {
    color: var(--text-secondary);
    font-weight: 500;
    min-width: 28px;
    font-size: 12px;
  }

  .move-white, .move-black {
    min-width: 60px;
    font-weight: 500;
    padding: 2px 6px;
    border-radius: 4px;
  }

  .move-row:last-child .move-white,
  .move-row:last-child .move-black:not(:empty) {
    background: rgba(0,113,227,0.08);
    color: var(--accent);
  }

  /* Modals */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.4);
    backdrop-filter: blur(8px);
    z-index: 200;
    align-items: center;
    justify-content: center;
  }

  .modal-overlay.show {
    display: flex;
  }

  .modal {
    background: var(--card-bg);
    border-radius: var(--radius);
    box-shadow: var(--shadow-lg);
    padding: 32px;
    text-align: center;
    animation: modalIn 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
    max-width: 420px;
    width: 90%;
  }

  @keyframes modalIn {
    from { transform: scale(0.9); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }

  .modal h2 {
    font-size: 22px;
    font-weight: 600;
    margin-bottom: 8px;
  }

  .modal p {
    color: var(--text-secondary);
    font-size: 15px;
    margin-bottom: 24px;
  }

  .promo-pieces {
    display: flex;
    gap: 12px;
    justify-content: center;
  }

  .promo-piece {
    width: 72px;
    height: 72px;
    font-size: 44px;
    border: 2px solid rgba(0,0,0,0.08);
    border-radius: var(--radius-sm);
    background: var(--bg);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
  }

  .promo-piece:hover {
    border-color: var(--accent);
    background: rgba(0,113,227,0.05);
    transform: scale(1.08);
  }

  .modal-actions {
    display: flex;
    gap: 12px;
    justify-content: center;
    margin-top: 20px;
  }

  /* Lobby Overlay */
  .lobby-overlay {
    position: fixed;
    inset: 0;
    background: var(--bg);
    z-index: 300;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.4s ease;
  }

  .lobby-overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  .lobby {
    text-align: center;
    max-width: 400px;
    width: 90%;
  }

  .lobby-icon {
    font-size: 64px;
    margin-bottom: 16px;
  }

  .lobby h2 {
    font-size: 32px;
    font-weight: 700;
    letter-spacing: -0.5px;
    margin-bottom: 8px;
  }

  .lobby p {
    color: var(--text-secondary);
    font-size: 17px;
    margin-bottom: 40px;
    line-height: 1.5;
  }

  .lobby-buttons {
    display: flex;
    flex-direction: column;
    gap: 16px;
  }

  .lobby-btn {
    padding: 18px 32px;
    border: none;
    border-radius: var(--radius-sm);
    font-family: inherit;
    font-size: 17px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.25, 0.1, 0.25, 1);
    outline: none;
  }

  .lobby-btn:hover {
    transform: scale(1.02);
  }

  .lobby-btn.create {
    background: var(--accent);
    color: white;
  }

  .lobby-btn.create:hover {
    background: var(--accent-hover);
  }

  .lobby-btn.join {
    background: var(--card-bg);
    color: var(--text-primary);
    box-shadow: var(--shadow);
  }

  .lobby-btn.join:hover {
    box-shadow: var(--shadow-lg);
  }

  .lobby-btn.local {
    background: rgba(0,0,0,0.04);
    color: var(--text-secondary);
    font-size: 15px;
    font-weight: 500;
    padding: 14px 32px;
  }

  .lobby-btn.local:hover {
    background: rgba(0,0,0,0.08);
    color: var(--text-primary);
  }

  /* Join Input */
  .join-section {
    display: none;
    margin-top: 24px;
    animation: modalIn 0.3s ease;
  }

  .join-section.show {
    display: block;
  }

  .code-input {
    width: 100%;
    padding: 16px;
    border: 2px solid rgba(0,0,0,0.08);
    border-radius: var(--radius-sm);
    font-family: 'Inter', monospace;
    font-size: 24px;
    font-weight: 600;
    text-align: center;
    letter-spacing: 8px;
    outline: none;
    transition: border-color 0.3s ease;
    text-transform: uppercase;
  }

  .code-input:focus {
    border-color: var(--accent);
  }

  .code-input.error {
    border-color: var(--red);
    animation: shake 0.4s ease;
  }

  @keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-8px); }
    75% { transform: translateX(8px); }
  }

  .join-error {
    color: var(--red);
    font-size: 14px;
    margin-top: 8px;
    min-height: 20px;
  }

  .join-actions {
    display: flex;
    gap: 12px;
    margin-top: 16px;
    justify-content: center;
  }

  /* Waiting Screen */
  .waiting-section {
    display: none;
    animation: modalIn 0.3s ease;
  }

  .waiting-section.show {
    display: block;
  }

  .room-code-display {
    font-size: 40px;
    font-weight: 700;
    letter-spacing: 10px;
    color: var(--accent);
    margin: 24px 0 8px;
    font-family: 'Inter', monospace;
  }

  .room-code-hint {
    color: var(--text-secondary);
    font-size: 14px;
    margin-bottom: 24px;
  }

  .copy-btn {
    padding: 10px 24px;
    border: 2px solid rgba(0,0,0,0.08);
    border-radius: 980px;
    background: var(--card-bg);
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.3s ease;
    color: var(--text-primary);
  }

  .copy-btn:hover {
    border-color: var(--accent);
    color: var(--accent);
  }

  .copy-btn.copied {
    border-color: var(--green);
    color: var(--green);
  }

  .waiting-spinner {
    margin: 32px auto 16px;
    width: 40px;
    height: 40px;
    border: 3px solid rgba(0,0,0,0.08);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  .waiting-text {
    color: var(--text-secondary);
    font-size: 15px;
  }

  .cancel-btn {
    margin-top: 24px;
    padding: 10px 24px;
    border: none;
    border-radius: 980px;
    background: rgba(0,0,0,0.06);
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    color: var(--text-secondary);
    transition: all 0.3s ease;
  }

  .cancel-btn:hover {
    background: rgba(0,0,0,0.1);
    color: var(--text-primary);
  }

  /* Responsive */
  @media (max-width: 1100px) {
    .move-history-panel { display: none; }
  }

  @media (max-width: 780px) {
    .main {
      flex-direction: column;
      align-items: center;
      gap: 16px;
      padding: 20px 12px 40px;
    }
    .player-card { min-width: 0; width: 100%; max-width: 420px; padding: 16px 20px; }
    .board-container { padding: 12px; }
    .square { width: 44px; height: 44px; font-size: 30px; }
    .board { grid-template-columns: repeat(8, 44px); grid-template-rows: repeat(8, 44px); }
    .coords-row span { width: 44px; font-size: 10px; }
    .coords-col span { height: 44px; width: 20px; font-size: 10px; }
    .coords-row { padding-left: 20px; padding-right: 20px; }
    .square .move-indicator { width: 12px; height: 12px; }
    .square .capture-indicator { width: 40px; height: 40px; border-width: 4px; }
  }
</style>
</head>
<body>

<!-- Lobby Overlay -->
<div class="lobby-overlay" id="lobby-overlay">
  <div class="lobby">
    <div class="lobby-icon">â™š</div>
    <h2>Chess Online</h2>
    <p>Play chess with friends over the network</p>

    <div class="lobby-buttons" id="lobby-buttons">
      <button class="lobby-btn create" onclick="createRoom()">Create Game</button>
      <button class="lobby-btn join" onclick="showJoinInput()">Join Game</button>
      <button class="lobby-btn local" onclick="startLocal()">Play Locally</button>
    </div>

    <!-- Join Input -->
    <div class="join-section" id="join-section">
      <input type="text" class="code-input" id="code-input" placeholder="CODE" maxlength="6" autocomplete="off" spellcheck="false">
      <div class="join-error" id="join-error"></div>
      <div class="join-actions">
        <button class="btn btn-secondary" onclick="hideJoinInput()">Back</button>
        <button class="btn btn-primary" onclick="joinRoom()">Join</button>
      </div>
    </div>

    <!-- Waiting Screen -->
    <div class="waiting-section" id="waiting-section">
      <div class="room-code-display" id="room-code-display"></div>
      <div class="room-code-hint">Share this code with your opponent</div>
      <button class="copy-btn" id="copy-btn" onclick="copyRoomCode()">Copy Code</button>
      <div class="waiting-spinner"></div>
      <div class="waiting-text">Waiting for opponent...</div>
      <button class="cancel-btn" onclick="cancelWaiting()">Cancel</button>
    </div>
  </div>
</div>

<div class="header">
  <h1>Chess</h1>
  <div class="connection-dot" id="connection-dot" title="Connection status"></div>
</div>

<div class="main">
  <!-- Top Player (opponent from perspective) -->
  <div class="player-card" id="player-top">
    <div class="player-label" id="label-top">Black</div>
    <div class="player-name">
      <span class="piece-icon" id="icon-top">&#9818;</span>
      <span id="name-top">Player 2</span>
    </div>
    <div class="captured" id="captured-top"></div>
    <div class="score-diff" id="score-top"></div>
  </div>

  <!-- Board -->
  <div class="board-container">
    <div class="board-wrapper">
      <div class="coords-row" id="coords-top"></div>
      <div class="board-with-coords">
        <div class="coords-col" id="coords-left"></div>
        <div class="board" id="board"></div>
        <div class="coords-col" id="coords-right"></div>
      </div>
      <div class="coords-row" id="coords-bottom"></div>
    </div>

    <div class="status-bar" id="status">White's turn</div>

    <div class="controls" id="controls">
      <button class="btn btn-secondary" id="btn-undo" onclick="undoMove()">Undo</button>
      <button class="btn btn-primary" id="btn-new" onclick="handleNewGame()">New Game</button>
      <button class="btn btn-danger" id="btn-resign" onclick="resignGame()" style="display:none;">Resign</button>
      <button class="btn btn-secondary" id="btn-draw" onclick="offerDraw()" style="display:none;">Offer Draw</button>
      <button class="btn btn-primary" id="btn-rematch" onclick="requestRematch()" style="display:none;">Rematch</button>
      <button class="btn btn-secondary" id="btn-lobby" onclick="backToLobby()" style="display:none;">Lobby</button>
    </div>
  </div>

  <!-- Bottom Player (you from perspective) -->
  <div class="player-card active" id="player-bottom">
    <div class="player-label" id="label-bottom">White</div>
    <div class="player-name">
      <span class="piece-icon" id="icon-bottom">&#9812;</span>
      <span id="name-bottom">Player 1</span>
    </div>
    <div class="captured" id="captured-bottom"></div>
    <div class="score-diff" id="score-bottom"></div>
  </div>

  <!-- Move History -->
  <div class="move-history-panel">
    <h3>Moves</h3>
    <div class="move-list" id="move-list"></div>
  </div>
</div>

<!-- Promotion Modal -->
<div class="modal-overlay" id="promo-modal">
  <div class="modal">
    <h2>Pawn Promotion</h2>
    <p>Choose a piece</p>
    <div class="promo-pieces" id="promo-pieces"></div>
  </div>
</div>

<!-- Draw Offer Modal -->
<div class="modal-overlay" id="draw-modal">
  <div class="modal">
    <h2>Draw Offer</h2>
    <p>Your opponent offers a draw</p>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="declineDraw()">Decline</button>
      <button class="btn btn-primary" onclick="acceptDraw()">Accept</button>
    </div>
  </div>
</div>

<!-- Rematch Modal -->
<div class="modal-overlay" id="rematch-modal">
  <div class="modal">
    <h2>Rematch?</h2>
    <p>Your opponent wants a rematch (colors will swap)</p>
    <div class="modal-actions">
      <button class="btn btn-secondary" onclick="declineRematch()">Decline</button>
      <button class="btn btn-primary" onclick="acceptRematch()">Accept</button>
    </div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
// ========================
// Piece constants
// ========================
const EMPTY = 0;
const WP = 1, WN = 2, WB = 3, WR = 4, WQ = 5, WK = 6;
const BP = 7, BN = 8, BB = 9, BR = 10, BQ = 11, BK = 12;

const PIECE_UNICODE = {
  [WK]: '\u2654', [WQ]: '\u2655', [WR]: '\u2656', [WB]: '\u2657', [WN]: '\u2658', [WP]: '\u2659',
  [BK]: '\u265A', [BQ]: '\u265B', [BR]: '\u265C', [BB]: '\u265D', [BN]: '\u265E', [BP]: '\u265F'
};

const PIECE_VALUES = { [WP]: 1, [WN]: 3, [WB]: 3, [WR]: 5, [WQ]: 9, [WK]: 0, [BP]: 1, [BN]: 3, [BB]: 3, [BR]: 5, [BQ]: 9, [BK]: 0 };
const PIECE_NAMES = { [WP]: '', [WN]: 'N', [WB]: 'B', [WR]: 'R', [WQ]: 'Q', [WK]: 'K', [BP]: '', [BN]: 'N', [BB]: 'B', [BR]: 'R', [BQ]: 'Q', [BK]: 'K' };

function isWhite(p) { return p >= 1 && p <= 6; }
function isBlack(p) { return p >= 7 && p <= 12; }
function colorOf(p) { return p === 0 ? null : isWhite(p) ? 'w' : 'b'; }

const FILES = 'abcdefgh';

// ========================
// Multiplayer state
// ========================
let socket = null;
let isOnline = false;
let myColor = null;      // 'w' or 'b'
let roomCode = null;
let boardFlipped = false;
let drawOfferedByMe = false;
let rematchRequestedByMe = false;

// ========================
// Game state
// ========================
let board = [];
let turn = 'w';
let selected = null;
let legalMoves = [];
let lastMove = null;
let moveHistory = [];
let stateHistory = [];
let capturedByWhite = [];
let capturedByBlack = [];
let castleRights = { wk: true, wq: true, bk: true, bq: true };
let enPassantTarget = null;
let halfMoveClock = 0;
let fullMoveNumber = 1;
let gameOver = false;
let promotionPending = null;

// ========================
// Socket.IO connection
// ========================
function initSocket() {
  socket = io();

  socket.on('connect', () => {
    document.getElementById('connection-dot').className = 'connection-dot connected';
  });

  socket.on('disconnect', () => {
    document.getElementById('connection-dot').className = 'connection-dot disconnected';
  });

  socket.on('opponent-joined', () => {
    // Start the game
    document.getElementById('lobby-overlay').classList.add('hidden');
    startOnlineGame();
  });

  socket.on('opponent-move', (moveData) => {
    // Reconstruct the move
    const m = {
      fr: moveData.fr, fc: moveData.fc,
      tr: moveData.tr, tc: moveData.tc
    };
    if (moveData.castle) m.castle = moveData.castle;
    if (moveData.promo) m.promo = moveData.promo;

    executeMove(m, true);
  });

  socket.on('opponent-resigned', () => {
    gameOver = true;
    const statusEl = document.getElementById('status');
    statusEl.textContent = 'Opponent resigned. You win!';
    statusEl.className = 'status-bar important';
    showGameOverControls();
  });

  socket.on('draw-offered', () => {
    document.getElementById('draw-modal').classList.add('show');
  });

  socket.on('draw-accepted', () => {
    gameOver = true;
    drawOfferedByMe = false;
    const statusEl = document.getElementById('status');
    statusEl.textContent = 'Draw by agreement';
    statusEl.className = 'status-bar important';
    showGameOverControls();
  });

  socket.on('draw-declined', () => {
    drawOfferedByMe = false;
    document.getElementById('btn-draw').disabled = false;
    document.getElementById('btn-draw').textContent = 'Offer Draw';
  });

  socket.on('rematch-requested', () => {
    document.getElementById('rematch-modal').classList.add('show');
  });

  socket.on('rematch-started', (data) => {
    myColor = data.color;
    boardFlipped = (myColor === 'b');
    rematchRequestedByMe = false;
    drawOfferedByMe = false;
    newGame();
    document.getElementById('lobby-overlay').classList.add('hidden');
    startOnlineGame();
  });

  socket.on('opponent-disconnected', () => {
    if (!gameOver) {
      gameOver = true;
      const statusEl = document.getElementById('status');
      statusEl.textContent = 'Opponent disconnected';
      statusEl.className = 'status-bar important';
    }
    showDisconnectedControls();
  });

  socket.on('room-expired', () => {
    isOnline = false;
    myColor = null;
    roomCode = null;
    backToLobby();
  });
}

// ========================
// Lobby functions
// ========================
function createRoom() {
  socket.emit('create-room', (response) => {
    if (response.error) {
      alert(response.error);
      return;
    }
    roomCode = response.code;
    myColor = response.color;
    boardFlipped = false;

    document.getElementById('lobby-buttons').style.display = 'none';
    document.getElementById('join-section').classList.remove('show');
    document.getElementById('waiting-section').classList.add('show');
    document.getElementById('room-code-display').textContent = roomCode;
  });
}

function showJoinInput() {
  document.getElementById('lobby-buttons').style.display = 'none';
  document.getElementById('join-section').classList.add('show');
  document.getElementById('code-input').value = '';
  document.getElementById('join-error').textContent = '';
  document.getElementById('code-input').focus();
}

function hideJoinInput() {
  document.getElementById('join-section').classList.remove('show');
  document.getElementById('lobby-buttons').style.display = '';
}

function joinRoom() {
  const code = document.getElementById('code-input').value.trim().toUpperCase();
  if (code.length !== 6) {
    document.getElementById('join-error').textContent = 'Enter a 6-character code';
    document.getElementById('code-input').classList.add('error');
    setTimeout(() => document.getElementById('code-input').classList.remove('error'), 400);
    return;
  }

  socket.emit('join-room', code, (response) => {
    if (response.error) {
      document.getElementById('join-error').textContent = response.error;
      document.getElementById('code-input').classList.add('error');
      setTimeout(() => document.getElementById('code-input').classList.remove('error'), 400);
      return;
    }
    roomCode = response.code;
    myColor = response.color;
    boardFlipped = (myColor === 'b');

    document.getElementById('lobby-overlay').classList.add('hidden');
    startOnlineGame();
  });
}

function copyRoomCode() {
  navigator.clipboard.writeText(roomCode).then(() => {
    const btn = document.getElementById('copy-btn');
    btn.textContent = 'Copied!';
    btn.classList.add('copied');
    setTimeout(() => {
      btn.textContent = 'Copy Code';
      btn.classList.remove('copied');
    }, 2000);
  });
}

function cancelWaiting() {
  socket.emit('leave-room');
  roomCode = null;
  myColor = null;
  document.getElementById('waiting-section').classList.remove('show');
  document.getElementById('lobby-buttons').style.display = '';
}

function startLocal() {
  isOnline = false;
  myColor = null;
  boardFlipped = false;
  roomCode = null;
  document.getElementById('lobby-overlay').classList.add('hidden');
  newGame();
  updateControls();
}

function startOnlineGame() {
  isOnline = true;
  newGame();
  updateControls();
}

function backToLobby() {
  if (isOnline && socket) {
    socket.emit('leave-room');
  }
  isOnline = false;
  myColor = null;
  boardFlipped = false;
  roomCode = null;
  drawOfferedByMe = false;
  rematchRequestedByMe = false;

  // Reset lobby UI
  document.getElementById('waiting-section').classList.remove('show');
  document.getElementById('join-section').classList.remove('show');
  document.getElementById('lobby-buttons').style.display = '';
  document.getElementById('lobby-overlay').classList.remove('hidden');
  newGame();
}

function updateControls() {
  const btnUndo = document.getElementById('btn-undo');
  const btnNew = document.getElementById('btn-new');
  const btnResign = document.getElementById('btn-resign');
  const btnDraw = document.getElementById('btn-draw');
  const btnRematch = document.getElementById('btn-rematch');
  const btnLobby = document.getElementById('btn-lobby');

  if (isOnline) {
    btnUndo.style.display = 'none';
    btnNew.style.display = 'none';
    btnResign.style.display = gameOver ? 'none' : '';
    btnDraw.style.display = gameOver ? 'none' : '';
    btnRematch.style.display = gameOver ? '' : 'none';
    btnLobby.style.display = gameOver ? '' : 'none';
    btnDraw.disabled = drawOfferedByMe;
    btnRematch.disabled = rematchRequestedByMe;
  } else {
    btnUndo.style.display = '';
    btnNew.style.display = '';
    btnResign.style.display = 'none';
    btnDraw.style.display = 'none';
    btnRematch.style.display = 'none';
    btnLobby.style.display = '';
  }
}

function showGameOverControls() {
  document.getElementById('btn-resign').style.display = 'none';
  document.getElementById('btn-draw').style.display = 'none';
  document.getElementById('btn-rematch').style.display = '';
  document.getElementById('btn-lobby').style.display = '';
  document.getElementById('btn-rematch').disabled = false;
  rematchRequestedByMe = false;
}

function showDisconnectedControls() {
  document.getElementById('btn-resign').style.display = 'none';
  document.getElementById('btn-draw').style.display = 'none';
  document.getElementById('btn-rematch').style.display = 'none';
  document.getElementById('btn-lobby').style.display = '';
}

// ========================
// Online actions
// ========================
function resignGame() {
  if (!isOnline || gameOver) return;
  gameOver = true;
  socket.emit('resign');
  const statusEl = document.getElementById('status');
  statusEl.textContent = 'You resigned. ' + (myColor === 'w' ? 'Black' : 'White') + ' wins!';
  statusEl.className = 'status-bar important';
  showGameOverControls();
}

function offerDraw() {
  if (!isOnline || gameOver || drawOfferedByMe) return;
  drawOfferedByMe = true;
  socket.emit('offer-draw');
  document.getElementById('btn-draw').disabled = true;
  document.getElementById('btn-draw').textContent = 'Draw Offered';
}

function acceptDraw() {
  document.getElementById('draw-modal').classList.remove('show');
  socket.emit('accept-draw');
  gameOver = true;
  const statusEl = document.getElementById('status');
  statusEl.textContent = 'Draw by agreement';
  statusEl.className = 'status-bar important';
  showGameOverControls();
}

function declineDraw() {
  document.getElementById('draw-modal').classList.remove('show');
  socket.emit('decline-draw');
}

function requestRematch() {
  if (!isOnline || rematchRequestedByMe) return;
  rematchRequestedByMe = true;
  socket.emit('request-rematch');
  document.getElementById('btn-rematch').disabled = true;
  document.getElementById('btn-rematch').textContent = 'Rematch Sent';
}

function acceptRematch() {
  document.getElementById('rematch-modal').classList.remove('show');
  socket.emit('accept-rematch');
  // The server will emit 'rematch-started' to both players
}

function declineRematch() {
  document.getElementById('rematch-modal').classList.remove('show');
}

function handleNewGame() {
  if (isOnline) return;
  newGame();
}

// ========================
// Board init
// ========================
function initBoard() {
  board = [
    [BR, BN, BB, BQ, BK, BB, BN, BR],
    [BP, BP, BP, BP, BP, BP, BP, BP],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [0,  0,  0,  0,  0,  0,  0,  0],
    [WP, WP, WP, WP, WP, WP, WP, WP],
    [WR, WN, WB, WQ, WK, WB, WN, WR]
  ];
}

function cloneBoard(b) { return b.map(r => [...r]); }

function saveState() {
  stateHistory.push({
    board: cloneBoard(board),
    turn,
    castleRights: { ...castleRights },
    enPassantTarget: enPassantTarget ? [...enPassantTarget] : null,
    halfMoveClock,
    fullMoveNumber,
    capturedByWhite: [...capturedByWhite],
    capturedByBlack: [...capturedByBlack],
    lastMove: lastMove ? { ...lastMove } : null,
    moveHistory: moveHistory.map(m => ({ ...m }))
  });
}

function undoMove() {
  if (isOnline) return; // Disabled in online mode
  if (stateHistory.length === 0 || gameOver) return;
  const s = stateHistory.pop();
  board = s.board;
  turn = s.turn;
  castleRights = s.castleRights;
  enPassantTarget = s.enPassantTarget;
  halfMoveClock = s.halfMoveClock;
  fullMoveNumber = s.fullMoveNumber;
  capturedByWhite = s.capturedByWhite;
  capturedByBlack = s.capturedByBlack;
  lastMove = s.lastMove;
  moveHistory = s.moveHistory;
  selected = null;
  legalMoves = [];
  render();
}

// ========================
// Move generation
// ========================
function inBounds(r, c) { return r >= 0 && r < 8 && c >= 0 && c < 8; }

function pseudoLegalMoves(b, color, castle, ep) {
  const moves = [];
  const isAlly = color === 'w' ? isWhite : isBlack;
  const isEnemy = color === 'w' ? isBlack : isWhite;

  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = b[r][c];
      if (!isAlly(p)) continue;

      if (p === WP) {
        if (r > 0 && b[r-1][c] === 0) {
          moves.push({ fr: r, fc: c, tr: r-1, tc: c });
          if (r === 6 && b[r-2][c] === 0) moves.push({ fr: r, fc: c, tr: r-2, tc: c });
        }
        if (r > 0 && c > 0 && (isEnemy(b[r-1][c-1]) || (ep && ep[0] === r-1 && ep[1] === c-1)))
          moves.push({ fr: r, fc: c, tr: r-1, tc: c-1 });
        if (r > 0 && c < 7 && (isEnemy(b[r-1][c+1]) || (ep && ep[0] === r-1 && ep[1] === c+1)))
          moves.push({ fr: r, fc: c, tr: r-1, tc: c+1 });
      }
      else if (p === BP) {
        if (r < 7 && b[r+1][c] === 0) {
          moves.push({ fr: r, fc: c, tr: r+1, tc: c });
          if (r === 1 && b[r+2][c] === 0) moves.push({ fr: r, fc: c, tr: r+2, tc: c });
        }
        if (r < 7 && c > 0 && (isEnemy(b[r+1][c-1]) || (ep && ep[0] === r+1 && ep[1] === c-1)))
          moves.push({ fr: r, fc: c, tr: r+1, tc: c-1 });
        if (r < 7 && c < 7 && (isEnemy(b[r+1][c+1]) || (ep && ep[0] === r+1 && ep[1] === c+1)))
          moves.push({ fr: r, fc: c, tr: r+1, tc: c+1 });
      }
      else if (p === WN || p === BN) {
        for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
          const nr = r+dr, nc = c+dc;
          if (inBounds(nr, nc) && !isAlly(b[nr][nc])) moves.push({ fr: r, fc: c, tr: nr, tc: nc });
        }
      }
      else if (p === WB || p === BB) {
        for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = r+dr*i, nc = c+dc*i;
            if (!inBounds(nr, nc)) break;
            if (isAlly(b[nr][nc])) break;
            moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            if (isEnemy(b[nr][nc])) break;
          }
        }
      }
      else if (p === WR || p === BR) {
        for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = r+dr*i, nc = c+dc*i;
            if (!inBounds(nr, nc)) break;
            if (isAlly(b[nr][nc])) break;
            moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            if (isEnemy(b[nr][nc])) break;
          }
        }
      }
      else if (p === WQ || p === BQ) {
        for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
          for (let i = 1; i < 8; i++) {
            const nr = r+dr*i, nc = c+dc*i;
            if (!inBounds(nr, nc)) break;
            if (isAlly(b[nr][nc])) break;
            moves.push({ fr: r, fc: c, tr: nr, tc: nc });
            if (isEnemy(b[nr][nc])) break;
          }
        }
      }
      else if (p === WK || p === BK) {
        for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
          const nr = r+dr, nc = c+dc;
          if (inBounds(nr, nc) && !isAlly(b[nr][nc])) moves.push({ fr: r, fc: c, tr: nr, tc: nc });
        }
        // Castling
        if (color === 'w' && r === 7 && c === 4) {
          if (castle.wk && b[7][5] === 0 && b[7][6] === 0 && b[7][7] === WR)
            moves.push({ fr: 7, fc: 4, tr: 7, tc: 6, castle: 'wk' });
          if (castle.wq && b[7][3] === 0 && b[7][2] === 0 && b[7][1] === 0 && b[7][0] === WR)
            moves.push({ fr: 7, fc: 4, tr: 7, tc: 2, castle: 'wq' });
        }
        if (color === 'b' && r === 0 && c === 4) {
          if (castle.bk && b[0][5] === 0 && b[0][6] === 0 && b[0][7] === BR)
            moves.push({ fr: 0, fc: 4, tr: 0, tc: 6, castle: 'bk' });
          if (castle.bq && b[0][3] === 0 && b[0][2] === 0 && b[0][1] === 0 && b[0][0] === BR)
            moves.push({ fr: 0, fc: 4, tr: 0, tc: 2, castle: 'bq' });
        }
      }
    }
  }
  return moves;
}

function isSquareAttacked(b, r, c, byColor) {
  // Pawns
  if (byColor === 'w') {
    if (inBounds(r+1, c-1) && b[r+1][c-1] === WP) return true;
    if (inBounds(r+1, c+1) && b[r+1][c+1] === WP) return true;
  } else {
    if (inBounds(r-1, c-1) && b[r-1][c-1] === BP) return true;
    if (inBounds(r-1, c+1) && b[r-1][c+1] === BP) return true;
  }

  // Knights
  const kn = byColor === 'w' ? WN : BN;
  for (const [dr, dc] of [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]) {
    const nr = r+dr, nc = c+dc;
    if (inBounds(nr, nc) && b[nr][nc] === kn) return true;
  }

  // King
  const k = byColor === 'w' ? WK : BK;
  for (const [dr, dc] of [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]]) {
    const nr = r+dr, nc = c+dc;
    if (inBounds(nr, nc) && b[nr][nc] === k) return true;
  }

  // Bishop/Queen diag
  const bish = byColor === 'w' ? WB : BB;
  const queen = byColor === 'w' ? WQ : BQ;
  for (const [dr, dc] of [[-1,-1],[-1,1],[1,-1],[1,1]]) {
    for (let i = 1; i < 8; i++) {
      const nr = r+dr*i, nc = c+dc*i;
      if (!inBounds(nr, nc)) break;
      if (b[nr][nc] === bish || b[nr][nc] === queen) return true;
      if (b[nr][nc] !== 0) break;
    }
  }

  // Rook/Queen straight
  const rk = byColor === 'w' ? WR : BR;
  for (const [dr, dc] of [[-1,0],[1,0],[0,-1],[0,1]]) {
    for (let i = 1; i < 8; i++) {
      const nr = r+dr*i, nc = c+dc*i;
      if (!inBounds(nr, nc)) break;
      if (b[nr][nc] === rk || b[nr][nc] === queen) return true;
      if (b[nr][nc] !== 0) break;
    }
  }

  return false;
}

function findKing(b, color) {
  const k = color === 'w' ? WK : BK;
  for (let r = 0; r < 8; r++)
    for (let c = 0; c < 8; c++)
      if (b[r][c] === k) return [r, c];
  return null;
}

function isInCheck(b, color) {
  const [kr, kc] = findKing(b, color);
  const enemy = color === 'w' ? 'b' : 'w';
  return isSquareAttacked(b, kr, kc, enemy);
}

function makeMoveOnBoard(b, m) {
  const nb = cloneBoard(b);
  const p = nb[m.fr][m.fc];

  // En passant capture
  if ((p === WP || p === BP) && m.tc !== m.fc && nb[m.tr][m.tc] === 0) {
    nb[m.fr][m.tc] = 0;
  }

  nb[m.tr][m.tc] = p;
  nb[m.fr][m.fc] = 0;

  // Castling rook
  if (m.castle === 'wk') { nb[7][5] = WR; nb[7][7] = 0; }
  if (m.castle === 'wq') { nb[7][3] = WR; nb[7][0] = 0; }
  if (m.castle === 'bk') { nb[0][5] = BR; nb[0][7] = 0; }
  if (m.castle === 'bq') { nb[0][3] = BR; nb[0][0] = 0; }

  // Promotion
  if (m.promo) nb[m.tr][m.tc] = m.promo;

  return nb;
}

function getLegalMoves(color) {
  const pseudo = pseudoLegalMoves(board, color, castleRights, enPassantTarget);
  const legal = [];

  for (const m of pseudo) {
    if (m.castle) {
      const enemy = color === 'w' ? 'b' : 'w';
      if (isInCheck(board, color)) continue;
      if (m.castle === 'wk') {
        if (isSquareAttacked(board, 7, 5, enemy) || isSquareAttacked(board, 7, 6, enemy)) continue;
      }
      if (m.castle === 'wq') {
        if (isSquareAttacked(board, 7, 3, enemy) || isSquareAttacked(board, 7, 2, enemy)) continue;
      }
      if (m.castle === 'bk') {
        if (isSquareAttacked(board, 0, 5, enemy) || isSquareAttacked(board, 0, 6, enemy)) continue;
      }
      if (m.castle === 'bq') {
        if (isSquareAttacked(board, 0, 3, enemy) || isSquareAttacked(board, 0, 2, enemy)) continue;
      }
    }

    const p = board[m.fr][m.fc];
    if ((p === WP && m.tr === 0) || (p === BP && m.tr === 7)) {
      const promos = color === 'w' ? [WQ, WR, WB, WN] : [BQ, BR, BB, BN];
      for (const promo of promos) {
        const pm = { ...m, promo };
        const nb = makeMoveOnBoard(board, pm);
        if (!isInCheck(nb, color)) legal.push(pm);
      }
      continue;
    }

    const nb = makeMoveOnBoard(board, m);
    if (!isInCheck(nb, color)) legal.push(m);
  }

  return legal;
}

function getMovesFrom(r, c) {
  return getLegalMoves(turn).filter(m => m.fr === r && m.fc === c);
}

// ========================
// Execute move
// ========================
function executeMove(m, fromNetwork = false) {
  saveState();

  const p = board[m.fr][m.fc];
  let captured = board[m.tr][m.tc];

  // En passant capture
  if ((p === WP || p === BP) && m.tc !== m.fc && captured === 0) {
    captured = board[m.fr][m.tc];
    board[m.fr][m.tc] = 0;
  }

  if (captured) {
    if (isWhite(p)) capturedByWhite.push(captured);
    else capturedByBlack.push(captured);
  }

  // Build notation
  let notation = buildNotation(m, p, captured);

  board[m.tr][m.tc] = p;
  board[m.fr][m.fc] = 0;

  // Castling rook
  if (m.castle === 'wk') { board[7][5] = WR; board[7][7] = 0; }
  if (m.castle === 'wq') { board[7][3] = WR; board[7][0] = 0; }
  if (m.castle === 'bk') { board[0][5] = BR; board[0][7] = 0; }
  if (m.castle === 'bq') { board[0][3] = BR; board[0][0] = 0; }

  // Promotion
  if (m.promo) board[m.tr][m.tc] = m.promo;

  // Update castle rights
  if (p === WK) { castleRights.wk = false; castleRights.wq = false; }
  if (p === BK) { castleRights.bk = false; castleRights.bq = false; }
  if (p === WR && m.fr === 7 && m.fc === 0) castleRights.wq = false;
  if (p === WR && m.fr === 7 && m.fc === 7) castleRights.wk = false;
  if (p === BR && m.fr === 0 && m.fc === 0) castleRights.bq = false;
  if (p === BR && m.fr === 0 && m.fc === 7) castleRights.bk = false;
  if (m.tr === 0 && m.tc === 0) castleRights.bq = false;
  if (m.tr === 0 && m.tc === 7) castleRights.bk = false;
  if (m.tr === 7 && m.tc === 0) castleRights.wq = false;
  if (m.tr === 7 && m.tc === 7) castleRights.wk = false;

  // En passant
  if ((p === WP && m.fr - m.tr === 2)) enPassantTarget = [m.fr - 1, m.fc];
  else if ((p === BP && m.tr - m.fr === 2)) enPassantTarget = [m.fr + 1, m.fc];
  else enPassantTarget = null;

  lastMove = { fr: m.fr, fc: m.fc, tr: m.tr, tc: m.tc };

  // Switch turn
  const prevTurn = turn;
  turn = turn === 'w' ? 'b' : 'w';
  if (turn === 'w') fullMoveNumber++;

  // Check / checkmate / stalemate
  const inCheck = isInCheck(board, turn);
  const legal = getLegalMoves(turn);

  if (inCheck && legal.length === 0) {
    notation += '#';
    gameOver = true;
  } else if (inCheck) {
    notation += '+';
  } else if (legal.length === 0) {
    gameOver = true;
  }

  // Record notation
  if (prevTurn === 'w') {
    moveHistory.push({ num: fullMoveNumber - (turn === 'w' ? 0 : 1), white: notation, black: '' });
  } else {
    if (moveHistory.length > 0) moveHistory[moveHistory.length - 1].black = notation;
  }

  selected = null;
  legalMoves = [];

  // Send move to server (only if it's a local move in online mode)
  if (isOnline && !fromNetwork) {
    const moveData = { fr: m.fr, fc: m.fc, tr: m.tr, tc: m.tc };
    if (m.castle) moveData.castle = m.castle;
    if (m.promo) moveData.promo = m.promo;
    socket.emit('move', moveData);
  }

  render();

  if (isOnline && gameOver) {
    showGameOverControls();
  }
}

function buildNotation(m, p, captured) {
  if (m.castle === 'wk' || m.castle === 'bk') return 'O-O';
  if (m.castle === 'wq' || m.castle === 'bq') return 'O-O-O';

  let n = PIECE_NAMES[p] || '';
  const targetSq = FILES[m.tc] + (8 - m.tr);

  // Disambiguation for non-pawns
  if (n && n !== '') {
    const allLegal = getLegalMoves(colorOf(p));
    const same = allLegal.filter(om => om.tr === m.tr && om.tc === m.tc && board[om.fr][om.fc] === p && (om.fr !== m.fr || om.fc !== m.fc));
    if (same.length > 0) {
      const sameFile = same.some(om => om.fc === m.fc);
      const sameRank = same.some(om => om.fr === m.fr);
      if (!sameFile) n += FILES[m.fc];
      else if (!sameRank) n += (8 - m.fr);
      else n += FILES[m.fc] + (8 - m.fr);
    }
  }

  if ((p === WP || p === BP) && captured) n = FILES[m.fc];

  if (captured) n += 'x';
  n += targetSq;

  if (m.promo) {
    const promoNames = { [WQ]: 'Q', [WR]: 'R', [WB]: 'B', [WN]: 'N', [BQ]: 'Q', [BR]: 'R', [BB]: 'B', [BN]: 'N' };
    n += '=' + promoNames[m.promo];
  }

  return n;
}

// ========================
// Click handling
// ========================
function onSquareClick(r, c) {
  if (gameOver || promotionPending) return;

  // Online mode: block clicks when it's not my turn
  if (isOnline && myColor !== turn) return;

  const p = board[r][c];

  if (selected) {
    // Clicked same square -> deselect
    if (selected[0] === r && selected[1] === c) {
      selected = null;
      legalMoves = [];
      render();
      return;
    }

    // Clicked another own piece -> reselect
    if (p && colorOf(p) === turn) {
      selected = [r, c];
      legalMoves = getMovesFrom(r, c);
      render();
      return;
    }

    // Try to move
    const moves = legalMoves.filter(m => m.tr === r && m.tc === c);
    if (moves.length === 0) {
      selected = null;
      legalMoves = [];
      render();
      return;
    }

    // Check for promotion choices
    if (moves.length > 1 && moves[0].promo) {
      showPromotionModal(moves);
      return;
    }

    executeMove(moves[0]);
    return;
  }

  // Select piece (only own pieces in online mode)
  if (p && colorOf(p) === turn) {
    selected = [r, c];
    legalMoves = getMovesFrom(r, c);
    render();
  }
}

function showPromotionModal(moves) {
  promotionPending = moves;
  const modal = document.getElementById('promo-modal');
  const container = document.getElementById('promo-pieces');
  container.innerHTML = '';

  const displayOrder = turn === 'w' ? [WQ, WR, WB, WN] : [BQ, BR, BB, BN];
  for (const promo of displayOrder) {
    const m = moves.find(mv => mv.promo === promo);
    if (!m) continue;
    const btn = document.createElement('div');
    btn.className = 'promo-piece';
    btn.textContent = PIECE_UNICODE[promo];
    btn.onclick = () => {
      modal.classList.remove('show');
      promotionPending = null;
      executeMove(m);
    };
    container.appendChild(btn);
  }
  modal.classList.add('show');
}

// ========================
// Rendering
// ========================
function render() {
  renderBoard();
  renderStatus();
  renderPlayers();
  renderMoveHistory();
}

function renderBoard() {
  const boardEl = document.getElementById('board');
  boardEl.innerHTML = '';

  const inCheck = isInCheck(board, turn);
  const kingPos = findKing(board, turn);

  for (let ri = 0; ri < 8; ri++) {
    for (let ci = 0; ci < 8; ci++) {
      // If board is flipped (Black perspective), reverse the visual order
      const r = boardFlipped ? (7 - ri) : ri;
      const c = boardFlipped ? (7 - ci) : ci;

      const sq = document.createElement('div');
      const isLight = (r + c) % 2 === 0;
      sq.className = 'square ' + (isLight ? 'light' : 'dark');

      // Last move highlight
      if (lastMove && ((lastMove.fr === r && lastMove.fc === c) || (lastMove.tr === r && lastMove.tc === c))) {
        sq.classList.add('last-move');
      }

      // Selected highlight
      if (selected && selected[0] === r && selected[1] === c) {
        sq.classList.add('selected');
      }

      // Check highlight
      if (inCheck && kingPos && kingPos[0] === r && kingPos[1] === c) {
        sq.classList.add('check');
      }

      // Legal move indicators
      const isLegalTarget = legalMoves.some(m => m.tr === r && m.tc === c);
      if (isLegalTarget) {
        if (board[r][c] !== 0 || (enPassantTarget && enPassantTarget[0] === r && enPassantTarget[1] === c && selected && (board[selected[0]][selected[1]] === WP || board[selected[0]][selected[1]] === BP))) {
          const ind = document.createElement('div');
          ind.className = 'capture-indicator';
          sq.appendChild(ind);
        } else {
          const ind = document.createElement('div');
          ind.className = 'move-indicator';
          sq.appendChild(ind);
        }
      }

      // Piece
      if (board[r][c] !== 0) {
        const piece = document.createElement('span');
        piece.className = 'piece';
        piece.textContent = PIECE_UNICODE[board[r][c]];
        sq.appendChild(piece);
      }

      sq.onclick = () => onSquareClick(r, c);
      boardEl.appendChild(sq);
    }
  }

  // Coordinates
  renderCoords();
}

function renderCoords() {
  const top = document.getElementById('coords-top');
  const bottom = document.getElementById('coords-bottom');
  const left = document.getElementById('coords-left');
  const right = document.getElementById('coords-right');

  top.innerHTML = '';
  bottom.innerHTML = '';
  left.innerHTML = '';
  right.innerHTML = '';

  for (let i = 0; i < 8; i++) {
    const fileIdx = boardFlipped ? (7 - i) : i;
    const rankIdx = boardFlipped ? i : (7 - i);

    const ft = document.createElement('span');
    ft.textContent = FILES[fileIdx];
    top.appendChild(ft);

    const fb = document.createElement('span');
    fb.textContent = FILES[fileIdx];
    bottom.appendChild(fb);

    const rl = document.createElement('span');
    rl.textContent = rankIdx + 1;
    left.appendChild(rl);

    const rr = document.createElement('span');
    rr.textContent = rankIdx + 1;
    right.appendChild(rr);
  }
}

function renderStatus() {
  const statusEl = document.getElementById('status');
  const inCheck = isInCheck(board, turn);
  const legal = getLegalMoves(turn);

  if (gameOver && statusEl.className.includes('important')) {
    // Status already set by resign/draw/disconnect - don't override
    if (!statusEl.textContent.includes('Checkmate') && !statusEl.textContent.includes('Stalemate')) return;
  }

  if (gameOver) {
    if (inCheck) {
      const winner = turn === 'w' ? 'Black' : 'White';
      if (isOnline) {
        const youWin = (turn !== myColor);
        statusEl.textContent = youWin ? 'Checkmate! You win!' : 'Checkmate! You lose.';
      } else {
        statusEl.textContent = `Checkmate! ${winner} wins!`;
      }
      statusEl.className = 'status-bar important';
    } else {
      statusEl.textContent = 'Stalemate! Draw.';
      statusEl.className = 'status-bar important';
    }
  } else if (inCheck) {
    if (isOnline) {
      statusEl.textContent = (turn === myColor) ? 'You are in check!' : 'Opponent is in check!';
    } else {
      statusEl.textContent = (turn === 'w' ? 'White' : 'Black') + ' is in check!';
    }
    statusEl.className = 'status-bar';
  } else {
    if (isOnline) {
      statusEl.textContent = (turn === myColor) ? 'Your turn' : "Opponent's turn";
    } else {
      statusEl.textContent = (turn === 'w' ? "White's turn" : "Black's turn");
    }
    statusEl.className = 'status-bar';
  }
}

function renderPlayers() {
  const topCard = document.getElementById('player-top');
  const bottomCard = document.getElementById('player-bottom');

  // Determine which color is on top/bottom
  // If boardFlipped (Black perspective), White is on top, Black on bottom
  // Otherwise, Black on top, White on bottom
  const topColor = boardFlipped ? 'w' : 'b';
  const bottomColor = boardFlipped ? 'b' : 'w';

  const topIsActive = (turn === topColor) && !gameOver;
  const bottomIsActive = (turn === bottomColor) && !gameOver;

  topCard.classList.toggle('active', topIsActive);
  bottomCard.classList.toggle('active', bottomIsActive);

  // Labels and icons
  document.getElementById('label-top').textContent = topColor === 'w' ? 'White' : 'Black';
  document.getElementById('label-bottom').textContent = bottomColor === 'w' ? 'White' : 'Black';
  document.getElementById('icon-top').innerHTML = topColor === 'w' ? '&#9812;' : '&#9818;';
  document.getElementById('icon-bottom').innerHTML = bottomColor === 'w' ? '&#9812;' : '&#9818;';

  if (isOnline) {
    document.getElementById('name-top').textContent = 'Opponent';
    document.getElementById('name-bottom').textContent = 'You';
  } else {
    document.getElementById('name-top').textContent = topColor === 'w' ? 'Player 1' : 'Player 2';
    document.getElementById('name-bottom').textContent = bottomColor === 'w' ? 'Player 1' : 'Player 2';
  }

  // Captured pieces
  const sortPieces = (arr) => [...arr].sort((a, b) => PIECE_VALUES[b] - PIECE_VALUES[a]);

  // Top player captured = pieces captured BY the top-color player
  const topCaptured = topColor === 'w' ? capturedByWhite : capturedByBlack;
  const bottomCaptured = bottomColor === 'w' ? capturedByWhite : capturedByBlack;

  document.getElementById('captured-top').innerHTML = sortPieces(topCaptured).map(p => `<span>${PIECE_UNICODE[p]}</span>`).join('');
  document.getElementById('captured-bottom').innerHTML = sortPieces(bottomCaptured).map(p => `<span>${PIECE_UNICODE[p]}</span>`).join('');

  // Score diff
  const whiteScore = capturedByWhite.reduce((s, p) => s + PIECE_VALUES[p], 0);
  const blackScore = capturedByBlack.reduce((s, p) => s + PIECE_VALUES[p], 0);
  const diff = whiteScore - blackScore;

  const topDiff = topColor === 'w' ? diff : -diff;
  const bottomDiff = bottomColor === 'w' ? diff : -diff;

  document.getElementById('score-top').textContent = topDiff > 0 ? `+${topDiff}` : '';
  document.getElementById('score-bottom').textContent = bottomDiff > 0 ? `+${bottomDiff}` : '';
}

function renderMoveHistory() {
  const list = document.getElementById('move-list');
  list.innerHTML = '';

  for (const m of moveHistory) {
    const row = document.createElement('div');
    row.className = 'move-row';
    row.innerHTML = `<span class="move-num">${m.num}.</span><span class="move-white">${m.white}</span><span class="move-black">${m.black}</span>`;
    list.appendChild(row);
  }

  list.scrollTop = list.scrollHeight;
}

function newGame() {
  initBoard();
  turn = 'w';
  selected = null;
  legalMoves = [];
  lastMove = null;
  moveHistory = [];
  stateHistory = [];
  capturedByWhite = [];
  capturedByBlack = [];
  castleRights = { wk: true, wq: true, bk: true, bq: true };
  enPassantTarget = null;
  halfMoveClock = 0;
  fullMoveNumber = 1;
  gameOver = false;
  promotionPending = null;
  drawOfferedByMe = false;

  // Reset draw button text
  const btnDraw = document.getElementById('btn-draw');
  if (btnDraw) {
    btnDraw.textContent = 'Offer Draw';
    btnDraw.disabled = false;
  }
  const btnRematch = document.getElementById('btn-rematch');
  if (btnRematch) {
    btnRematch.textContent = 'Rematch';
    btnRematch.disabled = false;
  }

  updateControls();
  render();
}

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undoMove();
  }
});

// Enter key for join input
document.getElementById('code-input').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') joinRoom();
});

// ========================
// Init
// ========================
initSocket();
newGame();
</script>
</body>
</html>
