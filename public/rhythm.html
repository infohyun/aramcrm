<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>RHYTHM - Beat Sync</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --cyan: #00f0ff;
  --purple: #a855f7;
  --gold: #f59e0b;
  --pink: #ec4899;
  --red: #ef4444;
  --green: #22c55e;
  --bg: #05050f;
  --glass: rgba(255, 255, 255, 0.03);
  --glass-border: rgba(255, 255, 255, 0.08);
  --text: #e2e8f0;
  --text-dim: rgba(255, 255, 255, 0.4);
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  font-family: 'Rajdhani', sans-serif;
  color: var(--text);
}

#gameCanvas {
  display: block;
  width: 100%; height: 100%;
  position: fixed; top: 0; left: 0;
}

/* ===== MENU OVERLAY ===== */
.overlay {
  position: fixed; inset: 0;
  display: flex; align-items: center; justify-content: center;
  z-index: 100;
  background: rgba(5, 5, 15, 0.92);
  backdrop-filter: blur(20px);
  transition: opacity 0.5s ease, visibility 0.5s ease;
}
.overlay.hidden {
  opacity: 0; visibility: hidden; pointer-events: none;
}

.menu-panel {
  background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
  border: 1px solid var(--glass-border);
  border-radius: 24px;
  padding: 50px 60px;
  text-align: center;
  backdrop-filter: blur(30px);
  box-shadow:
    0 0 80px rgba(0, 240, 255, 0.06),
    0 0 160px rgba(168, 85, 247, 0.04),
    inset 0 1px 0 rgba(255,255,255,0.06);
  max-width: 500px;
  width: 90%;
  animation: panelIn 0.6s ease;
}
@keyframes panelIn {
  from { transform: scale(0.9) translateY(30px); opacity: 0; }
  to { transform: scale(1) translateY(0); opacity: 1; }
}

.menu-title {
  font-family: 'Orbitron', sans-serif;
  font-size: 3.2rem;
  font-weight: 900;
  letter-spacing: 8px;
  background: linear-gradient(135deg, var(--cyan), var(--purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  text-shadow: none;
  filter: drop-shadow(0 0 20px rgba(0, 240, 255, 0.3));
}
.menu-subtitle {
  font-family: 'Orbitron', sans-serif;
  font-size: 1rem;
  letter-spacing: 12px;
  color: var(--text-dim);
  margin-top: 4px;
  margin-bottom: 36px;
}

.bpm-section {
  margin-bottom: 32px;
}
.bpm-label {
  font-family: 'Orbitron', sans-serif;
  font-size: 0.85rem;
  letter-spacing: 4px;
  color: var(--text-dim);
  margin-bottom: 14px;
  text-transform: uppercase;
}
.bpm-options {
  display: flex;
  gap: 12px;
  justify-content: center;
}
.bpm-btn {
  font-family: 'Orbitron', sans-serif;
  font-size: 1.1rem;
  font-weight: 700;
  padding: 12px 22px;
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  background: var(--glass);
  color: var(--text-dim);
  cursor: pointer;
  transition: all 0.3s ease;
  min-width: 64px;
}
.bpm-btn:hover {
  border-color: rgba(0, 240, 255, 0.3);
  color: var(--cyan);
  background: rgba(0, 240, 255, 0.05);
  box-shadow: 0 0 20px rgba(0, 240, 255, 0.1);
}
.bpm-btn.active {
  border-color: var(--cyan);
  color: #fff;
  background: linear-gradient(135deg, rgba(0, 240, 255, 0.15), rgba(168, 85, 247, 0.1));
  box-shadow: 0 0 30px rgba(0, 240, 255, 0.15);
}

.start-btn {
  font-family: 'Orbitron', sans-serif;
  font-size: 1.1rem;
  font-weight: 700;
  letter-spacing: 6px;
  padding: 16px 52px;
  border: 1px solid var(--cyan);
  border-radius: 14px;
  background: linear-gradient(135deg, rgba(0, 240, 255, 0.12), rgba(168, 85, 247, 0.08));
  color: var(--cyan);
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  margin-top: 8px;
}
.start-btn:hover {
  background: linear-gradient(135deg, rgba(0, 240, 255, 0.25), rgba(168, 85, 247, 0.15));
  box-shadow: 0 0 40px rgba(0, 240, 255, 0.2), 0 0 80px rgba(168, 85, 247, 0.1);
  transform: translateY(-2px);
}

.high-score-text {
  font-family: 'Rajdhani', sans-serif;
  font-size: 0.9rem;
  color: var(--text-dim);
  margin-top: 20px;
}
.high-score-text span {
  color: var(--gold);
  font-weight: 700;
}

.key-hint {
  font-size: 0.8rem;
  color: var(--text-dim);
  margin-top: 16px;
  letter-spacing: 2px;
}
.key-hint kbd {
  display: inline-block;
  padding: 2px 8px;
  border: 1px solid var(--glass-border);
  border-radius: 4px;
  background: var(--glass);
  font-family: 'Orbitron', sans-serif;
  font-size: 0.75rem;
  margin: 0 2px;
}

.back-link {
  position: fixed;
  top: 20px; left: 20px;
  font-family: 'Orbitron', sans-serif;
  font-size: 0.75rem;
  letter-spacing: 3px;
  color: var(--text-dim);
  text-decoration: none;
  z-index: 200;
  padding: 10px 18px;
  border: 1px solid var(--glass-border);
  border-radius: 10px;
  background: var(--glass);
  backdrop-filter: blur(10px);
  transition: all 0.3s ease;
}
.back-link:hover {
  color: var(--cyan);
  border-color: rgba(0, 240, 255, 0.3);
}

/* ===== RESULTS OVERLAY ===== */
.results-panel {
  background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.01));
  border: 1px solid var(--glass-border);
  border-radius: 24px;
  padding: 44px 56px;
  text-align: center;
  backdrop-filter: blur(30px);
  box-shadow:
    0 0 80px rgba(0, 240, 255, 0.06),
    0 0 160px rgba(168, 85, 247, 0.04),
    inset 0 1px 0 rgba(255,255,255,0.06);
  max-width: 480px;
  width: 90%;
  animation: panelIn 0.6s ease;
}
.results-title {
  font-family: 'Orbitron', sans-serif;
  font-size: 1.6rem;
  font-weight: 700;
  letter-spacing: 8px;
  color: var(--text-dim);
  margin-bottom: 8px;
}
.grade-display {
  font-family: 'Orbitron', sans-serif;
  font-size: 5rem;
  font-weight: 900;
  line-height: 1;
  margin-bottom: 8px;
}
.grade-S { background: linear-gradient(135deg, var(--gold), #fbbf24, var(--gold)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 30px rgba(245,158,11,0.5)); }
.grade-A { background: linear-gradient(135deg, var(--cyan), #67e8f9); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(0,240,255,0.4)); }
.grade-B { background: linear-gradient(135deg, var(--green), #86efac); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(34,197,94,0.4)); }
.grade-C { background: linear-gradient(135deg, var(--purple), #c084fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent; filter: drop-shadow(0 0 20px rgba(168,85,247,0.4)); }

.score-big {
  font-family: 'Orbitron', sans-serif;
  font-size: 2.6rem;
  font-weight: 800;
  color: #fff;
  margin-bottom: 24px;
}
.stat-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px 20px;
  margin-bottom: 28px;
}
.stat-item {
  display: flex; justify-content: space-between; align-items: center;
  padding: 8px 16px;
  border-radius: 8px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.04);
}
.stat-label {
  font-size: 0.85rem;
  color: var(--text-dim);
  letter-spacing: 1px;
}
.stat-value {
  font-family: 'Orbitron', sans-serif;
  font-weight: 700;
  font-size: 1rem;
}
.stat-perfect .stat-value { color: var(--gold); }
.stat-great .stat-value { color: var(--cyan); }
.stat-good .stat-value { color: var(--green); }
.stat-miss .stat-value { color: var(--red); }
.stat-combo .stat-value { color: var(--purple); }
.stat-combo { grid-column: 1 / -1; }

.new-record {
  font-family: 'Orbitron', sans-serif;
  font-size: 0.9rem;
  letter-spacing: 4px;
  color: var(--gold);
  margin-bottom: 12px;
  animation: pulse 1s ease infinite;
}
@keyframes pulse { 0%,100%{ opacity:1; } 50%{ opacity:0.5; } }

.result-btns {
  display: flex; gap: 12px; justify-content: center; margin-top: 4px;
}
.retry-btn, .menu-back-btn {
  font-family: 'Orbitron', sans-serif;
  font-size: 0.85rem;
  font-weight: 600;
  letter-spacing: 4px;
  padding: 13px 32px;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
}
.retry-btn {
  border: 1px solid var(--cyan);
  background: linear-gradient(135deg, rgba(0,240,255,0.12), rgba(168,85,247,0.08));
  color: var(--cyan);
}
.retry-btn:hover {
  background: linear-gradient(135deg, rgba(0,240,255,0.25), rgba(168,85,247,0.15));
  box-shadow: 0 0 30px rgba(0,240,255,0.2);
}
.menu-back-btn {
  border: 1px solid var(--glass-border);
  background: var(--glass);
  color: var(--text-dim);
}
.menu-back-btn:hover {
  border-color: rgba(255,255,255,0.15);
  color: var(--text);
}

/* Mobile touch lanes overlay */
.touch-lanes {
  position: fixed;
  bottom: 0; left: 0; right: 0;
  height: 100%;
  display: none;
  z-index: 50;
}
@media (pointer: coarse) {
  .touch-lanes { display: flex; }
}
.touch-lane {
  flex: 1;
  height: 100%;
  opacity: 0;
}
.touch-lane:active {
  opacity: 0.08;
  background: white;
}
</style>
</head>
<body>

<a href="/games.html" class="back-link">&#9664; ARCADE</a>

<canvas id="gameCanvas"></canvas>

<!-- MENU -->
<div id="menuOverlay" class="overlay">
  <div class="menu-panel">
    <div class="menu-title">RHYTHM</div>
    <div class="menu-subtitle">BEAT SYNC</div>

    <div class="bpm-section">
      <div class="bpm-label">Select BPM</div>
      <div class="bpm-options">
        <button class="bpm-btn" data-bpm="80">80</button>
        <button class="bpm-btn" data-bpm="100">100</button>
        <button class="bpm-btn active" data-bpm="120">120</button>
        <button class="bpm-btn" data-bpm="140">140</button>
      </div>
    </div>

    <button class="start-btn" id="startBtn">START</button>
    <div class="high-score-text" id="highScoreText"></div>
    <div class="key-hint">Keys: <kbd>D</kbd> <kbd>F</kbd> <kbd>J</kbd> <kbd>K</kbd></div>
  </div>
</div>

<!-- RESULTS -->
<div id="resultsOverlay" class="overlay hidden">
  <div class="results-panel">
    <div class="results-title">RESULTS</div>
    <div class="grade-display" id="gradeDisplay">S</div>
    <div class="score-big" id="scoreBig">0</div>
    <div class="new-record hidden" id="newRecord">NEW RECORD</div>
    <div class="stat-grid">
      <div class="stat-item stat-perfect"><span class="stat-label">PERFECT</span><span class="stat-value" id="statPerfect">0</span></div>
      <div class="stat-item stat-great"><span class="stat-label">GREAT</span><span class="stat-value" id="statGreat">0</span></div>
      <div class="stat-item stat-good"><span class="stat-label">GOOD</span><span class="stat-value" id="statGood">0</span></div>
      <div class="stat-item stat-miss"><span class="stat-label">MISS</span><span class="stat-value" id="statMiss">0</span></div>
      <div class="stat-item stat-combo"><span class="stat-label">MAX COMBO</span><span class="stat-value" id="statCombo">0</span></div>
    </div>
    <div class="result-btns">
      <button class="retry-btn" id="retryBtn">RETRY</button>
      <button class="menu-back-btn" id="menuBtn">MENU</button>
    </div>
  </div>
</div>

<!-- Touch lanes for mobile -->
<div class="touch-lanes" id="touchLanes">
  <div class="touch-lane" data-lane="0"></div>
  <div class="touch-lane" data-lane="1"></div>
  <div class="touch-lane" data-lane="2"></div>
  <div class="touch-lane" data-lane="3"></div>
</div>

<script>
// ===================================================
// RHYTHM - BEAT SYNC  |  Premium Rhythm Game
// ===================================================

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// ---- Constants ----
const LANE_COLORS = ['#00f0ff', '#a855f7', '#f59e0b', '#ec4899']; // cyan, purple, gold, pink
const LANE_KEYS = ['d', 'f', 'j', 'k'];
const LANE_LABELS = ['D', 'F', 'J', 'K'];
const JUDGMENTS = {
  PERFECT: { window: 45, label: 'PERFECT', color: '#f59e0b', score: 300 },
  GREAT:   { window: 80, label: 'GREAT',   color: '#00f0ff', score: 200 },
  GOOD:    { window: 120, label: 'GOOD',    color: '#22c55e', score: 100 },
  MISS:    { window: 160, label: 'MISS',    color: '#ef4444', score: 0 }
};
const GAME_DURATION_BEATS = 128; // song length in beats
const NOTE_SPEED_BASE = 600; // pixels per second at 120 BPM

// ---- State ----
let W, H;
let selectedBPM = 120;
let gameState = 'menu'; // menu | playing | results
let score = 0;
let combo = 0;
let maxCombo = 0;
let health = 100;
let counts = { perfect: 0, great: 0, good: 0, miss: 0 };
let notes = [];
let particles = [];
let judgmentPopups = [];
let lanePressed = [false, false, false, false];
let lanePressTime = [0, 0, 0, 0];
let beatPulse = 0;
let gameStartTime = 0;
let lastBeatTime = 0;
let totalNotesInSong = 0;
let songEnded = false;
let endCheckTime = 0;

// Audio
let audioCtx = null;
let masterGain = null;
let beatScheduled = {};

// Animation
let animFrame = null;
let lastTime = 0;

// ---- Layout ----
let laneWidth, totalLanesWidth, lanesLeft, hitLineY, noteRadius;

function resize() {
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  laneWidth = Math.min(100, W / 5.5);
  totalLanesWidth = laneWidth * 4;
  lanesLeft = (W - totalLanesWidth) / 2;
  hitLineY = H - H * 0.13;
  noteRadius = laneWidth * 0.22;
}
window.addEventListener('resize', resize);
resize();

// ---- High Score ----
function getHighScore(bpm) {
  try { return parseInt(localStorage.getItem('rhythm_hs_' + bpm)) || 0; } catch(e) { return 0; }
}
function setHighScore(bpm, s) {
  try { localStorage.setItem('rhythm_hs_' + bpm, s); } catch(e) {}
}
function updateHighScoreDisplay() {
  const hs = getHighScore(selectedBPM);
  const el = document.getElementById('highScoreText');
  el.innerHTML = hs > 0 ? `Best Score: <span>${hs.toLocaleString()}</span>` : '';
}

// ---- BPM Buttons ----
document.querySelectorAll('.bpm-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.bpm-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    selectedBPM = parseInt(btn.dataset.bpm);
    updateHighScoreDisplay();
  });
});
updateHighScoreDisplay();

// ---- Audio System ----
function initAudio() {
  if (audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  masterGain = audioCtx.createGain();
  masterGain.gain.value = 0.25;
  masterGain.connect(audioCtx.destination);
}

function playHitSound(lane, judgment) {
  if (!audioCtx) return;
  const now = audioCtx.currentTime;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const baseFreqs = [261.63, 329.63, 392.00, 523.25]; // C4, E4, G4, C5
  osc.frequency.value = baseFreqs[lane];
  osc.type = judgment === 'MISS' ? 'sawtooth' : 'triangle';
  gain.gain.setValueAtTime(judgment === 'MISS' ? 0.05 : 0.18, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
  osc.connect(gain);
  gain.connect(masterGain);
  osc.start(now);
  osc.stop(now + 0.15);
}

function playBeatSound(time, strong) {
  if (!audioCtx) return;
  // Kick-like sound on strong beats
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(strong ? 80 : 60, time);
  osc.frequency.exponentialRampToValueAtTime(30, time + 0.08);
  gain.gain.setValueAtTime(strong ? 0.2 : 0.08, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
  osc.connect(gain);
  gain.connect(masterGain);
  osc.start(time);
  osc.stop(time + 0.12);

  // Hi-hat on every beat
  const bufferSize = audioCtx.sampleRate * 0.04;
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
  const noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  const hpf = audioCtx.createBiquadFilter();
  hpf.type = 'highpass';
  hpf.frequency.value = 8000;
  const g2 = audioCtx.createGain();
  g2.gain.setValueAtTime(strong ? 0.06 : 0.04, time);
  g2.gain.exponentialRampToValueAtTime(0.001, time + 0.04);
  noise.connect(hpf);
  hpf.connect(g2);
  g2.connect(masterGain);
  noise.start(time);
  noise.stop(time + 0.05);
}

function scheduleBeatSounds() {
  if (!audioCtx) return;
  const beatInterval = 60 / selectedBPM;
  const now = audioCtx.currentTime;
  const elapsed = now - (gameStartTime / 1000);
  const lookAhead = 0.2; // schedule 200ms ahead

  for (let beat = 0; beat <= GAME_DURATION_BEATS; beat++) {
    const beatTime = beat * beatInterval;
    const audioTime = (gameStartTime / 1000) + beatTime;
    const key = beat;
    if (audioTime > now && audioTime < now + lookAhead && !beatScheduled[key]) {
      beatScheduled[key] = true;
      playBeatSound(audioTime, beat % 4 === 0);
    }
  }
}

// ---- Note Pattern Generation ----
function generateNotes() {
  notes = [];
  const beatInterval = 60 / selectedBPM; // seconds per beat
  const speed = NOTE_SPEED_BASE * (selectedBPM / 120);
  const travelTime = hitLineY / speed; // time for note to travel from top to hit line

  // Seed-based pseudo-random for consistent patterns
  let seed = selectedBPM * 7 + 42;
  function rand() {
    seed = (seed * 16807 + 0) % 2147483647;
    return (seed - 1) / 2147483646;
  }

  // Pattern templates (relative beat offsets within a measure)
  const patterns = [
    // Simple quarter notes
    [[0, 0], [1, 1], [2, 2], [3, 3]],
    [[0, 0], [1, 2], [2, 1], [3, 3]],
    // Eighth note patterns
    [[0, 0], [0.5, 2], [1, 1], [1.5, 3], [2, 0], [2.5, 2], [3, 1], [3.5, 3]],
    [[0, 0], [0.5, 1], [1, 2], [1.5, 3], [2, 3], [2.5, 2], [3, 1], [3.5, 0]],
    // Syncopated
    [[0, 0], [0.5, 1], [1.5, 2], [2, 3], [3, 0], [3.5, 2]],
    [[0, 1], [0.5, 2], [1, 3], [2, 0], [2.5, 1], [3, 2], [3.5, 3]],
    // Trills
    [[0, 1], [0.5, 2], [1, 1], [1.5, 2], [2, 0], [2.5, 3], [3, 0], [3.5, 3]],
    // Chord-like
    [[0, 0], [0, 1], [2, 2], [2, 3]],
    [[0, 0], [0, 3], [1, 1], [1, 2], [2, 0], [2, 3], [3, 1], [3, 2]],
    // Sparse
    [[0, 0], [2, 2]],
    [[1, 1], [3, 3]],
    // Runs
    [[0, 0], [0.5, 1], [1, 2], [1.5, 3], [2, 3], [2.5, 2], [3, 1], [3.5, 0]],
    // Gallops
    [[0, 0], [0.25, 0], [1, 2], [1.25, 2], [2, 1], [2.25, 1], [3, 3], [3.25, 3]],
  ];

  // Build the song: 128 beats = 32 measures of 4
  const measures = GAME_DURATION_BEATS / 4;
  for (let m = 0; m < measures; m++) {
    // Difficulty ramp: first 4 measures are easier
    let availablePatterns;
    if (m < 4) {
      availablePatterns = patterns.slice(0, 4); // simple patterns
    } else if (m < 12) {
      availablePatterns = patterns.slice(0, 8);
    } else {
      availablePatterns = patterns;
    }

    const pat = availablePatterns[Math.floor(rand() * availablePatterns.length)];

    for (const [beatOffset, lane] of pat) {
      const beat = m * 4 + beatOffset;
      const hitTime = beat * beatInterval; // time in seconds when note should be hit
      notes.push({
        lane: lane,
        hitTime: hitTime, // seconds from game start
        y: -noteRadius, // will be calculated each frame
        hit: false,
        missed: false,
        judged: false
      });
    }
  }

  // Sort by hitTime
  notes.sort((a, b) => a.hitTime - b.hitTime);
  totalNotesInSong = notes.length;
}

// ---- Particles ----
function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const angle = (Math.PI * 2 / count) * i + (Math.random() - 0.5) * 0.5;
    const speed = 150 + Math.random() * 250;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed - 80,
      life: 1,
      decay: 1.5 + Math.random() * 1.5,
      size: 2 + Math.random() * 4,
      color
    });
  }
}

// ---- Judgment Popup ----
function showJudgment(lane, judgment) {
  const x = lanesLeft + lane * laneWidth + laneWidth / 2;
  judgmentPopups.push({
    x,
    y: hitLineY - 40,
    label: judgment.label,
    color: judgment.color,
    life: 1,
    vy: -100
  });
}

// ---- Hit Logic ----
function tryHitLane(lane) {
  if (gameState !== 'playing') return;
  const now = performance.now();
  const elapsed = (now - gameStartTime) / 1000;

  // Find closest unhit note in this lane
  let closest = null;
  let closestDist = Infinity;

  for (const note of notes) {
    if (note.lane !== lane || note.judged) continue;
    const dist = Math.abs(note.hitTime - elapsed) * 1000; // ms
    if (dist < closestDist) {
      closestDist = dist;
      closest = note;
    }
  }

  if (!closest) return;

  let judgment = null;
  if (closestDist <= JUDGMENTS.PERFECT.window) judgment = JUDGMENTS.PERFECT;
  else if (closestDist <= JUDGMENTS.GREAT.window) judgment = JUDGMENTS.GREAT;
  else if (closestDist <= JUDGMENTS.GOOD.window) judgment = JUDGMENTS.GOOD;
  else return; // too far, ignore

  closest.judged = true;
  closest.hit = true;

  // Combo
  combo++;
  if (combo > maxCombo) maxCombo = combo;

  // Score with multiplier
  const multiplier = Math.min(1 + Math.floor(combo / 10) * 0.5, 5);
  score += Math.floor(judgment.score * multiplier);

  // Count
  if (judgment === JUDGMENTS.PERFECT) { counts.perfect++; health = Math.min(100, health + 2); }
  else if (judgment === JUDGMENTS.GREAT) { counts.great++; health = Math.min(100, health + 1); }
  else { counts.good++; }

  // Effects
  const x = lanesLeft + lane * laneWidth + laneWidth / 2;
  spawnParticles(x, hitLineY, LANE_COLORS[lane], judgment === JUDGMENTS.PERFECT ? 24 : 14);
  showJudgment(lane, judgment);
  playHitSound(lane, judgment.label);
}

function missNote(note) {
  if (note.judged) return;
  note.judged = true;
  note.missed = true;
  combo = 0;
  counts.miss++;
  health = Math.max(0, health - 8);
  showJudgment(note.lane, JUDGMENTS.MISS);
}

// ---- Input ----
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  const idx = LANE_KEYS.indexOf(key);
  if (idx >= 0) {
    e.preventDefault();
    if (!lanePressed[idx]) {
      lanePressed[idx] = true;
      lanePressTime[idx] = performance.now();
      tryHitLane(idx);
    }
  }
  // Space to start
  if (key === ' ' || key === 'enter') {
    if (gameState === 'menu') {
      e.preventDefault();
      startGame();
    }
  }
});
window.addEventListener('keyup', e => {
  const idx = LANE_KEYS.indexOf(e.key.toLowerCase());
  if (idx >= 0) lanePressed[idx] = false;
});

// Touch
document.querySelectorAll('.touch-lane').forEach(el => {
  el.addEventListener('touchstart', e => {
    e.preventDefault();
    const lane = parseInt(el.dataset.lane);
    lanePressed[lane] = true;
    lanePressTime[lane] = performance.now();
    tryHitLane(lane);
  }, { passive: false });
  el.addEventListener('touchend', e => {
    const lane = parseInt(el.dataset.lane);
    lanePressed[lane] = false;
  });
});

// ---- Start / End ----
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('retryBtn').addEventListener('click', startGame);
document.getElementById('menuBtn').addEventListener('click', () => {
  gameState = 'menu';
  document.getElementById('resultsOverlay').classList.add('hidden');
  document.getElementById('menuOverlay').classList.remove('hidden');
  updateHighScoreDisplay();
});

function startGame() {
  initAudio();
  if (audioCtx.state === 'suspended') audioCtx.resume();

  gameState = 'playing';
  score = 0;
  combo = 0;
  maxCombo = 0;
  health = 100;
  counts = { perfect: 0, great: 0, good: 0, miss: 0 };
  particles = [];
  judgmentPopups = [];
  beatScheduled = {};
  songEnded = false;
  endCheckTime = 0;

  generateNotes();

  document.getElementById('menuOverlay').classList.add('hidden');
  document.getElementById('resultsOverlay').classList.add('hidden');

  // Countdown delay
  gameStartTime = performance.now() + 2000; // 2 second lead-in
  lastTime = performance.now();

  if (!animFrame) gameLoop(performance.now());
}

function endGame() {
  gameState = 'results';

  // Grade
  const totalHittable = counts.perfect + counts.great + counts.good + counts.miss;
  const accuracy = totalHittable > 0 ? (counts.perfect * 100 + counts.great * 80 + counts.good * 50) / totalHittable : 0;
  let grade, gradeClass;
  if (accuracy >= 95) { grade = 'S'; gradeClass = 'grade-S'; }
  else if (accuracy >= 80) { grade = 'A'; gradeClass = 'grade-A'; }
  else if (accuracy >= 60) { grade = 'B'; gradeClass = 'grade-B'; }
  else { grade = 'C'; gradeClass = 'grade-C'; }

  // High score
  const hs = getHighScore(selectedBPM);
  const isNew = score > hs;
  if (isNew) setHighScore(selectedBPM, score);

  // Populate UI
  const gd = document.getElementById('gradeDisplay');
  gd.textContent = grade;
  gd.className = 'grade-display ' + gradeClass;
  document.getElementById('scoreBig').textContent = score.toLocaleString();
  document.getElementById('statPerfect').textContent = counts.perfect;
  document.getElementById('statGreat').textContent = counts.great;
  document.getElementById('statGood').textContent = counts.good;
  document.getElementById('statMiss').textContent = counts.miss;
  document.getElementById('statCombo').textContent = maxCombo;

  const nr = document.getElementById('newRecord');
  if (isNew && score > 0) nr.classList.remove('hidden');
  else nr.classList.add('hidden');

  document.getElementById('resultsOverlay').classList.remove('hidden');
}

// ---- Rendering ----
function drawBackground(dt, elapsed) {
  // Base background
  ctx.fillStyle = '#05050f';
  ctx.fillRect(0, 0, W, H);

  // Beat pulse
  const beatInterval = 60 / selectedBPM;
  if (gameState === 'playing' && elapsed > 0) {
    const beatPhase = (elapsed % beatInterval) / beatInterval;
    beatPulse = Math.max(0, 1 - beatPhase * 3);
  } else {
    beatPulse *= 0.95;
  }

  // Subtle radial pulse
  if (beatPulse > 0.01) {
    const grad = ctx.createRadialGradient(W/2, H*0.5, 0, W/2, H*0.5, W*0.6);
    grad.addColorStop(0, `rgba(168, 85, 247, ${0.04 * beatPulse})`);
    grad.addColorStop(0.5, `rgba(0, 240, 255, ${0.02 * beatPulse})`);
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
  }

  // Vertical grid lines (subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.015)';
  ctx.lineWidth = 1;
  for (let i = 0; i <= 4; i++) {
    const x = lanesLeft + i * laneWidth;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, H);
    ctx.stroke();
  }

  // Horizontal scan lines (very subtle)
  ctx.strokeStyle = 'rgba(255,255,255,0.008)';
  for (let y = 0; y < H; y += 4) {
    ctx.beginPath();
    ctx.moveTo(lanesLeft, y);
    ctx.lineTo(lanesLeft + totalLanesWidth, y);
    ctx.stroke();
  }
}

function drawLaneGlow() {
  // Dark lane backgrounds
  for (let i = 0; i < 4; i++) {
    const x = lanesLeft + i * laneWidth;
    const pressed = lanePressed[i];
    const col = LANE_COLORS[i];

    // Lane bg
    ctx.fillStyle = pressed ? hexToRGBA(col, 0.06) : 'rgba(255,255,255,0.01)';
    ctx.fillRect(x, 0, laneWidth, H);

    // Lane separator highlights
    if (pressed) {
      const grad = ctx.createLinearGradient(x, hitLineY - 200, x, hitLineY);
      grad.addColorStop(0, 'transparent');
      grad.addColorStop(1, hexToRGBA(col, 0.12));
      ctx.fillStyle = grad;
      ctx.fillRect(x, 0, laneWidth, H);
    }
  }
}

function drawHitZone() {
  // Hit line
  const glowY = hitLineY;

  // Glow under hit line
  const underGrad = ctx.createLinearGradient(lanesLeft, glowY, lanesLeft, H);
  underGrad.addColorStop(0, 'rgba(255,255,255,0.03)');
  underGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = underGrad;
  ctx.fillRect(lanesLeft, glowY, totalLanesWidth, H - glowY);

  // Hit line glow
  ctx.shadowBlur = 15;
  ctx.shadowColor = 'rgba(255,255,255,0.3)';
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(lanesLeft, glowY);
  ctx.lineTo(lanesLeft + totalLanesWidth, glowY);
  ctx.stroke();
  ctx.shadowBlur = 0;

  // Target indicators per lane
  for (let i = 0; i < 4; i++) {
    const cx = lanesLeft + i * laneWidth + laneWidth / 2;
    const col = LANE_COLORS[i];
    const pressed = lanePressed[i];
    const r = noteRadius * (pressed ? 1.3 : 1);
    const alpha = pressed ? 0.7 : 0.2;

    // Outer ring
    ctx.beginPath();
    ctx.arc(cx, glowY, r + 4, 0, Math.PI * 2);
    ctx.strokeStyle = hexToRGBA(col, alpha * 0.5);
    ctx.lineWidth = 2;
    ctx.stroke();

    // Inner circle
    ctx.beginPath();
    ctx.arc(cx, glowY, r, 0, Math.PI * 2);
    ctx.strokeStyle = hexToRGBA(col, alpha);
    ctx.lineWidth = pressed ? 3 : 2;
    ctx.stroke();

    if (pressed) {
      ctx.beginPath();
      ctx.arc(cx, glowY, r, 0, Math.PI * 2);
      ctx.fillStyle = hexToRGBA(col, 0.15);
      ctx.fill();

      // Glow
      ctx.shadowBlur = 25;
      ctx.shadowColor = col;
      ctx.beginPath();
      ctx.arc(cx, glowY, r * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = hexToRGBA(col, 0.3);
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Key label
    ctx.font = `600 ${laneWidth * 0.22}px 'Orbitron', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = pressed ? col : hexToRGBA(col, 0.35);
    ctx.fillText(LANE_LABELS[i], cx, glowY + noteRadius + 22);
  }
}

function drawNotes(elapsed) {
  const speed = NOTE_SPEED_BASE * (selectedBPM / 120);

  for (const note of notes) {
    if (note.judged) continue;

    // Calculate y position: note appears at top and reaches hitLineY at hitTime
    const timeDiff = note.hitTime - elapsed; // seconds until hit time
    const y = hitLineY - timeDiff * speed;

    note.y = y;

    // Skip if not on screen
    if (y < -50 || y > H + 50) continue;

    const cx = lanesLeft + note.lane * laneWidth + laneWidth / 2;
    const col = LANE_COLORS[note.lane];
    const r = noteRadius;

    // Trail (glow streak above note)
    const trailLen = Math.min(80, y + 50);
    if (trailLen > 0) {
      const trailGrad = ctx.createLinearGradient(cx, y - trailLen, cx, y);
      trailGrad.addColorStop(0, 'transparent');
      trailGrad.addColorStop(1, hexToRGBA(col, 0.25));
      ctx.beginPath();
      ctx.moveTo(cx - r * 0.4, y - trailLen);
      ctx.lineTo(cx + r * 0.4, y - trailLen);
      ctx.lineTo(cx + r * 0.6, y);
      ctx.lineTo(cx - r * 0.6, y);
      ctx.closePath();
      ctx.fillStyle = trailGrad;
      ctx.fill();
    }

    // Note glow
    ctx.shadowBlur = 20;
    ctx.shadowColor = col;

    // Note body
    ctx.beginPath();
    ctx.arc(cx, y, r, 0, Math.PI * 2);
    const noteGrad = ctx.createRadialGradient(cx, y - r * 0.3, 0, cx, y, r);
    noteGrad.addColorStop(0, lightenColor(col, 40));
    noteGrad.addColorStop(0.6, col);
    noteGrad.addColorStop(1, hexToRGBA(col, 0.6));
    ctx.fillStyle = noteGrad;
    ctx.fill();

    // Note border
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // Inner highlight
    ctx.beginPath();
    ctx.arc(cx, y - r * 0.15, r * 0.45, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(255,255,255,0.15)';
    ctx.fill();

    ctx.shadowBlur = 0;
  }
}

function drawParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt;
    p.y += p.vy * dt;
    p.vy += 300 * dt; // gravity
    p.life -= p.decay * dt;

    if (p.life <= 0) { particles.splice(i, 1); continue; }

    ctx.globalAlpha = p.life;
    ctx.shadowBlur = 8;
    ctx.shadowColor = p.color;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
}

function drawJudgments(dt) {
  for (let i = judgmentPopups.length - 1; i >= 0; i--) {
    const j = judgmentPopups[i];
    j.y += j.vy * dt;
    j.life -= 2.0 * dt;

    if (j.life <= 0) { judgmentPopups.splice(i, 1); continue; }

    ctx.globalAlpha = j.life;
    ctx.font = `800 ${laneWidth * 0.28}px 'Orbitron', sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowBlur = 15;
    ctx.shadowColor = j.color;
    ctx.fillStyle = j.color;
    ctx.fillText(j.label, j.x, j.y);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
}

function drawHUD() {
  const margin = 20;
  const hudLeft = lanesLeft - 180;
  const hudRight = lanesLeft + totalLanesWidth + 20;

  // Score (top right of lane area)
  ctx.font = "300 14px 'Orbitron', sans-serif";
  ctx.textAlign = 'right';
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fillText('SCORE', lanesLeft + totalLanesWidth, 34);
  ctx.font = "700 28px 'Orbitron', sans-serif";
  ctx.fillStyle = '#fff';
  ctx.fillText(score.toLocaleString(), lanesLeft + totalLanesWidth, 62);

  // Combo (top left of lane area)
  if (combo > 0) {
    ctx.textAlign = 'left';
    ctx.font = "300 14px 'Orbitron', sans-serif";
    ctx.fillStyle = 'rgba(255,255,255,0.35)';
    ctx.fillText('COMBO', lanesLeft, 34);
    ctx.font = `800 ${Math.min(36, 28 + combo * 0.1)}px 'Orbitron', sans-serif`;
    const comboColor = combo >= 50 ? '#f59e0b' : combo >= 20 ? '#a855f7' : '#00f0ff';
    ctx.shadowBlur = combo > 10 ? 10 : 0;
    ctx.shadowColor = comboColor;
    ctx.fillStyle = comboColor;
    ctx.fillText(combo.toString(), lanesLeft, 62);
    ctx.shadowBlur = 0;

    // Multiplier
    const mult = Math.min(1 + Math.floor(combo / 10) * 0.5, 5);
    if (mult > 1) {
      ctx.font = "600 13px 'Orbitron', sans-serif";
      ctx.fillStyle = hexToRGBA(comboColor, 0.6);
      ctx.fillText('x' + mult.toFixed(1), lanesLeft, 80);
    }
  }

  // Health bar (top center)
  const hbW = totalLanesWidth * 0.5;
  const hbH = 4;
  const hbX = lanesLeft + (totalLanesWidth - hbW) / 2;
  const hbY = 15;

  ctx.fillStyle = 'rgba(255,255,255,0.05)';
  ctx.fillRect(hbX, hbY, hbW, hbH);

  const hpColor = health > 50 ? '#22c55e' : health > 25 ? '#f59e0b' : '#ef4444';
  const hpGrad = ctx.createLinearGradient(hbX, 0, hbX + hbW * (health / 100), 0);
  hpGrad.addColorStop(0, hpColor);
  hpGrad.addColorStop(1, hexToRGBA(hpColor, 0.6));
  ctx.fillStyle = hpGrad;
  ctx.fillRect(hbX, hbY, hbW * (health / 100), hbH);

  // BPM indicator
  ctx.font = "500 12px 'Orbitron', sans-serif";
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(255,255,255,0.15)';
  ctx.fillText(selectedBPM + ' BPM', W / 2, H - 12);
}

function drawCountdown(elapsed) {
  if (elapsed >= 0) return;
  const countVal = Math.ceil(-elapsed);
  if (countVal > 3) return;

  const frac = 1 - (-elapsed - Math.floor(-elapsed));
  const scale = 1 + (1 - frac) * 0.5;
  const alpha = frac;

  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.font = `900 ${80 * scale}px 'Orbitron', sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowBlur = 30;
  ctx.shadowColor = '#00f0ff';
  ctx.fillStyle = '#00f0ff';
  ctx.fillText(countVal.toString(), W / 2, H * 0.4);
  ctx.shadowBlur = 0;
  ctx.restore();
}

// ---- Main Loop ----
function gameLoop(time) {
  animFrame = requestAnimationFrame(gameLoop);
  const dt = Math.min((time - lastTime) / 1000, 0.05);
  lastTime = time;

  resize();

  const elapsed = (time - gameStartTime) / 1000; // seconds since game start (negative during countdown)

  drawBackground(dt, elapsed);
  drawLaneGlow();

  if (gameState === 'playing') {
    // Schedule beat sounds
    scheduleBeatSounds();

    // Check for missed notes (passed too far below hit line)
    const speed = NOTE_SPEED_BASE * (selectedBPM / 120);
    for (const note of notes) {
      if (!note.judged && elapsed - note.hitTime > JUDGMENTS.MISS.window / 1000) {
        missNote(note);
      }
    }

    // Check if song ended
    if (!songEnded) {
      const lastNoteTime = notes.length > 0 ? notes[notes.length - 1].hitTime : 0;
      if (elapsed > lastNoteTime + 2) {
        songEnded = true;
        endCheckTime = time + 1500; // wait 1.5s for last particles
      }
    }

    if (songEnded && time > endCheckTime) {
      endGame();
    }

    // Health death
    if (health <= 0) {
      // Mark remaining notes as missed
      for (const note of notes) {
        if (!note.judged) { note.judged = true; note.missed = true; counts.miss++; }
      }
      endGame();
    }

    drawNotes(elapsed);
    drawCountdown(elapsed);
  }

  drawHitZone();
  drawParticles(dt);
  drawJudgments(dt);

  if (gameState === 'playing') {
    drawHUD();
  }
}

// Start animation loop for menu background
lastTime = performance.now();
gameLoop(lastTime);

// ---- Utility ----
function hexToRGBA(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

function lightenColor(hex, amount) {
  let r = parseInt(hex.slice(1, 3), 16);
  let g = parseInt(hex.slice(3, 5), 16);
  let b = parseInt(hex.slice(5, 7), 16);
  r = Math.min(255, r + amount);
  g = Math.min(255, g + amount);
  b = Math.min(255, b + amount);
  return `rgb(${r},${g},${b})`;
}
</script>
</body>
</html>