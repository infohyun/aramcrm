<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>WHACK - Reflex Protocol</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
  --cyan: #00f0ff;
  --cyan-dim: #00f0ff44;
  --cyan-glow: #00f0ff88;
  --purple: #a855f7;
  --purple-dim: #a855f744;
  --purple-glow: #a855f788;
  --gold: #f59e0b;
  --gold-dim: #f59e0b44;
  --gold-glow: #f59e0b88;
  --red: #ef4444;
  --red-dim: #ef444444;
  --red-glow: #ef444488;
  --green: #22c55e;
  --bg: #05050f;
  --panel: rgba(10, 10, 30, 0.7);
  --glass: rgba(255, 255, 255, 0.03);
  --glass-border: rgba(255, 255, 255, 0.08);
  --text: #e2e8f0;
  --text-dim: rgba(255, 255, 255, 0.4);
}

html, body {
  width: 100%; height: 100%;
  overflow: hidden;
  background: var(--bg);
  font-family: 'Rajdhani', 'Noto Sans KR', sans-serif;
  color: var(--text);
  -webkit-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

body.custom-cursor { cursor: none; }
body.custom-cursor * { cursor: none; }

/* ===== CROSSHAIR ===== */
#crosshair {
  display: none;
  position: fixed;
  width: 40px; height: 40px;
  pointer-events: none;
  z-index: 9999;
  transform: translate(-50%, -50%);
}
body.custom-cursor #crosshair { display: block; }

.crosshair-ring {
  position: absolute;
  top: 50%; left: 50%;
  width: 30px; height: 30px;
  border: 2px solid var(--cyan);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 8px var(--cyan-glow), inset 0 0 8px var(--cyan-dim);
  transition: transform 0.1s ease;
}
.crosshair-dot {
  position: absolute;
  top: 50%; left: 50%;
  width: 4px; height: 4px;
  background: var(--cyan);
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 6px var(--cyan);
}
.crosshair-line {
  position: absolute;
  background: var(--cyan);
  box-shadow: 0 0 4px var(--cyan-glow);
}
.crosshair-line.h {
  width: 8px; height: 1px;
  top: 50%; transform: translateY(-50%);
}
.crosshair-line.h.l { left: 0; }
.crosshair-line.h.r { right: 0; }
.crosshair-line.v {
  width: 1px; height: 8px;
  left: 50%; transform: translateX(-50%);
}
.crosshair-line.v.t { top: 0; }
.crosshair-line.v.b { bottom: 0; }

/* ===== STAR BACKGROUND ===== */
#starfield {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 0;
  pointer-events: none;
}

/* ===== SCREEN SHAKE ===== */
@keyframes screenShake {
  0%, 100% { transform: translate(0, 0); }
  10% { transform: translate(-8px, -5px); }
  20% { transform: translate(7px, 6px); }
  30% { transform: translate(-6px, 4px); }
  40% { transform: translate(5px, -7px); }
  50% { transform: translate(-4px, 5px); }
  60% { transform: translate(6px, -3px); }
  70% { transform: translate(-3px, 6px); }
  80% { transform: translate(4px, -4px); }
  90% { transform: translate(-5px, 3px); }
}
body.shake #game-container { animation: screenShake 0.4s ease; }
body.shake-red { background: #1a0505 !important; }

/* ===== OVERLAY SYSTEM ===== */
.overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  transition: opacity 0.5s ease, visibility 0.5s ease;
  pointer-events: none;
}
.overlay.active { pointer-events: all; }
.overlay.hidden { opacity: 0; visibility: hidden; }

/* ===== MENU SCREEN ===== */
#menu {
  background: radial-gradient(ellipse at 50% 30%, rgba(0, 240, 255, 0.05) 0%, transparent 60%),
              radial-gradient(ellipse at 30% 70%, rgba(168, 85, 247, 0.04) 0%, transparent 50%);
}

.logo-container {
  text-align: center;
  margin-bottom: 40px;
  animation: logoFloat 6s ease-in-out infinite;
}

@keyframes logoFloat {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.game-title {
  font-family: 'Orbitron', monospace;
  font-size: clamp(48px, 10vw, 96px);
  font-weight: 900;
  letter-spacing: 12px;
  background: linear-gradient(135deg, var(--cyan), var(--purple), var(--cyan));
  background-size: 300% 300%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: gradientShift 4s ease-in-out infinite;
  text-shadow: none;
  filter: drop-shadow(0 0 30px var(--cyan-dim)) drop-shadow(0 0 60px var(--purple-dim));
  line-height: 1;
}

@keyframes gradientShift {
  0%, 100% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
}

.game-subtitle {
  font-family: 'Orbitron', monospace;
  font-size: clamp(12px, 2.5vw, 20px);
  font-weight: 400;
  letter-spacing: 10px;
  color: var(--text-dim);
  margin-top: 8px;
}

.menu-panel {
  background: var(--panel);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--glass-border);
  border-radius: 20px;
  padding: 40px;
  text-align: center;
  min-width: 320px;
  max-width: 400px;
  width: 90%;
}

.high-score-display {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  color: var(--gold);
  margin-bottom: 24px;
  letter-spacing: 2px;
}
.high-score-display span {
  font-size: 24px;
  font-weight: 700;
}

.btn {
  display: block;
  width: 100%;
  padding: 14px 28px;
  margin: 10px 0;
  font-family: 'Orbitron', monospace;
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 3px;
  border: 1px solid var(--cyan-dim);
  background: rgba(0, 240, 255, 0.06);
  color: var(--cyan);
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  position: relative;
  overflow: hidden;
}
.btn::before {
  content: '';
  position: absolute;
  top: 0; left: -100%;
  width: 100%; height: 100%;
  background: linear-gradient(90deg, transparent, rgba(0, 240, 255, 0.1), transparent);
  transition: left 0.5s ease;
}
.btn:hover::before { left: 100%; }
.btn:hover {
  background: rgba(0, 240, 255, 0.12);
  border-color: var(--cyan);
  box-shadow: 0 0 20px var(--cyan-dim), inset 0 0 20px rgba(0, 240, 255, 0.05);
  transform: translateY(-2px);
}
.btn:active { transform: translateY(0) scale(0.98); }

.btn-secondary {
  border-color: var(--purple-dim);
  background: rgba(168, 85, 247, 0.06);
  color: var(--purple);
}
.btn-secondary:hover {
  background: rgba(168, 85, 247, 0.12);
  border-color: var(--purple);
  box-shadow: 0 0 20px var(--purple-dim), inset 0 0 20px rgba(168, 85, 247, 0.05);
}

.btn-back {
  border-color: rgba(255,255,255,0.1);
  background: rgba(255,255,255,0.03);
  color: var(--text-dim);
  font-size: 12px;
  padding: 10px 20px;
  margin-top: 16px;
}
.btn-back:hover {
  background: rgba(255,255,255,0.06);
  border-color: rgba(255,255,255,0.2);
  color: var(--text);
  box-shadow: none;
}

.instructions {
  margin-top: 20px;
  padding-top: 20px;
  border-top: 1px solid var(--glass-border);
  text-align: left;
}
.instructions h3 {
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  letter-spacing: 3px;
  color: var(--text-dim);
  margin-bottom: 12px;
}
.inst-row {
  display: flex;
  align-items: center;
  gap: 10px;
  margin: 8px 0;
  font-size: 14px;
  color: var(--text-dim);
}
.inst-icon {
  width: 20px; height: 20px;
  border-radius: 50%;
  flex-shrink: 0;
  box-shadow: 0 0 8px;
}
.inst-icon.cyan { background: var(--cyan); box-shadow: 0 0 8px var(--cyan-dim); }
.inst-icon.gold { background: var(--gold); box-shadow: 0 0 8px var(--gold-dim); }
.inst-icon.red { background: var(--red); box-shadow: 0 0 8px var(--red-dim); }

/* ===== GAME CONTAINER ===== */
#game-container {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 5;
  display: none;
}
#game-container.active { display: flex; flex-direction: column; }

/* ===== HUD ===== */
.hud {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  background: rgba(5, 5, 15, 0.8);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--glass-border);
  z-index: 6;
  flex-shrink: 0;
}

.hud-left, .hud-right { display: flex; align-items: center; gap: 20px; }
.hud-center { display: flex; flex-direction: column; align-items: center; }

.hud-label {
  font-family: 'Orbitron', monospace;
  font-size: 9px;
  letter-spacing: 2px;
  color: var(--text-dim);
  text-transform: uppercase;
}
.hud-value {
  font-family: 'Orbitron', monospace;
  font-size: 22px;
  font-weight: 700;
  color: var(--cyan);
  text-shadow: 0 0 10px var(--cyan-dim);
}
.hud-value.score-val { color: var(--gold); text-shadow: 0 0 10px var(--gold-dim); }
.hud-value.timer-val { color: var(--cyan); }
.hud-value.timer-val.warning { color: var(--red); text-shadow: 0 0 10px var(--red-dim); animation: timerPulse 0.5s ease infinite; }

@keyframes timerPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.combo-display {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  font-weight: 600;
  color: var(--purple);
  text-shadow: 0 0 8px var(--purple-dim);
  opacity: 0;
  transition: opacity 0.3s ease, transform 0.3s ease;
  transform: scale(0.8);
}
.combo-display.show {
  opacity: 1;
  transform: scale(1);
}

.reaction-display {
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  color: var(--green);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.reaction-display.show { opacity: 1; }

/* ===== TIMER BAR ===== */
.timer-bar-container {
  width: 100%;
  height: 3px;
  background: rgba(255,255,255,0.05);
  flex-shrink: 0;
}
.timer-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--cyan), var(--purple));
  transition: width 0.1s linear;
  box-shadow: 0 0 10px var(--cyan-dim);
}
.timer-bar.warning {
  background: linear-gradient(90deg, var(--red), var(--gold));
  box-shadow: 0 0 10px var(--red-dim);
}

/* ===== GAME AREA ===== */
.game-area {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
  position: relative;
  overflow: hidden;
}

.grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: clamp(12px, 3vw, 24px);
  max-width: 520px;
  width: 100%;
}

/* ===== HOLE / PORTAL ===== */
.hole {
  position: relative;
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
}

.portal {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background: radial-gradient(circle at 50% 50%, rgba(10, 10, 30, 0.9) 0%, rgba(5, 5, 15, 0.95) 60%, rgba(0, 0, 0, 0.98) 100%);
  border: 2px solid rgba(255, 255, 255, 0.06);
  position: relative;
  overflow: hidden;
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
}

.portal::before {
  content: '';
  position: absolute;
  top: -1px; left: -1px;
  right: -1px; bottom: -1px;
  border-radius: 50%;
  background: conic-gradient(from 0deg, transparent 0%, rgba(0, 240, 255, 0.08) 25%, transparent 50%, rgba(168, 85, 247, 0.08) 75%, transparent 100%);
  animation: portalSpin 8s linear infinite;
}

@keyframes portalSpin {
  from { transform: rotate(0deg); }
  to { transform: rotate(360deg); }
}

.portal::after {
  content: '';
  position: absolute;
  top: 15%; left: 15%; right: 15%; bottom: 15%;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(0, 240, 255, 0.02) 0%, transparent 70%);
}

.portal.active {
  border-color: rgba(0, 240, 255, 0.15);
  box-shadow: 0 0 20px rgba(0, 240, 255, 0.08), inset 0 0 20px rgba(0, 240, 255, 0.03);
}

/* ===== TARGET ===== */
.target {
  position: absolute;
  top: 50%; left: 50%;
  width: 60%;
  height: 60%;
  transform: translate(-50%, -50%) scale(0);
  border-radius: 50%;
  cursor: pointer;
  z-index: 2;
  transition: transform 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
  pointer-events: none;
}
.target.visible {
  transform: translate(-50%, -50%) scale(1);
  pointer-events: all;
}
.target.hiding {
  transform: translate(-50%, -50%) scale(0);
  pointer-events: none;
  transition: transform 0.25s ease-in;
}
.target.hit {
  transform: translate(-50%, -50%) scale(1.3);
  pointer-events: none;
  opacity: 0;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

/* Target types */
.target-inner {
  width: 100%; height: 100%;
  border-radius: 50%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.target.normal .target-inner {
  background: radial-gradient(circle at 35% 35%, rgba(0, 240, 255, 0.6), rgba(0, 240, 255, 0.2) 50%, rgba(0, 240, 255, 0.05));
  border: 2px solid var(--cyan);
  box-shadow: 0 0 20px var(--cyan-dim), 0 0 40px rgba(0, 240, 255, 0.1), inset 0 0 15px var(--cyan-dim);
  animation: targetPulse 1s ease-in-out infinite;
}

.target.bonus .target-inner {
  background: radial-gradient(circle at 35% 35%, rgba(245, 158, 11, 0.7), rgba(245, 158, 11, 0.3) 50%, rgba(245, 158, 11, 0.05));
  border: 2px solid var(--gold);
  box-shadow: 0 0 25px var(--gold-dim), 0 0 50px rgba(245, 158, 11, 0.15), inset 0 0 15px var(--gold-dim);
  animation: bonusPulse 0.6s ease-in-out infinite;
}

.target.bomb .target-inner {
  background: radial-gradient(circle at 35% 35%, rgba(239, 68, 68, 0.6), rgba(239, 68, 68, 0.2) 50%, rgba(239, 68, 68, 0.05));
  border: 2px solid var(--red);
  box-shadow: 0 0 20px var(--red-dim), 0 0 40px rgba(239, 68, 68, 0.1), inset 0 0 15px var(--red-dim);
  animation: bombPulse 0.4s ease-in-out infinite;
}

@keyframes targetPulse {
  0%, 100% { box-shadow: 0 0 20px var(--cyan-dim), 0 0 40px rgba(0, 240, 255, 0.1), inset 0 0 15px var(--cyan-dim); }
  50% { box-shadow: 0 0 30px var(--cyan-glow), 0 0 60px rgba(0, 240, 255, 0.2), inset 0 0 25px var(--cyan-dim); }
}
@keyframes bonusPulse {
  0%, 100% { box-shadow: 0 0 25px var(--gold-dim), 0 0 50px rgba(245, 158, 11, 0.15), inset 0 0 15px var(--gold-dim); transform: scale(1); }
  50% { box-shadow: 0 0 35px var(--gold-glow), 0 0 70px rgba(245, 158, 11, 0.25), inset 0 0 25px var(--gold-dim); transform: scale(1.08); }
}
@keyframes bombPulse {
  0%, 100% { box-shadow: 0 0 20px var(--red-dim), 0 0 40px rgba(239, 68, 68, 0.1), inset 0 0 15px var(--red-dim); }
  50% { box-shadow: 0 0 30px var(--red-glow), 0 0 50px rgba(239, 68, 68, 0.2), inset 0 0 20px var(--red-dim); }
}

/* Target symbols */
.target-symbol {
  font-size: clamp(16px, 4vw, 28px);
  font-weight: 700;
  position: relative;
  z-index: 1;
}
.target.normal .target-symbol { color: var(--cyan); text-shadow: 0 0 10px var(--cyan); }
.target.bonus .target-symbol { color: var(--gold); text-shadow: 0 0 10px var(--gold); font-size: clamp(18px, 4.5vw, 32px); }
.target.bomb .target-symbol { color: var(--red); text-shadow: 0 0 10px var(--red); }

/* ===== FLOATING SCORE POPUP ===== */
.score-popup {
  position: absolute;
  font-family: 'Orbitron', monospace;
  font-weight: 700;
  font-size: 20px;
  pointer-events: none;
  z-index: 20;
  animation: scoreFloat 0.8s ease-out forwards;
}
.score-popup.positive { color: var(--cyan); text-shadow: 0 0 10px var(--cyan-dim); }
.score-popup.bonus-score { color: var(--gold); text-shadow: 0 0 10px var(--gold-dim); font-size: 26px; }
.score-popup.negative { color: var(--red); text-shadow: 0 0 10px var(--red-dim); }
.score-popup.combo-score { color: var(--purple); text-shadow: 0 0 10px var(--purple-dim); font-size: 16px; }

@keyframes scoreFloat {
  0% { opacity: 1; transform: translateY(0) scale(1); }
  50% { opacity: 1; transform: translateY(-30px) scale(1.1); }
  100% { opacity: 0; transform: translateY(-60px) scale(0.8); }
}

/* ===== PARTICLES ===== */
.particle {
  position: absolute;
  width: 6px; height: 6px;
  border-radius: 50%;
  pointer-events: none;
  z-index: 15;
}

/* ===== COUNTDOWN ===== */
.countdown-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  z-index: 50;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(5, 5, 15, 0.7);
  backdrop-filter: blur(5px);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}
.countdown-overlay.active { opacity: 1; pointer-events: all; }

.countdown-number {
  font-family: 'Orbitron', monospace;
  font-size: 120px;
  font-weight: 900;
  color: var(--cyan);
  text-shadow: 0 0 40px var(--cyan-dim), 0 0 80px var(--cyan-dim);
  animation: countdownPop 0.8s ease-out;
}

@keyframes countdownPop {
  0% { transform: scale(2); opacity: 0; }
  30% { transform: scale(0.9); opacity: 1; }
  50% { transform: scale(1.05); }
  100% { transform: scale(1); opacity: 0.3; }
}

/* ===== RESULTS SCREEN ===== */
#results {
  background: rgba(5, 5, 15, 0.85);
  backdrop-filter: blur(20px);
}

.results-panel {
  background: var(--panel);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  border: 1px solid var(--glass-border);
  border-radius: 20px;
  padding: 36px;
  text-align: center;
  min-width: 320px;
  max-width: 440px;
  width: 90%;
  animation: resultsSlideIn 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

@keyframes resultsSlideIn {
  0% { transform: translateY(30px) scale(0.9); opacity: 0; }
  100% { transform: translateY(0) scale(1); opacity: 1; }
}

.results-title {
  font-family: 'Orbitron', monospace;
  font-size: 28px;
  font-weight: 800;
  letter-spacing: 6px;
  margin-bottom: 6px;
  background: linear-gradient(135deg, var(--cyan), var(--purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

.results-subtitle {
  font-family: 'Orbitron', monospace;
  font-size: 10px;
  letter-spacing: 3px;
  color: var(--text-dim);
  margin-bottom: 24px;
}

.final-score {
  font-family: 'Orbitron', monospace;
  font-size: 52px;
  font-weight: 900;
  color: var(--gold);
  text-shadow: 0 0 30px var(--gold-dim);
  margin-bottom: 4px;
}

.new-high-score {
  font-family: 'Orbitron', monospace;
  font-size: 12px;
  font-weight: 600;
  color: var(--gold);
  letter-spacing: 3px;
  margin-bottom: 20px;
  animation: newHSPulse 1s ease-in-out infinite;
  display: none;
}
.new-high-score.show { display: block; }

@keyframes newHSPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.4; }
}

.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin: 20px 0;
}

.stat-card {
  background: var(--glass);
  border: 1px solid var(--glass-border);
  border-radius: 12px;
  padding: 14px 10px;
}
.stat-label {
  font-family: 'Orbitron', monospace;
  font-size: 8px;
  letter-spacing: 2px;
  color: var(--text-dim);
  text-transform: uppercase;
  margin-bottom: 6px;
}
.stat-value {
  font-family: 'Orbitron', monospace;
  font-size: 20px;
  font-weight: 700;
}
.stat-value.cyan { color: var(--cyan); }
.stat-value.purple { color: var(--purple); }
.stat-value.green { color: var(--green); }
.stat-value.gold { color: var(--gold); }
.stat-value.red { color: var(--red); }

.grade-display {
  margin: 16px 0;
}
.grade-letter {
  font-family: 'Orbitron', monospace;
  font-size: 48px;
  font-weight: 900;
  letter-spacing: 4px;
}
.grade-text {
  font-family: 'Orbitron', monospace;
  font-size: 10px;
  letter-spacing: 2px;
  color: var(--text-dim);
  margin-top: 2px;
}

/* ===== RESPONSIVE ===== */
@media (max-width: 480px) {
  .hud { padding: 8px 12px; gap: 8px; }
  .hud-left, .hud-right { gap: 10px; }
  .hud-value { font-size: 18px; }
  .hud-label { font-size: 7px; }
  .grid { gap: 10px; max-width: 340px; }
  .menu-panel, .results-panel { padding: 24px 20px; }
  .game-title { letter-spacing: 6px; }
  .game-subtitle { letter-spacing: 4px; }
  .final-score { font-size: 40px; }
  .stat-value { font-size: 16px; }
}

@media (max-height: 600px) {
  .game-area { padding: 10px; }
  .grid { max-width: 320px; gap: 10px; }
  .logo-container { margin-bottom: 20px; }
  .menu-panel { padding: 20px; }
}
</style>
</head>
<body>

<!-- CROSSHAIR CURSOR -->
<div id="crosshair">
  <div class="crosshair-ring"></div>
  <div class="crosshair-dot"></div>
  <div class="crosshair-line h l"></div>
  <div class="crosshair-line h r"></div>
  <div class="crosshair-line v t"></div>
  <div class="crosshair-line v b"></div>
</div>

<!-- STAR BACKGROUND -->
<canvas id="starfield"></canvas>

<!-- MENU SCREEN -->
<div id="menu" class="overlay active">
  <div class="logo-container">
    <div class="game-title">WHACK</div>
    <div class="game-subtitle">REFLEX PROTOCOL</div>
  </div>
  <div class="menu-panel">
    <div class="high-score-display">
      BEST SCORE <br><span id="menuHighScore">0</span>
    </div>
    <button class="btn" onclick="startGame()">START PROTOCOL</button>
    <button class="btn btn-back" onclick="location.href='/games.html'">BACK TO HUB</button>
    <div class="instructions">
      <h3>TARGETS</h3>
      <div class="inst-row"><div class="inst-icon cyan"></div> Standard Orb = +100 pts</div>
      <div class="inst-row"><div class="inst-icon gold"></div> Bonus Orb = +500 pts</div>
      <div class="inst-row"><div class="inst-icon red"></div> Bomb = -300 pts</div>
    </div>
  </div>
</div>

<!-- GAME CONTAINER -->
<div id="game-container">
  <!-- HUD -->
  <div class="hud">
    <div class="hud-left">
      <div>
        <div class="hud-label">SCORE</div>
        <div class="hud-value score-val" id="scoreDisplay">0</div>
      </div>
      <div>
        <div class="hud-label">COMBO</div>
        <div class="combo-display" id="comboDisplay">x0</div>
      </div>
    </div>
    <div class="hud-center">
      <div class="hud-label">TIME</div>
      <div class="hud-value timer-val" id="timerDisplay">30.0</div>
    </div>
    <div class="hud-right">
      <div>
        <div class="hud-label">REACTION</div>
        <div class="reaction-display" id="reactionDisplay">---ms</div>
      </div>
    </div>
  </div>
  <div class="timer-bar-container"><div class="timer-bar" id="timerBar"></div></div>

  <!-- GAME AREA -->
  <div class="game-area" id="gameArea">
    <div class="grid" id="grid"></div>
  </div>
</div>

<!-- COUNTDOWN -->
<div class="countdown-overlay" id="countdown">
  <div class="countdown-number" id="countdownNumber">3</div>
</div>

<!-- RESULTS SCREEN -->
<div id="results" class="overlay hidden">
  <div class="results-panel">
    <div class="results-title">MISSION COMPLETE</div>
    <div class="results-subtitle">PROTOCOL TERMINATED</div>
    <div class="final-score" id="finalScore">0</div>
    <div class="new-high-score" id="newHighScore">NEW HIGH SCORE!</div>
    <div class="grade-display">
      <div class="grade-letter" id="gradeLetter">A</div>
      <div class="grade-text" id="gradeText">EXCELLENT REFLEXES</div>
    </div>
    <div class="stats-grid">
      <div class="stat-card">
        <div class="stat-label">HITS</div>
        <div class="stat-value green" id="statHits">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">MISSES</div>
        <div class="stat-value red" id="statMisses">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">ACCURACY</div>
        <div class="stat-value cyan" id="statAccuracy">0%</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">AVG REACTION</div>
        <div class="stat-value purple" id="statReaction">---ms</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">BEST COMBO</div>
        <div class="stat-value gold" id="statCombo">x0</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">BEST REACTION</div>
        <div class="stat-value green" id="statBestReaction">---ms</div>
      </div>
    </div>
    <button class="btn" onclick="startGame()">RETRY PROTOCOL</button>
    <button class="btn btn-secondary" onclick="showMenu()">MAIN MENU</button>
  </div>
</div>

<script>
// ===== AUDIO ENGINE =====
const AudioEngine = (() => {
  let ctx = null;
  const getCtx = () => {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    if (ctx.state === 'suspended') ctx.resume();
    return ctx;
  };

  const playTone = (freq, duration, type = 'sine', vol = 0.15, detune = 0) => {
    try {
      const c = getCtx();
      const osc = c.createOscillator();
      const gain = c.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      osc.detune.value = detune;
      gain.gain.setValueAtTime(vol, c.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, c.currentTime + duration);
      osc.connect(gain);
      gain.connect(c.destination);
      osc.start();
      osc.stop(c.currentTime + duration);
    } catch(e) {}
  };

  const noise = (duration, vol = 0.08) => {
    try {
      const c = getCtx();
      const bufferSize = c.sampleRate * duration;
      const buffer = c.createBuffer(1, bufferSize, c.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
      const src = c.createBufferSource();
      src.buffer = buffer;
      const gain = c.createGain();
      gain.gain.setValueAtTime(vol, c.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, c.currentTime + duration);
      const filter = c.createBiquadFilter();
      filter.type = 'highpass';
      filter.frequency.value = 2000;
      src.connect(filter);
      filter.connect(gain);
      gain.connect(c.destination);
      src.start();
    } catch(e) {}
  };

  return {
    hit() {
      playTone(880, 0.12, 'sine', 0.12);
      playTone(1320, 0.08, 'sine', 0.08);
      setTimeout(() => playTone(1760, 0.1, 'sine', 0.06), 40);
    },
    miss() {
      playTone(200, 0.25, 'sawtooth', 0.06);
      playTone(150, 0.3, 'sine', 0.04);
    },
    bomb() {
      playTone(80, 0.5, 'sawtooth', 0.15);
      playTone(60, 0.6, 'square', 0.1);
      noise(0.3, 0.12);
      setTimeout(() => playTone(40, 0.4, 'sine', 0.08), 100);
    },
    bonus() {
      playTone(660, 0.1, 'sine', 0.12);
      setTimeout(() => playTone(880, 0.1, 'sine', 0.12), 60);
      setTimeout(() => playTone(1100, 0.1, 'sine', 0.12), 120);
      setTimeout(() => playTone(1320, 0.15, 'sine', 0.1), 180);
    },
    countdown() {
      playTone(440, 0.15, 'sine', 0.1);
    },
    countdownGo() {
      playTone(880, 0.2, 'sine', 0.12);
      setTimeout(() => playTone(1320, 0.3, 'sine', 0.1), 80);
    },
    gameOver() {
      playTone(440, 0.3, 'sine', 0.1);
      setTimeout(() => playTone(350, 0.3, 'sine', 0.1), 200);
      setTimeout(() => playTone(280, 0.3, 'sine', 0.1), 400);
      setTimeout(() => playTone(220, 0.6, 'sine', 0.12), 600);
    },
    pop() {
      playTone(600, 0.08, 'sine', 0.06);
      noise(0.04, 0.03);
    }
  };
})();

// ===== STARFIELD =====
const starCanvas = document.getElementById('starfield');
const starCtx = starCanvas.getContext('2d');
let stars = [];

function initStarfield() {
  starCanvas.width = window.innerWidth;
  starCanvas.height = window.innerHeight;
  stars = [];
  const count = Math.floor((starCanvas.width * starCanvas.height) / 4000);
  for (let i = 0; i < count; i++) {
    stars.push({
      x: Math.random() * starCanvas.width,
      y: Math.random() * starCanvas.height,
      r: Math.random() * 1.5 + 0.3,
      a: Math.random() * 0.6 + 0.1,
      speed: Math.random() * 0.3 + 0.05,
      pulse: Math.random() * Math.PI * 2,
      pulseSpeed: Math.random() * 0.02 + 0.005,
      color: Math.random() > 0.8 ? (Math.random() > 0.5 ? '0, 240, 255' : '168, 85, 247') : '255, 255, 255'
    });
  }
}

function animateStars() {
  starCtx.clearRect(0, 0, starCanvas.width, starCanvas.height);
  for (const s of stars) {
    s.pulse += s.pulseSpeed;
    s.y -= s.speed;
    if (s.y < -2) { s.y = starCanvas.height + 2; s.x = Math.random() * starCanvas.width; }
    const alpha = s.a * (0.5 + 0.5 * Math.sin(s.pulse));
    starCtx.beginPath();
    starCtx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    starCtx.fillStyle = `rgba(${s.color}, ${alpha})`;
    starCtx.fill();
  }
  requestAnimationFrame(animateStars);
}

// ===== CROSSHAIR =====
const crosshairEl = document.getElementById('crosshair');
const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;

if (!isMobile) {
  document.body.classList.add('custom-cursor');
  document.addEventListener('mousemove', e => {
    crosshairEl.style.left = e.clientX + 'px';
    crosshairEl.style.top = e.clientY + 'px';
  });
}

// ===== GAME STATE =====
let gameState = {
  score: 0,
  combo: 0,
  maxCombo: 0,
  hits: 0,
  misses: 0,
  totalTargets: 0,
  timeLeft: 30,
  totalTime: 30,
  running: false,
  reactionTimes: [],
  activeTargets: [],
  spawnInterval: null,
  gameLoop: null,
  lastTime: 0,
  difficulty: 1
};

let highScore = parseInt(localStorage.getItem('whack_highscore') || '0');
document.getElementById('menuHighScore').textContent = highScore;

// ===== GRID SETUP =====
const gridEl = document.getElementById('grid');
const holes = [];

function createGrid() {
  gridEl.innerHTML = '';
  holes.length = 0;
  for (let i = 0; i < 9; i++) {
    const hole = document.createElement('div');
    hole.className = 'hole';
    hole.innerHTML = `
      <div class="portal" id="portal-${i}">
        <div class="target" id="target-${i}" data-index="${i}">
          <div class="target-inner">
            <div class="target-symbol"></div>
          </div>
        </div>
      </div>
    `;
    gridEl.appendChild(hole);
    holes.push({
      el: hole,
      portal: null,
      target: null,
      active: false,
      type: null,
      spawnTime: 0,
      timeout: null
    });
  }
  // Set references after DOM insertion
  for (let i = 0; i < 9; i++) {
    holes[i].portal = document.getElementById(`portal-${i}`);
    holes[i].target = document.getElementById(`target-${i}`);
  }
}

// ===== GAME FUNCTIONS =====
function getSpawnDelay() {
  const elapsed = gameState.totalTime - gameState.timeLeft;
  const progress = elapsed / gameState.totalTime;
  // Start at 1200ms, go down to 500ms
  return Math.max(500, 1200 - progress * 700);
}

function getTargetDuration() {
  const elapsed = gameState.totalTime - gameState.timeLeft;
  const progress = elapsed / gameState.totalTime;
  // Start at 1400ms, go down to 600ms
  return Math.max(600, 1400 - progress * 800);
}

function getTargetType() {
  const r = Math.random();
  if (r < 0.12) return 'bomb';
  if (r < 0.18) return 'bonus';
  return 'normal';
}

function getSymbol(type) {
  if (type === 'normal') {
    const symbols = ['\u25C6', '\u25CE', '\u2B22', '\u25C9'];
    return symbols[Math.floor(Math.random() * symbols.length)];
  }
  if (type === 'bonus') return '\u2605';
  if (type === 'bomb') return '\u2622';
  return '\u25CF';
}

function spawnTarget() {
  if (!gameState.running) return;

  const available = [];
  for (let i = 0; i < 9; i++) {
    if (!holes[i].active) available.push(i);
  }
  if (available.length === 0) return;

  const idx = available[Math.floor(Math.random() * available.length)];
  const hole = holes[idx];
  const type = getTargetType();
  const duration = getTargetDuration();

  hole.active = true;
  hole.type = type;
  hole.spawnTime = performance.now();
  gameState.totalTargets++;

  const target = hole.target;
  target.className = `target ${type}`;
  target.querySelector('.target-symbol').textContent = getSymbol(type);
  hole.portal.classList.add('active');

  // Pop up
  requestAnimationFrame(() => {
    target.classList.add('visible');
    AudioEngine.pop();
  });

  // Auto-hide after duration
  hole.timeout = setTimeout(() => {
    if (hole.active && gameState.running) {
      hideTarget(idx, false);
    }
  }, duration);

  // Schedule next spawn
  if (gameState.running) {
    const delay = getSpawnDelay();
    // Sometimes spawn two at once for difficulty
    const elapsed = gameState.totalTime - gameState.timeLeft;
    const extraSpawnChance = Math.min(0.4, elapsed / gameState.totalTime * 0.5);

    gameState.spawnInterval = setTimeout(() => {
      spawnTarget();
      if (Math.random() < extraSpawnChance) {
        setTimeout(() => spawnTarget(), 100 + Math.random() * 200);
      }
    }, delay);
  }
}

function hideTarget(idx, wasHit) {
  const hole = holes[idx];
  if (!hole.active) return;

  clearTimeout(hole.timeout);
  hole.active = false;
  hole.portal.classList.remove('active');

  const target = hole.target;
  if (wasHit) {
    target.classList.remove('visible');
    target.classList.add('hit');
    setTimeout(() => { target.className = 'target'; }, 200);
  } else {
    // Missed - target retreats
    if (hole.type !== 'bomb') {
      gameState.misses++;
      gameState.combo = 0;
      updateComboDisplay();
    }
    target.classList.remove('visible');
    target.classList.add('hiding');
    setTimeout(() => { target.className = 'target'; }, 300);
  }
}

function hitTarget(idx) {
  const hole = holes[idx];
  if (!hole.active || !gameState.running) return;

  const reactionTime = performance.now() - hole.spawnTime;
  const type = hole.type;
  const rect = hole.target.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;

  hideTarget(idx, true);

  if (type === 'bomb') {
    // Bomb hit - penalty
    gameState.score = Math.max(0, gameState.score - 300);
    gameState.combo = 0;
    updateComboDisplay();
    AudioEngine.bomb();
    spawnParticles(cx, cy, '#ef4444', 20);
    showScorePopup(cx, cy, '-300', 'negative');
    screenShake();
  } else {
    // Successful hit
    gameState.hits++;
    gameState.combo++;
    if (gameState.combo > gameState.maxCombo) gameState.maxCombo = gameState.combo;
    gameState.reactionTimes.push(reactionTime);

    let points;
    if (type === 'bonus') {
      points = 500;
      AudioEngine.bonus();
      spawnParticles(cx, cy, '#f59e0b', 25);
      showScorePopup(cx, cy, '+500', 'bonus-score');
    } else {
      points = 100;
      AudioEngine.hit();
      spawnParticles(cx, cy, '#00f0ff', 15);
      showScorePopup(cx, cy, '+100', 'positive');
    }

    // Combo bonus
    if (gameState.combo >= 3) {
      const comboBonus = Math.floor(gameState.combo * 15);
      points += comboBonus;
      setTimeout(() => {
        showScorePopup(cx, cy - 30, `COMBO x${gameState.combo}`, 'combo-score');
      }, 150);
    }

    gameState.score += points;
    updateComboDisplay();

    // Show reaction time
    const rtEl = document.getElementById('reactionDisplay');
    rtEl.textContent = Math.round(reactionTime) + 'ms';
    rtEl.classList.add('show');
    setTimeout(() => rtEl.classList.remove('show'), 1500);
  }

  document.getElementById('scoreDisplay').textContent = gameState.score;
  animateScoreDisplay();
}

function animateScoreDisplay() {
  const el = document.getElementById('scoreDisplay');
  el.style.transform = 'scale(1.2)';
  el.style.transition = 'transform 0.15s ease';
  setTimeout(() => {
    el.style.transform = 'scale(1)';
  }, 150);
}

function updateComboDisplay() {
  const el = document.getElementById('comboDisplay');
  if (gameState.combo >= 2) {
    el.textContent = `x${gameState.combo}`;
    el.classList.add('show');
    el.style.transform = 'scale(1.3)';
    el.style.transition = 'transform 0.15s ease';
    setTimeout(() => { el.style.transform = 'scale(1)'; }, 150);
  } else {
    el.classList.remove('show');
  }
}

function showScorePopup(x, y, text, cls) {
  const popup = document.createElement('div');
  popup.className = `score-popup ${cls}`;
  popup.textContent = text;
  popup.style.left = x + 'px';
  popup.style.top = (y - 20) + 'px';
  document.body.appendChild(popup);
  setTimeout(() => popup.remove(), 800);
}

function spawnParticles(x, y, color, count) {
  for (let i = 0; i < count; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.style.left = x + 'px';
    p.style.top = y + 'px';
    p.style.background = color;
    p.style.boxShadow = `0 0 6px ${color}`;
    p.style.width = (Math.random() * 5 + 3) + 'px';
    p.style.height = p.style.width;
    document.body.appendChild(p);

    const angle = (Math.PI * 2 / count) * i + (Math.random() - 0.5) * 0.5;
    const speed = 60 + Math.random() * 100;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const life = 400 + Math.random() * 300;
    const startTime = performance.now();

    function animateParticle() {
      const elapsed = performance.now() - startTime;
      const progress = elapsed / life;
      if (progress >= 1) { p.remove(); return; }
      const px = x + vx * progress;
      const py = y + vy * progress + 40 * progress * progress;
      p.style.left = px + 'px';
      p.style.top = py + 'px';
      p.style.opacity = 1 - progress;
      p.style.transform = `scale(${1 - progress * 0.5})`;
      requestAnimationFrame(animateParticle);
    }
    requestAnimationFrame(animateParticle);
  }
}

function screenShake() {
  document.body.classList.add('shake', 'shake-red');
  setTimeout(() => {
    document.body.classList.remove('shake', 'shake-red');
  }, 400);
}

// ===== GAME TIMER =====
function updateTimer() {
  if (!gameState.running) return;

  const now = performance.now();
  const dt = (now - gameState.lastTime) / 1000;
  gameState.lastTime = now;
  gameState.timeLeft -= dt;

  if (gameState.timeLeft <= 0) {
    gameState.timeLeft = 0;
    endGame();
    return;
  }

  const timerEl = document.getElementById('timerDisplay');
  timerEl.textContent = gameState.timeLeft.toFixed(1);

  const pct = (gameState.timeLeft / gameState.totalTime) * 100;
  const bar = document.getElementById('timerBar');
  bar.style.width = pct + '%';

  if (gameState.timeLeft <= 10) {
    timerEl.classList.add('warning');
    bar.classList.add('warning');
  } else {
    timerEl.classList.remove('warning');
    bar.classList.remove('warning');
  }

  gameState.gameLoop = requestAnimationFrame(updateTimer);
}

// ===== START / END =====
function startGame() {
  // Reset state
  gameState = {
    score: 0,
    combo: 0,
    maxCombo: 0,
    hits: 0,
    misses: 0,
    totalTargets: 0,
    timeLeft: 30,
    totalTime: 30,
    running: false,
    reactionTimes: [],
    activeTargets: [],
    spawnInterval: null,
    gameLoop: null,
    lastTime: 0,
    difficulty: 1
  };

  // Reset UI
  document.getElementById('scoreDisplay').textContent = '0';
  document.getElementById('timerDisplay').textContent = '30.0';
  document.getElementById('timerDisplay').classList.remove('warning');
  document.getElementById('timerBar').style.width = '100%';
  document.getElementById('timerBar').classList.remove('warning');
  document.getElementById('comboDisplay').classList.remove('show');
  document.getElementById('reactionDisplay').classList.remove('show');

  // Clear all targets
  for (let i = 0; i < 9; i++) {
    if (holes[i]) {
      clearTimeout(holes[i].timeout);
      holes[i].active = false;
      if (holes[i].target) holes[i].target.className = 'target';
      if (holes[i].portal) holes[i].portal.classList.remove('active');
    }
  }

  // Show game
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('menu').classList.remove('active');
  document.getElementById('results').classList.add('hidden');
  document.getElementById('results').classList.remove('active');
  document.getElementById('game-container').classList.add('active');

  // Countdown
  showCountdown();
}

function showCountdown() {
  const overlay = document.getElementById('countdown');
  const numEl = document.getElementById('countdownNumber');
  overlay.classList.add('active');

  let count = 3;
  numEl.textContent = count;
  numEl.style.animation = 'none';
  void numEl.offsetWidth;
  numEl.style.animation = 'countdownPop 0.8s ease-out';
  AudioEngine.countdown();

  const interval = setInterval(() => {
    count--;
    if (count > 0) {
      numEl.textContent = count;
      numEl.style.animation = 'none';
      void numEl.offsetWidth;
      numEl.style.animation = 'countdownPop 0.8s ease-out';
      AudioEngine.countdown();
    } else if (count === 0) {
      numEl.textContent = 'GO';
      numEl.style.color = 'var(--green)';
      numEl.style.textShadow = '0 0 40px rgba(34, 197, 94, 0.4), 0 0 80px rgba(34, 197, 94, 0.2)';
      numEl.style.animation = 'none';
      void numEl.offsetWidth;
      numEl.style.animation = 'countdownPop 0.8s ease-out';
      AudioEngine.countdownGo();
    } else {
      clearInterval(interval);
      overlay.classList.remove('active');
      numEl.style.color = '';
      numEl.style.textShadow = '';
      beginGame();
    }
  }, 800);
}

function beginGame() {
  gameState.running = true;
  gameState.lastTime = performance.now();
  updateTimer();

  // Start spawning
  setTimeout(() => spawnTarget(), 400);
}

function endGame() {
  gameState.running = false;
  clearTimeout(gameState.spawnInterval);
  cancelAnimationFrame(gameState.gameLoop);

  // Clear remaining targets
  for (let i = 0; i < 9; i++) {
    if (holes[i] && holes[i].active) {
      clearTimeout(holes[i].timeout);
      holes[i].active = false;
      holes[i].target.className = 'target';
      holes[i].portal.classList.remove('active');
    }
  }

  AudioEngine.gameOver();

  // Calculate stats
  const totalAttempts = gameState.hits + gameState.misses;
  const accuracy = totalAttempts > 0 ? Math.round((gameState.hits / totalAttempts) * 100) : 0;
  const avgReaction = gameState.reactionTimes.length > 0
    ? Math.round(gameState.reactionTimes.reduce((a, b) => a + b, 0) / gameState.reactionTimes.length)
    : 0;
  const bestReaction = gameState.reactionTimes.length > 0
    ? Math.round(Math.min(...gameState.reactionTimes))
    : 0;

  // Check high score
  const isNewHigh = gameState.score > highScore;
  if (isNewHigh) {
    highScore = gameState.score;
    localStorage.setItem('whack_highscore', highScore.toString());
    document.getElementById('menuHighScore').textContent = highScore;
  }

  // Grade
  const { letter, text, color } = calculateGrade(gameState.score, accuracy, avgReaction);

  // Update results
  document.getElementById('finalScore').textContent = gameState.score;
  document.getElementById('newHighScore').classList.toggle('show', isNewHigh);
  document.getElementById('statHits').textContent = gameState.hits;
  document.getElementById('statMisses').textContent = gameState.misses;
  document.getElementById('statAccuracy').textContent = accuracy + '%';
  document.getElementById('statReaction').textContent = avgReaction > 0 ? avgReaction + 'ms' : '---';
  document.getElementById('statCombo').textContent = 'x' + gameState.maxCombo;
  document.getElementById('statBestReaction').textContent = bestReaction > 0 ? bestReaction + 'ms' : '---';

  const gradeEl = document.getElementById('gradeLetter');
  gradeEl.textContent = letter;
  gradeEl.style.color = color;
  gradeEl.style.textShadow = `0 0 20px ${color}44`;
  document.getElementById('gradeText').textContent = text;

  // Show results
  setTimeout(() => {
    document.getElementById('game-container').classList.remove('active');
    document.getElementById('results').classList.remove('hidden');
    document.getElementById('results').classList.add('active');
  }, 600);
}

function calculateGrade(score, accuracy, avgReaction) {
  // Composite scoring
  let grade;
  if (score >= 5000 && accuracy >= 85 && avgReaction < 400) {
    grade = { letter: 'S+', text: 'SUPERHUMAN REFLEXES', color: '#f59e0b' };
  } else if (score >= 4000 && accuracy >= 80) {
    grade = { letter: 'S', text: 'ELITE OPERATOR', color: '#f59e0b' };
  } else if (score >= 3000 && accuracy >= 70) {
    grade = { letter: 'A', text: 'EXCELLENT REFLEXES', color: '#22c55e' };
  } else if (score >= 2000 && accuracy >= 60) {
    grade = { letter: 'B', text: 'SHARP REFLEXES', color: '#00f0ff' };
  } else if (score >= 1200) {
    grade = { letter: 'C', text: 'ADEQUATE RESPONSE', color: '#a855f7' };
  } else if (score >= 600) {
    grade = { letter: 'D', text: 'SLOW RESPONSE', color: '#ef4444' };
  } else {
    grade = { letter: 'F', text: 'PROTOCOL FAILURE', color: '#ef4444' };
  }
  return grade;
}

function showMenu() {
  document.getElementById('results').classList.add('hidden');
  document.getElementById('results').classList.remove('active');
  document.getElementById('game-container').classList.remove('active');
  document.getElementById('menu').classList.remove('hidden');
  document.getElementById('menu').classList.add('active');
}

// ===== EVENT HANDLERS =====
function handleClick(e) {
  if (!gameState.running) return;

  // Check if a target was clicked
  const target = e.target.closest('.target.visible');
  if (target) {
    const idx = parseInt(target.dataset.index);
    hitTarget(idx);
  }
}

document.addEventListener('mousedown', handleClick);
document.addEventListener('touchstart', e => {
  // Prevent double-firing on mobile
  e.preventDefault();
  const touch = e.touches[0];
  const el = document.elementFromPoint(touch.clientX, touch.clientY);
  if (el) {
    const fakeEvent = { target: el };
    handleClick(fakeEvent);
  }
}, { passive: false });

// ===== CLICK EFFECT ON CROSSHAIR =====
if (!isMobile) {
  document.addEventListener('mousedown', () => {
    const ring = crosshairEl.querySelector('.crosshair-ring');
    ring.style.transform = 'translate(-50%, -50%) scale(0.8)';
    ring.style.borderColor = '#ffffff';
    setTimeout(() => {
      ring.style.transform = 'translate(-50%, -50%) scale(1)';
      ring.style.borderColor = '';
    }, 100);
  });
}

// ===== RESIZE =====
window.addEventListener('resize', () => {
  initStarfield();
});

// ===== INIT =====
createGrid();
initStarfield();
animateStars();
</script>
</body>
</html>